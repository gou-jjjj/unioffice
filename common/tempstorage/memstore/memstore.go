//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package memstore implements tempStorage interface
// by using memory as a storage
package memstore

import (
	_bgc "encoding/hex"
	_bg "errors"
	_b "fmt"
	_e "io"
	_a "io/ioutil"
	_cd "math/rand"
	_g "sync"

	_gb "github.com/gou-jjjj/unioffice/common/tempstorage"
)

type memStorage struct{ _bf _g.Map }
type memFile struct {
	_ae *memDataCell
	_ad int64
}

// Write writes to the end of the underlying memDataCell in order to implement Writer interface
func (_dgf *memFile) Write(p []byte) (int, error) {
	_dgf._ae._ab = append(_dgf._ae._ab, p...)
	_dgf._ae._gf += int64(len(p))
	return len(p), nil
}

// Open returns tempstorage File object by name
func (_af *memStorage) Open(path string) (_gb.File, error) {
	_ac, _gc := _af._bf.Load(path)
	if !_gc {
		return nil, _bg.New(_b.Sprintf("\u0043\u0061\u006eno\u0074\u0020\u006f\u0070\u0065\u006e\u0020\u0074\u0068\u0065\u0020\u0066\u0069\u006c\u0065\u0020\u0025\u0073", path))
	}
	return &memFile{_ae: _ac.(*memDataCell)}, nil
}

type memDataCell struct {
	_gae string
	_ab  []byte
	_gf  int64
}

// TempFile creates a new empty file in the storage and returns it
func (_abe *memStorage) TempFile(dir, pattern string) (_gb.File, error) {
	_be := dir + "\u002f" + _cdd(pattern)
	_eg := &memDataCell{_gae: _be, _ab: []byte{}}
	_egg := &memFile{_ae: _eg}
	_abe._bf.Store(_be, _eg)
	return _egg, nil
}

// TempDir creates a name for a new temp directory using a pattern argument
func (_aa *memStorage) TempDir(pattern string) (string, error) { return _cdd(pattern), nil }
func _bc(_dbe int) (string, error) {
	_ddd := make([]byte, _dbe)
	if _, _bgf := _cd.Read(_ddd); _bgf != nil {
		return "", _bgf
	}
	return _bgc.EncodeToString(_ddd), nil
}

// Read reads from the underlying memDataCell in order to implement Reader interface
func (_cb *memFile) Read(p []byte) (int, error) {
	_cc := _cb._ad
	_ed := _cb._ae._gf
	_f := int64(len(p))
	if _f > _ed {
		_f = _ed
		p = p[:_f]
	}
	if _cc >= _ed {
		return 0, _e.EOF
	}
	_d := _cc + _f
	if _d >= _ed {
		_d = _ed
	}
	_dc := copy(p, _cb._ae._ab[_cc:_d])
	_cb._ad = _d
	return _dc, nil
}

// Close is not applicable in this implementation
func (_gg *memFile) Close() error { return nil }

// SetAsStorage sets temp storage as a memory storage
func SetAsStorage() { _gaef := memStorage{_bf: _g.Map{}}; _gb.SetAsStorage(&_gaef) }

// Name returns the filename of the underlying memDataCell
func (_ef *memFile) Name() string { return _ef._ae._gae }

// ReadAt reads from the underlying memDataCell at an offset provided in order to implement ReaderAt interface.
// It does not affect f.readOffset.
func (_ga *memFile) ReadAt(p []byte, readOffset int64) (int, error) {
	_dg := _ga._ae._gf
	_dcd := int64(len(p))
	if _dcd > _dg {
		_dcd = _dg
		p = p[:_dcd]
	}
	if readOffset >= _dg {
		return 0, _e.EOF
	}
	_ag := readOffset + _dcd
	if _ag >= _dg {
		_ag = _dg
	}
	_db := copy(p, _ga._ae._ab[readOffset:_ag])
	return _db, nil
}
func _cdd(_aag string) string { _df, _ := _bc(6); return _aag + _df }

// RemoveAll removes all files according to the dir argument prefix
func (_bd *memStorage) RemoveAll(dir string) error {
	_bd._bf.Range(func(_ff, _ge interface{}) bool { _bd._bf.Delete(_ff); return true })
	return nil
}

// Add reads a file from a disk and adds it to the storage
func (_ee *memStorage) Add(path string) error {
	_, _cdf := _ee._bf.Load(path)
	if _cdf {
		return nil
	}
	_dd, _abc := _a.ReadFile(path)
	if _abc != nil {
		return _abc
	}
	_ee._bf.Store(path, &memDataCell{_gae: path, _ab: _dd, _gf: int64(len(_dd))})
	return nil
}
