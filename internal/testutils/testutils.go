//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package testutils

import (
	_b "archive/zip"
	_gc "bufio"
	_eg "bytes"
	_fd "crypto/md5"
	_ad "encoding/hex"
	_db "encoding/json"
	_gdf "encoding/xml"
	_ag "errors"
	_ac "flag"
	_fb "fmt"
	_gfc "github.com/stretchr/testify/require"
	_bcc "github.com/unidoc/unipdf/v4/common"
	_ge "golang.org/x/image/font"
	_acb "golang.org/x/image/font/opentype"
	_dbf "golang.org/x/image/math/fixed"
	_ee "image"
	_c "image/color"
	_e "image/draw"
	_bc "image/png"
	_gb "io"
	_g "io/ioutil"
	_gfd "log"
	_f "math"
	_bf "os"
	_bg "os/exec"
	_cf "path/filepath"
	_a "strings"
	_gf "sync"
	_gd "testing"
	_dd "time"
	_gdg "unioffice"
)

func _agc(_fca, _gacg _ee.Rectangle) bool {
	return _fca.Min.X == _gacg.Min.X && _fca.Min.Y == _gacg.Min.Y && _fca.Max.X == _gacg.Max.X && _fca.Max.Y == _gacg.Max.Y
}
func (_cbdc *ReferenceMap) Write(key string, entry ReferenceEntry) {
	_cbdc.Lock()
	defer _cbdc.Unlock()
	if _cbdc._egc == nil {
		_cbdc._egc = map[string]ReferenceEntry{}
	}
	_cbdc._egc[key] = entry
}
func CompareImages(img1, img2 _ee.Image) (bool, error) {
	_feb := img1.Bounds()
	_ege := 0
	for _bbf := 0; _bbf < _feb.Size().X; _bbf++ {
		for _aed := 0; _aed < _feb.Size().Y; _aed++ {
			_fgc, _fbe, _bga, _ := img1.At(_bbf, _aed).RGBA()
			_efa, _bffe, _dgf, _ := img2.At(_bbf, _aed).RGBA()
			if _fgc != _efa || _fbe != _bffe || _bga != _dgf {
				_ege++
			}
		}
	}
	_gac := float64(_ege) / float64(_feb.Dx()*_feb.Dy())
	if _gac > 0.0001 {
		_fb.Printf("\u0064\u0069\u0066f \u0066\u0072\u0061\u0063\u0074\u0069\u006f\u006e\u003a\u0020\u0025\u0076\u0020\u0028\u0025\u0064\u0029\u000a", _gac, _ege)
		return false, nil
	}
	return true, nil
}
func _gfde(_aeab *_gd.T, _cba string) int64 {
	_bcfg, _ffaa := _bf.Stat(_cba)
	_gfc.NoError(_aeab, _ffaa)
	return _bcfg.Size()
}
func _dgee(_aab string) error {
	_bd := _gdg.XSDAny{}
	_bgc, _fbcc := _bf.Open(_aab)
	if _fbcc != nil {
		return _fbcc
	}
	_baf := _gdf.NewDecoder(_bgc)
	if _fbcc = _baf.Decode(&_bd); _fbcc != nil {
		return _fbcc
	}
	_bgc.Close()
	_bgc, _fbcc = _bf.Create(_aab)
	if _fbcc != nil {
		return _fbcc
	}
	defer _bgc.Close()
	_afb := _gdf.NewEncoder(_bgc)
	_afb.Indent("", "\u0020\u0020")
	return _afb.Encode(&_bd)
}
func (_ab *ReferenceMap) Read(key string) (ReferenceEntry, bool) {
	_ab.Lock()
	defer _ab.Unlock()
	if _ab._egc == nil {
		return ReferenceEntry{}, false
	}
	_gca, _gbca := _ab._egc[key]
	return _gca, _gbca
}
func (_cac *ReferenceMap) Keys() (_dc []string) {
	_dc = make([]string, len(_cac._egc))
	var _bdg int
	for _ebe := range _cac._egc {
		_dc[_bdg] = _ebe
		_bdg++
	}
	return _dc
}
func _ff(_fbg *_gd.T, _acd, _bccgd []byte) {
	_gg := _fgb("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064")
	_bf.WriteFile(_gg, _acd, 0644)
	_cfe := _fgb("\u0067\u006f\u0074")
	_bf.WriteFile(_cfe, _bccgd, 0644)
	defer func() { _bf.Remove(_gg); _bf.Remove(_cfe) }()
	_dgee(_gg)
	_dgee(_cfe)
	_gbac := _bg.Command("\u0064\u0069\u0066\u0066", "\u002d\u0075", _gg, _cfe)
	_ca, _gbaf := _gbac.StdoutPipe()
	if _gbaf != nil {
		_fbg.Fatalf("e\u0072\u0072\u006f\u0072\u0020\u0072u\u006e\u006e\u0069\u006e\u0067\u0020\u0078\u006d\u006ci\u006e\u0064\u0065n\u0074:\u0020\u0025\u0073", _gbaf)
	}
	defer _ca.Close()
	_aea, _gbaf := _gbac.StderrPipe()
	if _gbaf != nil {
		_fbg.Fatalf("e\u0072\u0072\u006f\u0072\u0020\u0072u\u006e\u006e\u0069\u006e\u0067\u0020\u0078\u006d\u006ci\u006e\u0064\u0065n\u0074:\u0020\u0025\u0073", _gbaf)
	}
	defer _aea.Close()
	if _aad := _gbac.Start(); _aad != nil {
		_fbg.Fatalf("\u0065\u0072\u0072\u006f\u0072\u0020\u0073\u0074\u0072\u0069\u006eg\u0020\u0078\u006d\u006c\u0069\u006e\u0064\u0065\u006e\u0074:\u0020\u0025\u0073", _aad)
	}
	_cda := _gc.NewScanner(_ca)
	for _cda.Scan() {
		_gfd.Println(_cda.Text())
	}
	if _agf := _gbac.Wait(); _agf != nil {
		_fbd, _ := _gb.ReadAll(_aea)
		_fbg.Fatalf("e\u0072\u0072\u006f\u0072\u0020\u0077a\u0069\u0074\u0069\u006e\u0067\u0020o\u006e\u0020\u0078\u006d\u006c\u0069\u006ed\u0065\u006e\u0074\u003a\u0020\u0025\u0073\u0020\u005b\u0025s\u005d", string(_fbd), _agf)
	}
}

type ReferenceEntry struct {
	Timestamp   int64   `json:"timestamp"`
	Value       string  `json:"value"`
	ResultSize  int64   `json:"resultSize,omitempty"`
	DiffPercent float64 `json:"diffPercent,omitempty"`
	DiffTotal   float64 `json:"diffValue,omitempty"`
	Invalid     bool    `json:"markedInvalid,omitempty"`
}

func HashFile(file string) (string, error) {
	_beg, _gbg := _bf.Open(file)
	if _gbg != nil {
		return "", _gbg
	}
	defer _beg.Close()
	_dfc := _fd.New()
	if _, _gbg = _gb.Copy(_dfc, _beg); _gbg != nil {
		return "", _gbg
	}
	return _ad.EncodeToString(_dfc.Sum(nil)), nil
}
func CompareZip(t *_gd.T, expectedFn string, got []byte, cmpFileContents bool) {
	_aa := _cf.Join("\u0074\u0065\u0073\u0074\u0064\u0061\u0074\u0061", expectedFn)
	_da, _cbd := _b.NewReader(_eg.NewReader(got), int64(len(got)))
	if _cbd != nil {
		t.Fatalf("\u0075\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0074\u0065\u0073\u0074\u0020\u0069\u006e\u0070\u0075\u0074: \u0025\u0073", _cbd)
	}
	_gda, _cbd := _bf.Open(_aa)
	if _cbd != nil {
		t.Fatalf("\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020r\u0065\u0061\u0064\u0020\u0067\u006f\u006cd\u0065\u006e\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _cbd)
	}
	defer _gda.Close()
	_cfc, _cbd := _bf.Stat(_aa)
	if _cbd != nil {
		t.Errorf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _cbd)
	}
	_egf, _cbd := _b.NewReader(_gda, _cfc.Size())
	if _cbd != nil {
		t.Errorf("\u0075\u006e\u0061bl\u0065\u0020\u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0066\u0069\u006c\u0065\u003a\u0020\u0025\u0073", _cbd)
	}
	t.Run(expectedFn, _gfe(_egf, _da, cmpFileContents))
}
func _bcd(_gfa, _eadg string) error {
	_bdc, _dfb := _bf.Open(_gfa)
	if _dfb != nil {
		return _dfb
	}
	defer _bdc.Close()
	_edb, _, _dfb := _ee.DecodeConfig(_bdc)
	if _dfb != nil {
		panic(_dfb)
	}
	_cbf := _ee.NewRGBA(_ee.Rect(0, 0, _edb.Width, _edb.Height))
	_gbcc, _dfb := _bf.Create(_eadg)
	if _dfb != nil {
		return _dfb
	}
	defer _gbcc.Close()
	_dfb = _bc.Encode(_gbcc, _cbf)
	if _dfb != nil {
		return _dfb
	}
	return nil
}
func (_agg *ReferenceMap) MarshalJSON() ([]byte, error)    { return _db.Marshal(_agg._egc) }
func (_ebdg *ReferenceMap) Len() int                       { return len(_ebdg._egc) }
func (_aeb *ReferenceMap) UnmarshalJSON(data []byte) error { return _db.Unmarshal(data, &_aeb._egc) }
func _fe(_bac, _ccc *_b.File) func(_dge *_gd.T) {
	return func(_cefa *_gd.T) {
		_bad, _fc := _bac.Open()
		if _fc != nil {
			_cefa.Errorf("\u0065\u0072r\u006f\u0072\u0020o\u0070\u0065\u006e\u0069\u006e\u0067\u0020\u0025\u0073", _bac.Name)
		}
		defer _bad.Close()
		_dac, _fc := _ccc.Open()
		if _fc != nil {
			_cefa.Errorf("\u0065\u0072r\u006f\u0072\u0020o\u0070\u0065\u006e\u0069\u006e\u0067\u0020\u0025\u0073", _ccc.Name)
		}
		defer _dac.Close()
		_fda, _ := _gb.ReadAll(_bad)
		_ead, _ := _gb.ReadAll(_dac)
		if !_eg.Equal(_fda, _ead) {
			_ff(_cefa, _fda, _ead)
			_fb.Println(string(_fda))
			_fb.Println(string(_ead))
			_cefa.Errorf("\u006d\u0069\u0073\u006da\u0074\u0063\u0068\u0065\u0064\u0020\u0063\u006f\u006e\u0074e\u006et\u0073\u0020\u0025\u0064\u0020\u0076\u0073 \u0025\u0064", len(_fda), len(_ead))
		}
	}
}

var (
	ErrRenderNotSupported = _ag.New("\u0072\u0065\u006e\u0064\u0065r\u0069\u006e\u0067\u0020\u0050\u0044\u0046\u0020\u0066\u0069\u006c\u0065\u0073 \u0069\u0073\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u006f\u006e\u0020\u0074\u0068\u0069\u0073\u0020\u0073\u0079\u0073\u0074\u0065m")
	ErrImageSizeNotMatch  = _ag.New("\u0069\u006d\u0061ge\u0020\u0073\u0069\u007a\u0065\u0073\u0020\u0064\u006f\u006e\u0027\u0074\u0020\u006d\u0061\u0074\u0063\u0068")
)

func ReadFile(dirPath, testName string, createEmpty bool) (*ReferenceFile, error) {
	if dirPath == "" && createEmpty {
		return &ReferenceFile{Map: &ReferenceMap{}}, nil
	}
	if dirPath == "" {
		return nil, _bf.ErrNotExist
	}
	_fcc := _cf.Join(dirPath, testName+"\u005fr\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u002e\u006a\u0073\u006f\u006e")
	_fce := &ReferenceFile{_ga: _fcc}
	_fcee, _bca := _bf.Open(_fcc)
	if _ag.Is(_bca, _bf.ErrNotExist) && createEmpty {
		_fce.Timestamp = _dd.Now().UTC()
		_fce.Map = &ReferenceMap{}
		return _fce, nil
	}
	if _bca != nil {
		return nil, _bca
	}
	defer _fcee.Close()
	if _aadf := _db.NewDecoder(_fcee).Decode(_fce); _aadf != nil {
		if _aadf.Error() == "i\u006c\u006c\u0065\u0067\u0061\u006c \u0062\u0061\u0073\u0065\u0036\u0034 \u0064\u0061\u0074\u0061\u0020\u0061\u0074 \u0069\u006e\u0070\u0075\u0074\u0020\u0062\u0079\u0074\u0065 \u0030" && createEmpty {
			return _fce, nil
		}
		return nil, _aadf
	}
	return _fce, nil
}
func CompareGoldenXML(t *_gd.T, expectedFn string, got []byte) {
	_ce := _cf.Join("\u0074\u0065\u0073\u0074\u0064\u0061\u0074\u0061", expectedFn)
	if *_cc {
		if _fbc := _bf.WriteFile(_ce, got, 0644); _fbc != nil {
			t.Fatal(_fbc)
		}
	}
	_cg, _cb := _bf.ReadFile(_ce)
	if _cb != nil {
		t.Fatalf("\u0075\u006e\u0061\u0062\u006c\u0065 \u0074\u006f\u0020\u0072\u0065\u0061\u0064\u0020\u0065\u0078\u0070\u0065\u0063t\u0065\u0064\u0020\u0069\u006e\u0070\u0075t\u003a\u0020\u0025\u0073", _cb)
	}
	_ff(t, _cg, got)
}
func _fgb(_aae string) string {
	_dab, _ := _bf.CreateTemp("", _aae)
	defer _dab.Close()
	return _dab.Name()
}
func _gfe(_cd, _ae *_b.Reader, _gbc bool) func(_ef *_gd.T) {
	return func(_fba *_gd.T) {
		_be := make([]*_b.File, len(_cd.File))
		copy(_be, _cd.File)
		_aff := make([]*_b.File, len(_ae.File))
		copy(_aff, _ae.File)
		if len(_be) != len(_aff) {
			_fba.Errorf("\u0065x\u0070\u0065\u0063\u0074e\u0064\u0020\u0025\u0064\u0020f\u0069l\u0065s\u002c\u0020\u0067\u006f\u0074\u0020\u0025d", len(_cd.File), len(_ae.File))
		}
		for _aaa, _ec := range _be {
			for _fg, _ea := range _aff {
				if _ea == nil {
					continue
				}
				if _ec.Name == _ea.Name {
					if _gbc {
						_fba.Run(_ec.Name, _fe(_ec, _ea))
					}
					_be[_aaa] = nil
					_aff[_fg] = nil
				}
			}
		}
		for _, _bcf := range _be {
			if _bcf != nil {
				_fba.Errorf("\u0064\u0069\u0064\u006e\u0027\u0074\u0020\u0066\u0069\u006ed\u0020\u0065\u0078\u0070\u0065\u0063\u0074e\u0064\u0020\u0066\u0069\u006c\u0065\u0020\u0027\u0025\u0073\u0027", _bcf.Name)
			}
		}
		for _, _dg := range _aff {
			if _dg != nil {
				_fba.Errorf("\u0066\u006f\u0075\u006e\u0064\u0020\u0075\u006e\u0065\u0078\u0070e\u0063\u0074\u0065\u0064\u0020\u0066\u0069\u006c\u0065\u0020'\u0025\u0073\u0027", _dg.Name)
			}
		}
	}
}
func CreatePNGDiff(src, dst string) (bool, string, float64, float64, error) {
	_eaf, _badc := ReadPNG(src)
	if _badc != nil {
		return false, "", 0, 0, _badc
	}
	_bfd, _badc := ReadPNG(dst)
	if _badc != nil {
		return false, "", 0, 0, _badc
	}
	_gee := _eaf.Bounds()
	_bce := _bfd.Bounds()
	if !_agc(_gee, _bce) {
		if _f.Abs(float64(_gee.Max.X)-float64(_bce.Max.X)) > 1 {
			_gfd.Printf("S\u006f\u0075\u0072\u0063\u0065\u0020b\u006f\u0075\u006e\u0064\u0073\u003a \u0025\u0076\u003b\u0020\u0044\u0065\u0073t\u0020\u0062\u006f\u0075\u006e\u0064\u0073\u003a\u0020\u0025v\u000a", _gee, _bce)
			return false, "", 0, 0, ErrImageSizeNotMatch
		}
	}
	_bfad := _ee.NewRGBA(_ee.Rect(0, 0, _gee.Max.X, _gee.Max.Y))
	var (
		_cec float64
		_dbe float64
	)
	for _bcfa := _gee.Min.Y; _bcfa < _gee.Max.Y; _bcfa++ {
		for _bee := _gee.Min.X; _bee < _gee.Max.X; _bee++ {
			_fed, _edd, _aade, _bfg := _eaf.At(_bee, _bcfa).RGBA()
			_aaea, _abb, _agb, _gffb := _bfd.At(_bee, _bcfa).RGBA()
			_bfad.Set(_bee, _bcfa, _c.RGBA{uint8(_aaea), uint8(_abb), uint8(_agb), 64})
			_bbb := _bfg == 0x00 && _fed == 0x00 && _edd == 0x00 && _aade == 0x00 && _aaea == 0xFFFF && _abb == 0xFFFF && _agb == 0xFFFF
			if !_bbb && !_gbgb(_eaf.At(_bee, _bcfa), _bfd.At(_bee, _bcfa)) {
				_bfad.Set(_bee, _bcfa, _c.RGBA{uint8(_fed), uint8(_edd), uint8(_aade), uint8(_bfg)})
				_dga := float64(_fed) + float64(_edd) + float64(_aade) + float64(_bfg) - float64(_aaea) + float64(_abb) + float64(_agb) + float64(_gffb)
				_dba := _f.Sqrt(_f.Pow(_dga/float64(_gee.Dx()*_gee.Dy()), 2))
				_dbe += _dba
				_cec++
			}
		}
	}
	_dfa := _cec / float64(_gee.Dx()*_gee.Dy()) * 100
	_afbe := _cf.Dir(src)
	_gaa := _a.TrimSuffix(_cf.Base(src), _cf.Ext(src))
	_cgf, _badc := _bf.Create(_afbe + "\u002f" + _gaa + "\u002dd\u0069\u0066\u0066\u002e\u0070\u006eg")
	if _badc != nil {
		return false, "", 0, 0, _badc
	}
	defer _cgf.Close()
	_gcgc := _a.Replace(_afbe, "\u0072\u0065\u006e\u0064\u0065\u0072", "\u0066\u006f\u006et\u0073", 1) + "\u002f\u0043\u0061l\u0069\u0062\u0072\u0069\u002e\u0074\u0074\u0066"
	_fdd := _fb.Sprintf("\u0044\u0069f\u0066\u0065\u0072e\u006e\u0063\u0065\u003a\u0020\u0025\u0066\u0025\u0025", _dfa)
	_badc = _eafa(_bfad, _gcgc, _fdd, 15, 22)
	if _badc != nil {
		return false, "", 0, 0, _badc
	}
	_fdd = _fb.Sprintf("T\u006ft\u0061\u006c\u0020\u0044\u0069\u0066\u0066\u0065r\u0065\u006e\u0063\u0065: \u0025\u0066", _dbe)
	_badc = _eafa(_bfad, _gcgc, _fdd, 15, 44)
	if _badc != nil {
		return false, "", 0, 0, _badc
	}
	if _gfdd := _bc.Encode(_cgf, _bfad); _gfdd != nil {
		return false, "", 0, 0, _gfdd
	}
	return true, _cgf.Name(), _dfa, _dbe, nil
}

type ReferenceMap struct {
	_gf.Mutex
	_egc map[string]ReferenceEntry
}

func CopyFile(src, dst string) error {
	_bfa, _bff := _bf.Open(src)
	if _bff != nil {
		return _bff
	}
	defer _bfa.Close()
	_gfcc, _bff := _bf.Create(dst)
	if _bff != nil {
		return _bff
	}
	defer _gfcc.Close()
	_, _bff = _gb.Copy(_gfcc, _bfa)
	return _bff
}
func CompareGoldenZipFilesOnly(t *_gd.T, expectedFn string, got []byte) {
	_cef := _cf.Join("\u0074\u0065\u0073\u0074\u0064\u0061\u0074\u0061", expectedFn)
	if *_cc {
		if _af := _bf.WriteFile(_cef, got, 0644); _af != nil {
			t.Fatal(_af)
		}
	}
	CompareZip(t, expectedFn, got, false)
}
func ReadPNG(file string) (_ee.Image, error) {
	_geg, _addd := _bf.Open(file)
	if _addd != nil {
		return nil, _addd
	}
	defer _geg.Close()
	return _bc.Decode(_geg)
}
func CombinePNGFiles(file1, file2 string) (bool, error) {
	_cag, _gad := ReadPNG(file1)
	if _gad != nil {
		return false, _gad
	}
	_ecb, _gad := ReadPNG(file2)
	if _gad != nil {
		return false, _gad
	}
	_gdab := _ee.Point{_cag.Bounds().Dx(), 0}
	_bae := _ee.Rectangle{_gdab, _gdab.Add(_ecb.Bounds().Size())}
	_ccf := _ee.Rectangle{_ee.Point{0, 0}, _bae.Max}
	_ada := _ee.NewRGBA(_ccf)
	_e.Draw(_ada, _cag.Bounds(), _cag, _ee.Point{0, 0}, _e.Src)
	_e.Draw(_ada, _bae, _ecb, _ee.Point{0, 0}, _e.Src)
	_aafc := _cf.Dir(file1)
	_dde := _a.TrimSuffix(_cf.Base(file1), _cf.Ext(file1))
	_ed, _gad := _bf.Create(_aafc + "\u002f" + _dde + "\u002d\u0063\u006f\u006d\u0062\u0069\u006e\u0065\u0064\u002e\u0070\u006e\u0067")
	if _gad != nil {
		return false, _gad
	}
	defer _ed.Close()
	if _ccff := _bc.Encode(_ed, _ada); _ccff != nil {
		return false, _ccff
	}
	return true, nil
}
func _eafa(_dbd *_ee.RGBA, _eag string, _gcc string, _adef, _fgg int) error {
	_eeg, _eea := _g.ReadFile(_eag)
	if _eea != nil {
		return _eea
	}
	_cfcd, _eea := _acb.Parse(_eeg)
	if _eea != nil {
		return _eea
	}
	_eaa, _eea := _acb.NewFace(_cfcd, &_acb.FaceOptions{Size: 18, DPI: 72, Hinting: _ge.HintingNone})
	if _eea != nil {
		return _eea
	}
	_dbg := &_ge.Drawer{Dst: _dbd, Src: _ee.NewUniform(_c.RGBA{200, 100, 0, 255}), Face: _eaa, Dot: _dbf.P(_adef, _fgg)}
	_dbg.DrawString(_gcc)
	return nil
}
func ComparePNGFiles(file1, file2 string) (bool, error) {
	_bbg, _fga := HashFile(file1)
	if _fga != nil {
		return false, _fga
	}
	_cca, _fga := HashFile(file2)
	if _fga != nil {
		return false, _fga
	}
	if _bbg == _cca {
		return true, nil
	}
	_bbd, _fga := ReadPNG(file1)
	if _fga != nil {
		return false, _fga
	}
	_aec, _fga := ReadPNG(file2)
	if _fga != nil {
		return false, _fga
	}
	if _bbd.Bounds() != _aec.Bounds() {
		return false, nil
	}
	return CompareImages(_bbd, _aec)
}
func _gbgb(_bcea, _egcc _c.Color) bool {
	_fgf, _fbdb, _dacf, _dea := _bcea.RGBA()
	_cfd, _feg, _aebb, _abg := _egcc.RGBA()
	return _fgf == _cfd && _fbdb == _feg && _dacf == _aebb && _dea == _abg
}
func RenderPDFToPNGs(pdfPath string, dpi int, outpathTpl string) error {
	if dpi <= 0 {
		dpi = 100
	}
	if _, _gde := _bg.LookPath("\u0067\u0073"); _gde != nil {
		return ErrRenderNotSupported
	}
	return _bg.Command("\u0067\u0073", "\u002d\u0073\u0044\u0045\u0056\u0049\u0043\u0045\u003d\u0070\u006e\u0067a\u006c\u0070\u0068\u0061", "\u002d\u006f", outpathTpl, _fb.Sprintf("\u002d\u0072\u0025\u0064", dpi), pdfPath).Run()
}
func (_gff *ReferenceFile) Update(currentMap *ReferenceMap) error {
	if _gff._ga == "" {
		return nil
	}
	_de := _gff.updateMap(currentMap)
	if _de == 0 {
		return nil
	}
	_fa, _bb := _bf.OpenFile(_gff._ga, _bf.O_CREATE|_bf.O_TRUNC|_bf.O_WRONLY, 0664)
	if _bb != nil {
		return _bb
	}
	defer _fa.Close()
	_gff.Timestamp = _dd.Now().UTC()
	_eb := _db.NewEncoder(_fa)
	_eb.SetIndent("", "\u0009")
	return _eb.Encode(_gff)
}
func RunRenderTest(t *_gd.T, pdfPath, outputDir, baselineRenderPath string, saveBaseline bool, currentHashMap *ReferenceMap, refFile *ReferenceFile) {
	RunRenderOfficeTest(t, pdfPath, outputDir, baselineRenderPath, saveBaseline, currentHashMap, refFile, "\u002em\u0073\u0077\u006f\u0072\u0064")
}
func (_efb *ReferenceMap) Copy() *ReferenceMap {
	_df := ReferenceMap{_egc: make(map[string]ReferenceEntry, len(_efb._egc))}
	for _gcg, _bgb := range _efb._egc {
		_df._egc[_gcg] = _bgb
	}
	return &_df
}

type ValidationResult struct {
	File   string `json:"file"`
	Result bool   `json:"result"`
	Note   string `json:"note"`
}

var _cc = _ac.Bool("t\u0065\u0073\u0074\u002e\u0075\u0070\u0064\u0061\u0074\u0065", false, "\u0075p\u0064a\u0074\u0065\u0020\u0067\u006fl\u0064\u0065n\u0020\u0066\u0069\u006c\u0065")

func CompareGoldenZip(t *_gd.T, expectedFn string, got []byte) {
	_ba := _cf.Join("\u0074\u0065\u0073\u0074\u0064\u0061\u0074\u0061", expectedFn)
	if *_cc {
		if _aca := _bf.WriteFile(_ba, got, 0644); _aca != nil {
			t.Fatal(_aca)
		}
	}
	CompareZip(t, expectedFn, got, true)
}
func ValidateDocument(file string) (bool, error) {
	var (
		_gdfc string = _bf.Getenv("\u0050\u0052\u004fJ\u0045\u0043\u0054\u005f\u0052\u004f\u004f\u0054")
		_dda  string = _bf.Getenv("\u0048\u004f\u004d\u0045") + "\u002f\u0064\u006f\u0074\u006e\u0065\u0074\u002f\u0064o\u0074\u006e\u0065\u0074"
		_bfgg string = _gdfc + "\u002f\u002e\u0063\u0069\u002f\u006f\u0070\u0065\u006e\u0078\u006dl\u002d\u0076\u0061\u006c\u0069\u0064\u0061\u0074o\u0072/\u0062\u0069\u006e\u002f\u0052\u0065\u006c\u0065\u0061\u0073\u0065\u002f\u006e\u0065\u0074\u0038\u002e\u0030/\u0050\u0072\u006f\u0067\u0072\u0061\u006d\u002e\u0064\u006c\u006c"
		_ffg  string = _gdfc + "\u002f\u0069\u006et\u0065\u0072\u006e\u0061\u006c\u002f\u0074\u0065\u0073\u0074\u0075\u0074\u0069\u006c\u0073\u002f\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u005f\u0072\u0065s\u0075\u006c\u0074\u002e\u006a\u0073\u006f\u006e"
		_adea _eg.Buffer
		_baa  string
		_bfb  bool = true
	)
	if _, _dcd := _bf.Stat(_dda); _dcd != nil {
		_bcc.Log.Debug("\u0064\u006f\u0074\u006e\u0065\u0074 \u0065\u0078\u0065\u0063\u0075\u0074\u0061\u0062\u006c\u0065\u0020\u006e\u006ft\u0020\u0066\u006f\u0075\u006e\u0064\u0020i\u006e\u0020\u0025\u0073", _dda)
		return true, nil
	}
	if _, _gdc := _bf.Stat(_bfgg); _gdc != nil {
		_bcc.Log.Debug("\u006f\u0070\u0065\u006e\u0078\u006dl\u002d\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u006f\u0072\u0020\u006e\u006ft\u0020\u0066\u006f\u0075\u006e\u0064\u0020i\u006e\u0020\u0025\u0073", _bfgg)
		return true, nil
	}
	var (
		_eggb map[string]map[string]*ValidationResult
		_cacd *ValidationResult
	)
	_eaca, _dgb := _bf.ReadFile(_ffg)
	if _dgb != nil {
		return false, _dgb
	}
	if _daf := _db.Unmarshal(_eaca, &_eggb); _daf != nil {
		return false, _daf
	}
	if _eggb == nil {
		_eggb = make(map[string]map[string]*ValidationResult)
	}
	_adf := _cf.Ext(file)
	_adf = _adf[1:]
	if _adf != "\u0064\u006f\u0063\u0078" && _adf != "\u0078\u006c\u0073\u0078" && _adf != "\u0070\u0070\u0074\u0078" {
		return false, _fb.Errorf("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0066\u0069\u006c\u0065\u0020\u0065x\u0074\u0065\u006e\u0073\u0069\u006f\u006e\u003a\u0020\u0025\u0073", _adf)
	}
	_edbg := _cf.Base(file)
	if _fbef, _fdeb := _eggb[_adf]; _fdeb {
		if _bba, _fcd := _fbef[_edbg]; _fcd {
			_cacd = _bba
		}
	}
	_bbga := _bg.Command(_dda, _bfgg, "\u002d\u002d"+_adf, file)
	_bbga.Stderr = &_adea
	_cbg, _dgb := _bbga.Output()
	if _dgb != nil {
		_baa = _adea.String()
	}
	_edc := string(_cbg)
	_edc = _a.TrimSpace(_edc[_a.Index(_edc, "\u000a")+1:])
	if _a.Contains(_edc, "\u0045x\u0063\u0065\u0070\u0074\u0069\u006fn") || _a.Contains(_edc, "\u0069\u0073\u0020n\u006f\u0074\u0020\u0076\u0061\u006c\u0069\u0064") {
		_bfb = false
		if _a.Contains(_edc, "\u006da\u0069\u006e\u003a\u0073\u007a") || _a.Contains(_edc, "m\u0061\u0069\u006e\u003a\u0066\u0061\u006d\u0069\u006c\u0079") || _a.Contains(_edc, "\u0063h\u0061\u0072\u0074\u003a\u0065\u0078t") {
			_baa = "\u0046\u0061\u0069\u006c\u0065\u0064\u0020\u0076\u0061\u006ci\u0064\u0061\u0074\u0069\u006f\u006e\u0020i\u0073\u0020\u0069\u0067\u006e\u006f\u0072\u0065\u0064\u003a\u0020" + _edc
			_bfb = true
		}
	}
	if _baa == "" {
		_baa = _edc
	}
	if _cacd == nil {
		_cacd = &ValidationResult{File: _edbg, Result: _bfb, Note: _baa}
	}
	_cacd.Result = _bfb
	_cacd.Note = _baa
	if _eggb[_adf] == nil {
		_eggb[_adf] = make(map[string]*ValidationResult)
	}
	if _bdca, _gegg := _eggb[_adf][_edbg]; _gegg {
		if _bdca.Result && !_bfb {
			return false, _fb.Errorf("V\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e \u0072\u0065\u0073\u0075\u006c\u0074\u0020ch\u0061\u006e\u0067\u0065d\u0020\u0066\u006f\u0072\u0020\u0025\u0073\u003a\u0020%v\u0020\u002d>\u0020\u0025\u0076\u0020\u0028\u0025\u0073\u0029", file, _bdca.Result, _bfb, _baa)
		}
	}
	_eggb[_adf][_edbg] = _cacd
	_eaca, _dgb = _db.MarshalIndent(_eggb, "", "\u0020\u0020")
	if _dgb != nil {
		return false, _dgb
	}
	if _bdf := _bf.WriteFile(_ffg, _eaca, 0644); _bdf != nil {
		return false, _bdf
	}
	return true, nil
}
func (_ece *ReferenceFile) updateMap(_cfb *ReferenceMap) int {
	var _ceb int
	if _ece.Map._egc == nil {
		_ece.Map._egc = map[string]ReferenceEntry{}
	}
	for _ade, _fad := range _cfb._egc {
		_cga, _aaf := _ece.Map._egc[_ade]
		if !_aaf {
			_ece.Map._egc[_ade] = _fad
			_ceb++
			continue
		}
		if string(_cga.Value) != string(_fad.Value) {
			_ece.Map._egc[_ade] = _fad
			_ceb++
		}
	}
	for _cge := range _ece.Map._egc {
		if _, _ebd := _cfb._egc[_cge]; !_ebd {
			delete(_ece.Map._egc, _cge)
			_ceb++
		}
	}
	return _ceb
}

type ReferenceFile struct {
	Timestamp _dd.Time      `json:"timestamp"`
	Map       *ReferenceMap `json:"map,omitempty"`
	_ga       string
}

func RunRenderOfficeTest(t *_gd.T, pdfPath, outputDir, baselineRenderPath string, saveBaseline bool, currentHashMap *ReferenceMap, refFile *ReferenceFile, postfix string) {
	_ffa := _a.TrimSuffix(_cf.Base(pdfPath), _cf.Ext(pdfPath))
	t.Run("\u0072\u0065\u006e\u0064\u0065\u0072", func(_cgc *_gd.T) {
		_dec := _cf.Join(outputDir, _ffa)
		_bccga := _dec + "\u002d%\u0064\u002e\u0070\u006e\u0067"
		if _fbgb := RenderPDFToPNGs(pdfPath, 0, _bccga); _fbgb != nil {
			_cgc.Skip(_fbgb)
		}
		_ccd := _ffa + postfix
		_cbfa := _cf.Join(outputDir, _ccd)
		_ffe := _cbfa + "\u002d%\u0064\u002e\u0070\u006e\u0067"
		_gdb := false
		if saveBaseline {
			_dad := _cf.Dir(pdfPath)
			_acc := _cf.Join(_dad, _ccd+"\u002e\u0070\u0064\u0066")
			if _, _egg := _bf.Stat(_acc); _egg == nil {
				_cgc.Logf("\u0052e\u006e\u0064\u0065\u0072\u0020\u004d\u0053\u0020\u004f\u0066\u0066i\u0063\u0065\u0020\u0050\u0044\u0046\u003a\u0020\u0025\u0076", _acc)
				if _aadea := RenderPDFToPNGs(_acc, 0, _ffe); _aadea != nil {
					_cgc.Skip(_aadea)
				}
				_gdb = true
			}
		}
		for _bfdf := 1; true; _bfdf++ {
			_egb := _fb.Sprintf("\u0025s\u002d\u0025\u0064\u002e\u0070\u006eg", _dec, _bfdf)
			_gfaa := _cf.Join(baselineRenderPath, _fb.Sprintf("\u0025\u0073\u002d\u0025\u0064\u005f\u0065\u0078\u0070\u002e\u0070\u006e\u0067", _ffa, _bfdf))
			if _, _dgeee := _bf.Stat(_egb); _dgeee != nil {
				break
			}
			_cgc.Logf("\u0025\u0073", _gfaa)
			if saveBaseline {
				_cgc.Logf("\u0043\u006fp\u0079\u0069\u006eg\u0020\u0025\u0073\u0020\u002d\u003e\u0020\u0025\u0073", _egb, _gfaa)
				_gef := CopyFile(_egb, _gfaa)
				if _gef != nil {
					_cgc.Fatalf("\u0045\u0052\u0052OR\u0020\u0063\u006f\u0070\u0079\u0069\u006e\u0067\u0020\u0074\u006f\u0020\u0025\u0073\u003a\u0020\u0025\u0076", _gfaa, _gef)
				}
				if _gdb {
					_cfdb := _fb.Sprintf("\u0025s\u002d\u0025\u0064\u002e\u0070\u006eg", _cbfa, _bfdf)
					_egeb := _cf.Join(baselineRenderPath, _fb.Sprintf("\u0025\u0073\u002d\u0025\u0064\u005f\u0065\u0078\u0070\u002e\u0070\u006e\u0067", _ccd, _bfdf))
					_cgc.Logf("\u0043\u006f\u0070\u0079\u0069\u006e\u0067\u0020\u004d\u0053\u0020\u0057\u006f\u0072\u0064 \u0072e\u0073\u0075\u006c\u0074\u0073\u0020\u0025\u0073\u0020\u002d\u003e\u0020\u0025\u0073", _cfdb, _egeb)
					_caa := CopyFile(_cfdb, _egeb)
					if _caa != nil {
						_cgc.Logf("\u0045\u0052\u0052\u004f\u0052\u0020\u0063\u006f\u0070\u0079\u0069\u006eg\u0020\u0074\u006f \u0025\u0073\u003a\u0020\u0025\u0076\u002c\u0020\u0068\u0061\u0076i\u006e\u0067\u0020d\u0069\u0066\u0066\u0065r\u0065\u006e\u0074\u0020\u0070\u0061\u0067\u0065\u0020\u0073\u0069\u007a\u0065\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0073\u002c\u0020\u0072\u0065\u0070\u006c\u0061\u0063\u0069\u006eg\u0020\u0069\u0074\u0020\u0077\u0069\u0074\u0068\u0020\u0062\u006ca\u006e\u006b\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0069\u006e\u0073\u0074\u0065\u0061\u0064", _egeb, _caa)
						if _baea := _bcd(_gfaa, _egeb); _baea != nil {
							_cgc.Fatalf("\u0045\u0052\u0052\u004f\u0052\u0020c\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0065\u006d\u0070\u0074\u0079 \u0069\u006d\u0061\u0067\u0065\u0020\u0025s\u003a\u0020\u0025\u0076", _egeb, _baea)
						}
					}
					_cgc.Logf("\u0043\u006fm\u0062\u0069\u006e\u0069\u006eg\u0020\u0055\u006e\u0069\u004ff\u0066\u0069\u0063\u0065\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0073\u0020\u0077\u0069\u0074\u0068\u0020\u004d\u0053\u0020\u004f\u0066\u0066\u0069\u0063\u0065\u0020\u0025\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0073", _gfaa, _egeb)
					_bccc, _caa := CombinePNGFiles(_gfaa, _egeb)
					if _bf.IsNotExist(_caa) {
						_cgc.Fatal("\u0069m\u0061g\u0065\u0020\u0066\u0069\u006ce\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
					} else if !_bccc {
						_cgc.Fatal("\u0055n\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0063\u006f\u006db\u0069\u006e\u0065\u0020\u0069\u006d\u0061\u0067\u0065\u0073")
					}
					_cgc.Logf("\u0043\u0072\u0065\u0061\u0074\u0069\u006e\u0067\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0064\u0069\u0066f \u0055n\u0069\u004f\u0066\u0066\u0069\u0063\u0065\u0020\u0072\u0065\u0073\u0075l\u0074\u0073\u0020\u0077\u0069\u0074\u0068\u0020\u004d\u0053\u0020\u004f\u0066\u0066\u0069\u0063\u0065 \u0025\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0073", _gfaa, _egeb)
					_bccc, _ddg, _fab, _aabf, _caa := CreatePNGDiff(_gfaa, _egeb)
					if _caa != nil && _ag.Is(_caa, ErrImageSizeNotMatch) {
						_cgc.Fatalf("\u0045\u0072\u0072\u006fr\u0020\u006f\u006e\u0020\u0063\u0072\u0065\u0061\u0074\u0065 \u0050N\u0047\u0020\u0044\u0069\u0066\u0066\u003a \u0025\u0076", _caa)
					}
					if _bccc {
						_cgc.Logf("\u0049\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073\u000a", _ddg)
						_cgc.Logf("D\u0069\u0066\u0066\u0020Pe\u0072c\u0065\u006e\u0074\u003a\u0020%\u0032\u002e\u0066\u0025\u0025\u000a", _fab)
						_cgc.Logf("\u0044i\u0066f\u0020\u0054\u006f\u0074\u0061\u006c\u003a\u0020\u0025\u0066\u000a", _aabf)
						_cee := _cf.Base(_ddg)
						_fdag, _dadc := currentHashMap.Read(_cee)
						if _dadc && (_fdag.DiffPercent < _fab || _fdag.DiffTotal < _aabf) {
							_cgc.Logf("\u004e\u0065\u0077\u0020\u0072\u0065\u0073\u0075\u006c\u0074\u0073\u0020\u0068\u0061\u0076\u0069\u006e\u0067 h\u0069g\u0068\u0065\u0072\u0020\u0064\u0069\u0066\u0066\u0065\u0072\u0065\u006ec\u0065\u0020\u0070\u0065\u0072\u0063\u0065\u006e\u0074\u003a\u0020\u0025\u0066\u0020\u0061\u006e\u0064 \u0074\u006f\u0074\u0061\u006c\u0020\u0025\u0066\u000a", _fab, _aabf)
						}
						_bfae, _abe := HashFile(_ddg)
						_gfc.NoError(_cgc, _abe)
						_eaga := _gfde(_cgc, _ddg)
						if !_dadc || _fdag.Value != _bfae || _fdag.ResultSize != _eaga || _fdag.DiffPercent != _fab || _fdag.DiffTotal != _aabf {
							_fdc := ReferenceEntry{Timestamp: _dd.Now().UTC().Unix(), Value: _bfae, ResultSize: _eaga, DiffPercent: _fab, DiffTotal: _aabf}
							currentHashMap.Write(_cee, _fdc)
							if _abe = refFile.Update(currentHashMap); _abe != nil {
								_cgc.Logf("\u0055\u0070\u0064\u0061\u0074\u0065\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u0020f\u0069\u006c\u0065\u0020\u0066\u0061\u0069\u006c\u0065\u0064\u003a\u0020\u0025\u0076", _abe)
							}
						}
					}
				}
				continue
			}
			_cgc.Run(_fb.Sprintf("\u0070\u0061\u0067\u0065\u0025\u0064", _bfdf), func(_ddf *_gd.T) {
				_ddf.Logf("\u0043o\u006dp\u0061\u0072\u0069\u006e\u0067 \u0025\u0073 \u0076\u0073\u0020\u0025\u0073", _egb, _gfaa)
				_aeaa, _beb := ComparePNGFiles(_egb, _gfaa)
				if _bf.IsNotExist(_beb) {
					_ddf.Fatal("\u0069m\u0061g\u0065\u0020\u0066\u0069\u006ce\u0020\u006di\u0073\u0073\u0069\u006e\u0067")
				} else if !_aeaa {
					_ddf.Fatal("\u0077\u0072\u006f\u006eg \u0070\u0061\u0067\u0065\u0020\u0072\u0065\u006e\u0064\u0065\u0072\u0065\u0064")
				}
			})
		}
	})
}
