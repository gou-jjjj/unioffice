//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package formatutils

import (
	_f "fmt"
	_a "strconv"
	_b "strings"
	_aa "unioffice/schema/soo/wml"
)

func _ad(_fee string) (_bc []string) {
	for _gf := 0; _gf < len(_fee)-2; _gf++ {
		if string(_fee[_gf]) == "\u0025" {
			if !_b.Contains(string(_fee[_gf+2:]), "\u0025") {
				if _gf == 0 {
					_bc = append(_bc, _f.Sprintf("\u0025\u0073\u0025\u0073\u0025\u0073", string(_fee[_gf]), string(_fee[_gf+1]), string(_fee[_gf+2:])))
				} else {
					_bc = append(_bc, _f.Sprintf("\u0025\u0073\u0025\u0073\u0025\u0073\u0025\u0073", string(_fee[_gf-1]), string(_fee[_gf]), string(_fee[_gf+1]), string(_fee[_gf+2:])))
				}
			} else {
				_bc = append(_bc, _f.Sprintf("\u0025\u0073\u0025\u0073\u0025\u0073", string(_fee[_gf]), string(_fee[_gf+1]), string(_fee[_gf+2])))
			}
		}
	}
	return
}
func _eg(_ga int64, _eb *_aa.CT_NumFmt) (_de string) {
	if _eb == nil {
		return
	}
	_da := _eb.ValAttr
	switch _da {
	case _aa.ST_NumberFormatNone:
		_de = ""
	case _aa.ST_NumberFormatDecimal:
		_de = _a.Itoa(int(_ga))
	case _aa.ST_NumberFormatDecimalZero:
		_de = _a.Itoa(int(_ga))
		if _ga < 10 {
			_de = "\u0030" + _de
		}
	case _aa.ST_NumberFormatUpperRoman:
		var (
			_ff = _ga % 10
			_dc = (_ga % 100) / 10
			_dd = (_ga % 1000) / 100
			_fc = _ga / 1000
		)
		_de = _edd[_fc] + _cd[_dd] + _dg[_dc] + _ed[_ff]
	case _aa.ST_NumberFormatLowerRoman:
		var (
			_bg  = _ga % 10
			_acc = (_ga % 100) / 10
			_cfe = (_ga % 1000) / 100
			_ce  = _ga / 1000
		)
		_de = _edd[_ce] + _cd[_cfe] + _dg[_acc] + _ed[_bg]
		_de = _b.ToLower(_de)
	case _aa.ST_NumberFormatUpperLetter:
		_agc := _ga % 780
		if _agc == 0 {
			_agc = 780
		}
		_fcc := (_agc - 1) / 26
		_dge := (_agc - 1) % 26
		_ab := _ag[_fcc+_dge]
		_de = string(_ab)
	case _aa.ST_NumberFormatLowerLetter:
		_aca := _ga % 780
		if _aca == 0 {
			_aca = 780
		}
		_ae := (_aca - 1) / 26
		_fg := (_aca - 1) % 26
		_cgc := _ag[_ae+_fg]
		_de = _b.ToLower(string(_cgc))
	default:
		_de = ""
	}
	return
}
func StringToNumbers(str string) (int, bool) {
	_def := 0
	_cfg := false
	for _, _gg := range []byte(str) {
		_gg -= '0'
		if _gg > 9 {
			continue
		}
		_def = _def*10 + int(_gg)
		_cfg = true
	}
	return _def, _cfg
}
func Initials(text string) string {
	if text == "" {
		return ""
	}
	_egc := _b.Split(text, "\u0020")
	_ca := _b.Builder{}
	for _, _dab := range _egc {
		_ca.WriteByte(_dab[0])
	}
	return _ca.String()
}

var (
	_ed  = []string{"", "\u0049", "\u0049\u0049", "\u0049\u0049\u0049", "\u0049\u0056", "\u0056", "\u0056\u0049", "\u0056\u0049\u0049", "\u0056\u0049\u0049\u0049", "\u0049\u0058"}
	_dg  = []string{"", "\u0058", "\u0058\u0058", "\u0058\u0058\u0058", "\u0058\u004c", "\u004c", "\u004c\u0058", "\u004c\u0058\u0058", "\u004c\u0058\u0058\u0058", "\u0058\u0043"}
	_cd  = []string{"", "\u0043", "\u0043\u0043", "\u0043\u0043\u0043", "\u0043\u0044", "\u0044", "\u0044\u0043", "\u0044\u0043\u0043", "\u0044\u0043\u0043\u0043", "\u0043\u004d", "\u004d"}
	_edd = []string{"", "\u004d", "\u004d\u004d", "\u004d\u004d\u004d", "\u004d\u004d\u004d\u004d", "\u004d\u004d\u004dM\u004d", "\u004d\u004d\u004d\u004d\u004d\u004d", "\u004dM\u004d\u004d\u004d\u004d\u004d", "\u004d\u004d\u004d\u004d\u004d\u004d\u004d\u004d", "\u004dM\u004d\u004d\u004d\u004d\u004d\u004dM", "\u004d\u004d\u004d\u004d\u004d\u004d\u004d\u004d\u004d\u004d"}
	_af  = []string{"\u006f\u006e\u0065", "\u0074\u0077\u006f", "\u0074\u0068\u0072e\u0065", "\u0066\u006f\u0075\u0072", "\u0066\u0069\u0076\u0065", "\u0073\u0069\u0078", "\u0073\u0065\u0076e\u006e", "\u0065\u0069\u0067h\u0074", "\u006e\u0069\u006e\u0065", "\u0074\u0065\u006e", "\u0065\u006c\u0065\u0076\u0065\u006e", "\u0074\u0077\u0065\u006c\u0076\u0065", "\u0074\u0068\u0069\u0072\u0074\u0065\u0065\u006e", "\u0066\u006f\u0075\u0072\u0074\u0065\u0065\u006e", "\u0066i\u0066\u0074\u0065\u0065\u006e", "\u0073i\u0078\u0074\u0065\u0065\u006e", "\u0073e\u0076\u0065\u006e\u0074\u0065\u0065n", "\u0065\u0069\u0067\u0068\u0074\u0065\u0065\u006e", "\u006e\u0069\u006e\u0065\u0074\u0065\u0065\u006e"}
	_cg  = []string{"\u0074\u0065\u006e", "\u0074\u0077\u0065\u006e\u0074\u0079", "\u0074\u0068\u0069\u0072\u0074\u0079", "\u0066\u006f\u0072t\u0079", "\u0066\u0069\u0066t\u0079", "\u0073\u0069\u0078t\u0079", "\u0073e\u0076\u0065\u006e\u0074\u0079", "\u0065\u0069\u0067\u0068\u0074\u0079", "\u006e\u0069\u006e\u0065\u0074\u0079"}
	_cf  = []string{"\u0066\u0069\u0072s\u0074", "\u0073\u0065\u0063\u006f\u006e\u0064", "\u0074\u0068\u0069r\u0064", "\u0066\u006f\u0075\u0072\u0074\u0068", "\u0066\u0069\u0066t\u0068", "\u0073\u0069\u0078t\u0068", "\u0073e\u0076\u0065\u006e\u0074\u0068", "\u0065\u0069\u0067\u0068\u0074\u0068", "\u006e\u0069\u006et\u0068", "\u0074\u0065\u006et\u0068", "\u0065\u006c\u0065\u0076\u0065\u006e\u0074\u0068", "\u0074w\u0065\u006c\u0066\u0074\u0068", "\u0074\u0068\u0069\u0072\u0074\u0065\u0065\u006e\u0074\u0068", "\u0066\u006f\u0075\u0072\u0074\u0065\u0065\u006e\u0074\u0068", "\u0066i\u0066\u0074\u0065\u0065\u006e\u0074h", "\u0073i\u0078\u0074\u0065\u0065\u006e\u0074h", "s\u0065\u0076\u0065\u006e\u0074\u0065\u0065\u006e\u0074\u0068", "\u0065\u0069\u0067\u0068\u0074\u0065\u0065\u006e\u0074\u0068", "\u006e\u0069\u006e\u0065\u0074\u0065\u0065\u006e\u0074\u0068"}
	_fa  = []string{"\u0074\u0065\u006et\u0068", "\u0074w\u0065\u006e\u0074\u0069\u0065\u0074h", "\u0074h\u0069\u0072\u0074\u0069\u0065\u0074h", "\u0066\u006f\u0072\u0074\u0069\u0065\u0074\u0068", "\u0066\u0069\u0066\u0074\u0069\u0065\u0074\u0068", "\u0073\u0069\u0078\u0074\u0069\u0065\u0074\u0068", "\u0073\u0065\u0076\u0065\u006e\u0074\u0069\u0065\u0074\u0068", "\u0065i\u0067\u0068\u0074\u0069\u0065\u0074h", "\u006ei\u006e\u0065\u0074\u0069\u0065\u0074h"}
	_ag  = "\u0041\u0042\u0043\u0044\u0045\u0046\u0047\u0048\u0049\u004a\u004bL\u004d\u004e\u004f\u0050\u0051\u0052\u0053\u0054\u0055\u0056W\u0058\u0059\u005a"
)

func FormatNumberingText(currentNumber int64, ilvl int64, lvlText string, numFmt *_aa.CT_NumFmt, levelNumbers map[int64]int64) string {
	_d := _ad(lvlText)
	_fe := _eg(currentNumber, numFmt)
	_ac := int64(0)
	for _aab, _g := range _d {
		_c := _f.Sprintf("\u0025\u0025\u0025\u0064", _aab+1)
		if len(_d) == 1 {
			_c = _f.Sprintf("\u0025\u0025\u0025\u0064", ilvl+1)
			_d[_aab] = _b.Replace(_g, _c, _fe, 1)
			break
		}
		if ilvl > 0 && ilvl > _ac && _aab < (len(_d)-1) {
			_df := _eg(levelNumbers[_ac], numFmt)
			_d[_aab] = _b.Replace(_g, _c, _df, 1)
			_ac++
		} else {
			_d[_aab] = _b.Replace(_g, _c, _fe, 1)
		}
	}
	return _b.Join(_d, "")
}
