//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package mscfb

import (
	_d "bytes"
	_aa "encoding/binary"
	_a "fmt"
	_fde "io"
	_cf "os"
	_b "strconv"
	_c "time"
	_fd "unicode"
	_fe "unicode/utf16"

	_af "github.com/gou-jjjj/unioffice/internal/mscfb/rw"
	_aaa "github.com/richardlehane/msoleps/types"
)

func (_bfg *File) stream(_eef int) ([][2]int64, error) {
	var _fac bool
	var _ada int
	var _bef int64
	if _bfg.Size < _fce {
		_fac = true
		_ada = _eef/int(_eba) + 2
		_bef = int64(_eba)
	} else {
		_ada = _eef/int(_bfg._cefd._cdbd) + 2
		_bef = int64(_bfg._cefd._cdbd)
	}
	_ddc := make([][2]int64, 0, _ada)
	var _agbg, _bfgb int
	if _bfg._ge > 0 {
		_dfd, _bcc := _bfg._cefd.getOffset(_bfg._agd, _fac)
		if _bcc != nil {
			return nil, _bcc
		}
		if _bef-_bfg._ge >= int64(_eef) {
			_ddc = append(_ddc, [2]int64{_dfd + _bfg._ge, int64(_eef)})
		} else {
			_ddc = append(_ddc, [2]int64{_dfd + _bfg._ge, _bef - _bfg._ge})
		}
		if _bef-_bfg._ge <= int64(_eef) {
			_bfg._agd, _bcc = _bfg._cefd.findNext(_bfg._agd, _fac)
			if _bcc != nil {
				return nil, _bcc
			}
			_bfgb += int(_bef - _bfg._ge)
			_bfg._ge = 0
		} else {
			_bfg._ge += int64(_eef)
		}
		if _ddc[0][1] == int64(_eef) {
			return _ddc, nil
		}
		if _bfg._agd == _cdg {
			return nil, Error{ErrRead, "\u0075\u006ee\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0065\u0061\u0072\u006c\u0079\u0020\u0065\u006e\u0064\u0020\u006f\u0066\u0020\u0063ha\u0069\u006e", int64(_bfg._agd)}
		}
		_agbg++
	}
	for {
		if _agbg >= cap(_ddc) {
			return nil, Error{ErrRead, "\u0069\u006e\u0064\u0065x\u0020\u006f\u0076\u0065\u0072\u0072\u0075\u006e\u0073\u0020s\u0065c\u0074\u006f\u0072\u0020\u006c\u0065\u006eg\u0074\u0068", int64(_agbg)}
		}
		_adag, _cbcb := _bfg._cefd.getOffset(_bfg._agd, _fac)
		if _cbcb != nil {
			return nil, _cbcb
		}
		if _eef-_bfgb < int(_bef) {
			_ddc = append(_ddc, [2]int64{_adag, int64(_eef - _bfgb)})
			_bfg._ge = int64(_eef - _bfgb)
			return _daaa(_ddc), nil
		} else {
			_ddc = append(_ddc, [2]int64{_adag, _bef})
			_bfgb += int(_bef)
			_bfg._agd, _cbcb = _bfg._cefd.findNext(_bfg._agd, _fac)
			if _cbcb != nil {
				return nil, _cbcb
			}
			if _bfgb == _eef {
				return _daaa(_ddc), nil
			}
		}
		_agbg++
	}
}

type Error struct {
	_gggf int
	_cfe  string
	_acfd int64
}

type header struct {
	*headerFields
	_deg []uint32
	_cdd []uint32
	_gcb []uint32
}

func (_cdac *Reader) Read(b []byte) (_bede int, _bgg error) {
	if _cdac._afg >= len(_cdac.File) {
		return 0, _fde.EOF
	}
	return _cdac.File[_cdac._afg].Read(b)
}

func (_acc *File) ReadAt(p []byte, off int64) (_bdd int, _eae error) {
	_abgb, _cgga, _agb := _acc._dd, _acc._ge, _acc._agd
	_, _eae = _acc.Seek(off, 0)
	if _eae == nil {
		_bdd, _eae = _acc.Read(p)
	}
	_acc._dd, _acc._ge, _acc._agd = _abgb, _cgga, _agb
	return _bdd, _eae
}

func _aea(_abf []byte) *headerFields {
	_ecc := &headerFields{}
	_ecc._bcb = _aa.LittleEndian.Uint64(_abf[:8])
	_ecc._dbdd = _aa.LittleEndian.Uint16(_abf[24:26])
	_ecc._acea = _aa.LittleEndian.Uint16(_abf[26:28])
	_ecc._fga = _aa.LittleEndian.Uint16(_abf[30:32])
	_ecc._ggcf = _aa.LittleEndian.Uint32(_abf[40:44])
	_ecc._ebd = _aa.LittleEndian.Uint32(_abf[44:48])
	_ecc._dfc = _aa.LittleEndian.Uint32(_abf[48:52])
	_ecc._bea = _aa.LittleEndian.Uint32(_abf[60:64])
	_ecc._cad = _aa.LittleEndian.Uint32(_abf[64:68])
	_ecc._cedc = _aa.LittleEndian.Uint32(_abf[68:72])
	_ecc._aegf = _aa.LittleEndian.Uint32(_abf[72:76])
	var _eeaa int
	for _fab := 76; _fab < 512; _fab = _fab + 4 {
		_ecc._eecb[_eeaa] = _aa.LittleEndian.Uint32(_abf[_fab : _fab+4])
		_eeaa++
	}
	return _ecc
}

func (_dfab *Reader) Debug() map[string][]uint32 {
	_geebe := map[string][]uint32{"s\u0065\u0063\u0074\u006f\u0072\u0020\u0073\u0069\u007a\u0065": []uint32{_dfab._cdbd}, "\u006d\u0069\u006e\u0069\u0020\u0066\u0061\u0074\u0020\u006c\u006f\u0063\u0073": _dfab._cgf._cdd, "\u006d\u0069n\u0069\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u006c\u006f\u0063\u0073": _dfab._cgf._gcb, "\u0064\u0069r\u0065\u0063\u0074o\u0072\u0079\u0020\u0073\u0065\u0063\u0074\u006f\u0072": []uint32{_dfab._cgf._dfc}, "\u006d\u0069\u006e\u0069 s\u0074\u0072\u0065\u0061\u006d\u0020\u0073\u0074\u0061\u0072\u0074\u002f\u0073\u0069z\u0065": []uint32{_dfab.File[0]._ce, _aa.LittleEndian.Uint32(_dfab.File[0]._fc[:])}}
	for _bdg, _fead := _dfab.Next(); _fead == nil; _bdg, _fead = _dfab.Next() {
		_geebe[_bdg.Name+" \u0073\u0074\u0061\u0072\u0074\u002f\u0073\u0069\u007a\u0065"] = []uint32{_bdg._ce, _aa.LittleEndian.Uint32(_bdg._fc[:])}
	}
	return _geebe
}

func (_cbg *Reader) exportDifats(_def *_af.Writer) error {
	if _cbg._cgf._aegf == 0 {
		return nil
	}
	return nil
}

func (_cff *File) ID() string { return _cff._ef.String() }

func (_aae fileInfo) Name() string { return _aae.File.Name }

func (_dae fileInfo) Size() int64 {
	if _dae._da != _aaf {
		return 0
	}
	return _dae.File.Size
}

func (_gc *File) Write(b []byte) (int, error) {
	if _gc.Size < 1 || _gc._dd >= _gc.Size {
		return 0, _fde.EOF
	}
	if _eb := _gc.ensureWriterAt(); _eb != nil {
		return 0, _eb
	}
	_dab := len(b)
	if int64(_dab) > _gc.Size-_gc._dd {
		_dab = int(_gc.Size - _gc._dd)
	}
	_ga, _dfa := _gc.stream(_dab)
	if _dfa != nil {
		return 0, _dfa
	}
	var _dbd, _eec int
	for _, _deeb := range _ga {
		_dfe := _dbd + int(_deeb[1])
		if _dfe < _dbd || _dfe > _dab {
			return 0, Error{ErrWrite, "\u0062\u0061d\u0020\u0077\u0072i\u0074\u0065\u0020\u006c\u0065\u006e\u0067\u0074\u0068", int64(_dfe)}
		}
		_adc, _daa := _gc._cefd._cbd.WriteAt(b[_dbd:_dfe], _deeb[0])
		_eec = _eec + _adc
		if _daa != nil {
			_gc._dd += int64(_eec)
			return _eec, Error{ErrWrite, "\u0075n\u0064\u0065\u0072\u006c\u0079\u0069\u006e\u0067\u0020\u0077\u0072i\u0074\u0065\u0072\u0020\u0066\u0061\u0069\u006c\u0020\u0028" + _daa.Error() + "\u0029", int64(_dbd)}
		}
		_dbd = _dfe
	}
	_gc._dd += int64(_eec)
	if _eec != _dab {
		_dfa = Error{ErrWrite, "\u0062\u0079t\u0065\u0073\u0020\u0077\u0072\u0069\u0074\u0074\u0065\u006e\u0020\u0064\u006f\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0077\u0072\u0069\u0074\u0065\u0020\u0073\u0069\u007a\u0065", int64(_eec)}
	} else if _eec < len(b) {
		_dfa = _fde.EOF
	}
	return _eec, _dfa
}

type Reader struct {
	_abd  bool
	_cdbd uint32
	_fgd  []byte
	_cgf  *header
	File  []*File
	_dfaf []*File
	_afg  int
	_edf  _fde.ReaderAt
	_cbd  _fde.WriterAt
}

func (_cfg Error) Typ() int { return _cfg._gggf }

func (_ed *File) WriteAt(p []byte, off int64) (_febe int, _fdc error) {
	_gbc, _ba, _cdef := _ed._dd, _ed._ge, _ed._agd
	_, _fdc = _ed.Seek(off, 0)
	if _fdc == nil {
		_febe, _fdc = _ed.Write(p)
	}
	_ed._dd, _ed._ge, _ed._agd = _gbc, _ba, _cdef
	return _febe, _fdc
}

func _feg(_gcdb, _aafa uint32) int64 { return int64((_aafa + 1) * _gcdb) }

func (_cffc *File) Read(b []byte) (int, error) {
	if _cffc.Size < 1 || _cffc._dd >= _cffc.Size {
		return 0, _fde.EOF
	}
	_ff := len(b)
	if int64(_ff) > _cffc.Size-_cffc._dd {
		_ff = int(_cffc.Size - _cffc._dd)
	}
	_fda, _ddg := _cffc.stream(_ff)
	if _ddg != nil {
		return 0, _ddg
	}
	var _gde, _cd int
	for _, _fdda := range _fda {
		_dg := _gde + int(_fdda[1])
		if _dg < _gde || _dg > _ff {
			return 0, Error{ErrRead, "\u0062a\u0064 \u0072\u0065\u0061\u0064\u0020\u006c\u0065\u006e\u0067\u0074\u0068", int64(_dg)}
		}
		_bde, _bf := _cffc._cefd._edf.ReadAt(b[_gde:_dg], _fdda[0])
		_cd = _cd + _bde
		if _bf != nil {
			_cffc._dd += int64(_cd)
			return _cd, Error{ErrRead, "\u0075n\u0064\u0065\u0072\u006c\u0079\u0069\u006e\u0067\u0020\u0072\u0065a\u0064\u0065\u0072\u0020\u0066\u0061\u0069\u006c\u0020\u0028" + _bf.Error() + "\u0029", int64(_gde)}
		}
		_gde = _dg
	}
	_cffc._dd += int64(_cd)
	if _cd != _ff {
		_ddg = Error{ErrRead, "\u0062\u0079\u0074e\u0073\u0020\u0072\u0065\u0061\u0064\u0020\u0064\u006f\u0020\u006e\u006f\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020r\u0065\u0061\u0064\u0020\u0073\u0069\u007a\u0065", int64(_cd)}
	} else if _cd < len(b) {
		_ddg = _fde.EOF
	}
	return _cd, _ddg
}

func (_bec *File) seek(_cdc int64) error {
	var _bc bool
	var _cba int64
	if _bec.Size < _fce {
		_bc = true
		_cba = 64
	} else {
		_cba = int64(_bec._cefd._cdbd)
	}
	var _fbd int64
	var _gdd error
	if _bec._ge > 0 {
		if _cba-_bec._ge <= _cdc {
			_bec._agd, _gdd = _bec._cefd.findNext(_bec._agd, _bc)
			if _gdd != nil {
				return _gdd
			}
			_fbd += _cba - _bec._ge
			_bec._ge = 0
			if _fbd == _cdc {
				return nil
			}
		} else {
			_bec._ge += _cdc
			return nil
		}
		if _bec._agd == _cdg {
			return Error{ErrRead, "\u0075\u006ee\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0065\u0061\u0072\u006c\u0079\u0020\u0065\u006e\u0064\u0020\u006f\u0066\u0020\u0063ha\u0069\u006e", int64(_bec._agd)}
		}
	}
	for {
		if _cdc-_fbd < _cba {
			_bec._ge = _cdc - _fbd
			return nil
		} else {
			_fbd += _cba
			_bec._agd, _gdd = _bec._cefd.findNext(_bec._agd, _bc)
			if _gdd != nil {
				return _gdd
			}
			if _fbd == _cdc {
				return nil
			}
		}
	}
}

const (
	_g  uint8 = 0x0
	_ca uint8 = 0x1
)

func (_gbff *Reader) findNext(_gab uint32, _ddf bool) (uint32, error) {
	_ggae := _gbff._cdbd / 4
	_efeg := int(_gab / _ggae)
	var _geed uint32
	if _ddf {
		if _efeg < 0 || _efeg >= len(_gbff._cgf._cdd) {
			return 0, Error{ErrRead, "\u006d\u0069\u006e\u0069\u0073e\u0063\u0074\u006f\u0072\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0069\u0073 \u006f\u0075\u0074\u0073\u0069\u0064\u0065\u0020\u006d\u0069\u006e\u0069\u0046\u0041\u0054\u0020\u0072\u0061\u006e\u0067\u0065", int64(_efeg)}
		}
		_geed = _gbff._cgf._cdd[_efeg]
	} else {
		if _efeg < 0 || _efeg >= len(_gbff._cgf._deg) {
			return 0, Error{ErrRead, "\u0046\u0041\u0054\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0069\u0073\u0020\u006f\u0075t\u0073i\u0064\u0065\u0020\u0044\u0049\u0046\u0041\u0054\u0020\u0072\u0061\u006e\u0067\u0065", int64(_efeg)}
		}
		_geed = _gbff._cgf._deg[_efeg]
	}
	_bcca := _gab % _ggae
	_adae := _feg(_gbff._cdbd, _geed) + int64(_bcca*4)
	_bbbd, _ddd := _gbff.readAt(_adae, 4)
	if _ddd != nil {
		return 0, Error{ErrRead, "\u0062\u0061\u0064\u0020\u0072\u0065\u0061\u0064\u0020\u0066i\u006e\u0064\u0069\u006e\u0067\u0020\u006ee\u0078\u0074\u0020\u0073\u0065\u0063\u0074\u006f\u0072\u0020\u0028" + _ddd.Error() + "\u0029", _adae}
	}
	_gcef := _aa.LittleEndian.Uint32(_bbbd)
	return _gcef, nil
}

func (_bgd *File) ensureWriterAt() error {
	if _bgd._cefd._cbd == nil {
		_afa, _gdf := _bgd._cefd._edf.(_fde.WriterAt)
		if !_gdf {
			return Error{ErrWrite, "\u006d\u0073\u0063\u0066\u0062\u002e\u004ee\u0077\u0020\u006d\u0075\u0073\u0074\u0020\u0062\u0065\u0020\u0067\u0069\u0076\u0065n\u0020R\u0065\u0061\u0064\u0065\u0072\u0041t\u0020\u0063\u006f\u006e\u0076\u0065\u0072t\u0069\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0061\u0020\u0069\u006f\u002e\u0057\u0072\u0069\u0074\u0065\u0072\u0041\u0074\u0020\u0069n\u0020\u006f\u0072\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0077\u0072\u0069t\u0065", 0}
		}
		_bgd._cefd._cbd = _afa
	}
	return nil
}

func (_fdef *Reader) setDifats() error {
	_fdef._cgf._deg = _fdef._cgf._eecb[:]
	if _fdef._cgf._aegf == 0 {
		return nil
	}
	_bddd := (_fdef._cdbd / 4) - 1
	_accc := make([]uint32, 109, _fdef._cgf._aegf*_bddd+109)
	copy(_accc, _fdef._cgf._deg)
	_fdef._cgf._deg = _accc
	_eaf := _fdef._cgf._cedc
	for _ede := 0; _ede < int(_fdef._cgf._aegf); _ede++ {
		_ebg, _dca := _fdef.readAt(_feg(_fdef._cdbd, _eaf), int(_fdef._cdbd))
		if _dca != nil {
			return Error{ErrFormat, "e\u0072r\u006f\u0072\u0020\u0073\u0065\u0074\u0074\u0069n\u0067\u0020\u0044\u0049FA\u0054\u0028" + _dca.Error() + "\u0029", int64(_eaf)}
		}
		for _ffg := 0; _ffg < int(_bddd); _ffg++ {
			_fdef._cgf._deg = append(_fdef._cgf._deg, _aa.LittleEndian.Uint32(_ebg[_ffg*4:_ffg*4+4]))
		}
		_eaf = _aa.LittleEndian.Uint32(_ebg[len(_ebg)-4:])
	}
	return nil
}

type fileInfo struct{ *File }

func (_eeb *File) Modified() _c.Time { return _eeb._fb.Time() }

func (_bed *Reader) getOffset(_ece uint32, _efgf bool) (int64, error) {
	if _efgf {
		_baa := _bed._cdbd / 64
		_gcg := int(_ece / _baa)
		if _gcg >= len(_bed._cgf._gcb) {
			return 0, Error{ErrRead, "\u006di\u006e\u0069s\u0065\u0063\u0074o\u0072\u0020\u006e\u0075\u006d\u0062\u0065r\u0020\u0069\u0073\u0020\u006f\u0075t\u0073\u0069\u0064\u0065\u0020\u006d\u0069\u006e\u0069\u0073\u0065c\u0074\u006f\u0072\u0020\u0072\u0061\u006e\u0067\u0065", int64(_gcg)}
		}
		_bbaf := _ece % _baa
		return int64((_bed._cgf._gcb[_gcg]+1)*_bed._cdbd + _bbaf*64), nil
	}
	return _feg(_bed._cdbd, _ece), nil
}

func (_fdf *Reader) setMiniStream() error {
	if _fdf._dfaf[0]._ce == _cdg || _fdf._cgf._bea == _cdg || _fdf._cgf._cad == 0 {
		return nil
	}
	_bff := int(_fdf._cgf._cad)
	_fdf._cgf._cdd = make([]uint32, _bff)
	_fdf._cgf._cdd[0] = _fdf._cgf._bea
	for _dde := 1; _dde < _bff; _dde++ {
		_ccd, _acf := _fdf.findNext(_fdf._cgf._cdd[_dde-1], false)
		if _acf != nil {
			return Error{ErrFormat, "s\u0065\u0074\u0074\u0069ng\u0020m\u0069\u006e\u0069\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028" + _acf.Error() + "\u0029", int64(_fdf._cgf._cdd[_dde-1])}
		}
		_fdf._cgf._cdd[_dde] = _ccd
	}
	_bff = int(_fdf._cdbd / 4 * _fdf._cgf._cad)
	_fdf._cgf._gcb = make([]uint32, 0, _bff)
	_eabf := _fdf._dfaf[0]._ce
	var _gbab error
	for _eabf != _cdg {
		_fdf._cgf._gcb = append(_fdf._cgf._gcb, _eabf)
		_eabf, _gbab = _fdf.findNext(_eabf, false)
		if _gbab != nil {
			return Error{ErrFormat, "s\u0065\u0074\u0074\u0069ng\u0020m\u0069\u006e\u0069\u0020\u0073t\u0072\u0065\u0061\u006d\u0020\u0028" + _gbab.Error() + "\u0029", int64(_eabf)}
		}
	}
	return nil
}

func New(ra _fde.ReaderAt) (*Reader, error) {
	_gfbf := &Reader{_edf: ra}
	if _, _dcg := ra.(slicer); _dcg {
		_gfbf._abd = true
	} else {
		_gfbf._fgd = make([]byte, _gae)
	}
	if _bfgf := _gfbf.setHeader(); _bfgf != nil {
		return nil, _bfgf
	}
	if !_gfbf._abd && int(_gfbf._cdbd) > len(_gfbf._fgd) {
		_gfbf._fgd = make([]byte, _gfbf._cdbd)
	}
	if _ggdc := _gfbf.setDifats(); _ggdc != nil {
		return nil, _ggdc
	}
	if _gdg := _gfbf.setDirEntries(); _gdg != nil {
		return nil, _gdg
	}
	if _aegd := _gfbf.setMiniStream(); _aegd != nil {
		return nil, _aegd
	}
	if _gge := _gfbf.traverse(); _gge != nil {
		return nil, _gge
	}
	return _gfbf, nil
}

func (_ggg *Reader) Modified() _c.Time { return _ggg.File[0].Modified() }

func (_feb *File) changeSize(_gcd int64) error {
	if _gcd == _feb.Size {
		return nil
	}
	var _gagb *File
	for _, _aac := range _feb._cefd._dfaf {
		if _aac.Name == _feb.Name {
			_gagb = _aac
			break
		}
	}
	if _gagb == nil {
		return _a.Errorf("\u004e\u006f\u0020\u0064\u0069\u0072e\u0063\u0074\u006f\u0072\u0079\u0020\u0065\u006e\u0074\u0072\u0079\u0020\u0066o\u0072\u0020\u0061\u0020\u0066\u0069\u006ce\u003a\u0020\u0025\u0073", _feb.Name)
	}
	_efe := _d.NewBuffer([]byte{})
	if _fed := _aa.Write(_efe, _aa.LittleEndian, _gcd); _fed != nil {
		return _fed
	}
	for _bfa, _acb := range _efe.Bytes() {
		_gagb._fc[_bfa] = _acb
	}
	var _dea int64
	var _adf bool
	if _feb.Size < _fce {
		_adf = true
		_dea = int64(_eba)
	} else {
		_dea = int64(_feb._cefd._cdbd)
	}
	_aeg := int((_feb.Size-1)/_dea) + 1
	_afac := int((_gcd-1)/_dea) + 1
	if _aeg < _afac {
		_beb, _cdb := _feb.findLast(_adf)
		if _cdb != nil {
			return _cdb
		}
		_ced, _cdb := _feb._cefd.findNextFreeSector(_adf)
		if _cdb != nil {
			return _cdb
		}
		for _fag := _afac - _aeg; _fag > 0; _fag-- {
			if _gee := _feb._cefd.saveToFatLocs(_beb, _ced, _adf); _gee != nil {
				return _gee
			}
			if _fag > 1 {
				_beb = _ced
				_ced++
			} else if _ggb := _feb._cefd.saveToFatLocs(_ced, _cdg, _adf); _ggb != nil {
				return _ggb
			}
		}
	} else if _aeg > _afac {
		_dbg := _feb._ce
		var _cde error
		for _cgg := 0; _cgg < _afac-1; _cgg++ {
			_dbg, _cde = _feb._cefd.findNext(_dbg, _adf)
			if _cde != nil {
				return _cde
			}
		}
		if _fcb := _feb._cefd.saveToFatLocs(_dbg, _cdg, _adf); _fcb != nil {
			return _fcb
		}
	}
	_feb.Size = _gcd
	return nil
}

type headerFields struct {
	_bcb  uint64
	_     [16]byte
	_dbdd uint16
	_acea uint16
	_     [2]byte
	_fga  uint16
	_     [2]byte
	_     [6]byte
	_ggcf uint32
	_ebd  uint32
	_dfc  uint32
	_     [4]byte
	_     [4]byte
	_bea  uint32
	_cad  uint32
	_cedc uint32
	_aegf uint32
	_eecb [109]uint32
}

func (_aaaa *File) FileInfo() _cf.FileInfo { return fileInfo{_aaaa} }

const (
	_ab  uint8 = 0x0
	_bg  uint8 = 0x1
	_aaf uint8 = 0x2
	_ae  uint8 = 0x5
)

func (_gaac *Reader) Export() ([]byte, error) {
	_cfgg := _af.NewWriter()
	if _fdcb := _gaac.exportHeader(_cfgg); _fdcb != nil {
		return nil, _fdcb
	}
	if _gbe := _cfgg.FillWithByte(512, _aff); _gbe != nil {
		return nil, _gbe
	}
	_bcd := []uint32{}
	if _fbaf := _gaac.exportDifats(_cfgg); _fbaf != nil {
		return nil, _fbaf
	}
	_dcd, _bga, _agbc := _gaac.exportMiniStream()
	if _agbc != nil {
		return nil, _agbc
	}
	_bcd = append(_bcd, uint32(_cfgg.Len())/_gaac._cdbd)
	if _fcec := _gaac.exportDirEntries(_cfgg); _fcec != nil {
		return nil, _fcec
	}
	_bcd = append(_bcd, uint32(_cfgg.Len())/_gaac._cdbd)
	if _, _eeba := _dcd.WriteTo(_cfgg); _eeba != nil {
		return nil, _eeba
	}
	_bcd = append(_bcd, uint32(_cfgg.Len())/_gaac._cdbd)
	if _, _dbc := _bga.WriteTo(_cfgg); _dbc != nil {
		return nil, _dbc
	}
	_bcd = append(_bcd, uint32(_cfgg.Len())/_gaac._cdbd)
	if _cfeg := _gaac.exportFAT(_cfgg, _bcd); _cfeg != nil {
		return nil, _cfeg
	}
	return _cfgg.Bytes(), nil
}

func (_beaf *Reader) exportMiniStream() (*_af.Writer, *_af.Writer, error) {
	_bdgc, _dbaf := _af.NewWriter(), _af.NewWriter()
	_fbc := uint32(0)
	for _, _degf := range _beaf.File {
		if _degf.Size == 0 {
			continue
		}
		_degf.reset()
		_degf._ce = _fbc
		_cebd := int(_degf.Size) / int(_eba)
		if int(_degf.Size)%int(_eba) != 0 {
			_cebd++
		}
		for _aef := 1; _aef < _cebd; _aef++ {
			_fbc++
			if _edg := _aa.Write(_bdgc, _aa.LittleEndian, _fbc); _edg != nil {
				return nil, nil, _edg
			}
		}
		if _cccb := _aa.Write(_bdgc, _aa.LittleEndian, _cdg); _cccb != nil {
			return nil, nil, _cccb
		}
		_fbc++
		if _, _bbee := _fde.Copy(_dbaf, _degf); _bbee != nil {
			return nil, nil, _bbee
		}
		if _bffd := _dbaf.AlignLength(64); _bffd != nil {
			return nil, nil, _bffd
		}
	}
	if _beg := _bdgc.FillWithByte(int(_beaf._cdbd)-_bdgc.Len(), _aff); _beg != nil {
		return nil, nil, _beg
	}
	if _cdeg := _dbaf.AlignLength(int(_beaf._cdbd)); _cdeg != nil {
		return nil, nil, _cdeg
	}
	return _bdgc, _dbaf, nil
}

func _bba(_gbb uint16, _aad *File) {
	_db(_aad)
	if _aad._da != _aaf {
		return
	}
	if _gbb > 3 {
		_aad.Size = int64(_aa.LittleEndian.Uint64(_aad._fc[:]))
	} else {
		_aad.Size = int64(_aa.LittleEndian.Uint32(_aad._fc[:4]))
	}
}

func (_ebce *Reader) GetEntry(entryName string) (*File, error) {
	for _ade, _edfc := _ebce.Next(); _edfc == nil; _ade, _edfc = _ebce.Next() {
		if _ade.Name == entryName {
			return _ade, nil
		}
	}
	return nil, Error{ErrTraverse, "\u004e\u006f\u0020\u0065\u006e\u0074\u0072\u0079\u0020\u0066o\u0075\u006e\u0064\u0020\u0066\u006f\u0072 \u0067\u0069\u0076\u0065\u006e\u0020\u006e\u0061\u006d\u0065\u002e", 0}
}

func (_age *Reader) findFatLocsOffset(_ffd bool) int64 {
	var _geeb uint32
	if _ffd {
		_geeb = _age._cgf._cdd[0]
	} else {
		_geeb = _age._cgf._deg[0]
	}
	return _feg(_age._cdbd, _geeb)
}

func (_gdda *Reader) findNextFreeSector(_ebc bool) (uint32, error) {
	_dff := _gdda.findFatLocsOffset(_ebc)
	_abbf := uint32(0)
	_eeac := _gdda._cdbd / 4
	for {
		_cfde, _dgcf := _gdda.readAt(_dff, 4)
		if _dgcf != nil {
			return 0, Error{ErrRead, "\u0062\u0061\u0064\u0020\u0072\u0065\u0061\u0064\u0020\u0066i\u006e\u0064\u0069\u006e\u0067\u0020\u006ee\u0078\u0074\u0020\u0073\u0065\u0063\u0074\u006f\u0072\u0020\u0028" + _dgcf.Error() + "\u0029", _dff}
		}
		_cddc := _aa.LittleEndian.Uint32(_cfde)
		if _cddc == _dgb {
			break
		}
		if _abbf >= _eeac {
			return 0, Error{ErrRead, "\u0065\u006e\u0064\u0020of\u0020\u006d\u0069\u006e\u0069\u0046\u0061\u0074\u0020\u0072\u0065\u0061\u0063\u0068e\u0064", _dff}
		}
		_abbf++
		_dff += 4
	}
	return _abbf, nil
}

func (_gg fileInfo) ModTime() _c.Time { return _gg.Modified() }

func (_fcf *Reader) setHeader() error {
	_ebae, _cffa := _fcf.readAt(0, _gae)
	if _cffa != nil {
		return _cffa
	}
	_fcf._cgf = &header{headerFields: _aea(_ebae)}
	if _fcf._cgf._bcb != _gef {
		return Error{ErrFormat, "\u0062\u0061\u0064\u0020\u0073\u0069\u0067\u006e\u0061\u0074\u0075\u0072\u0065", int64(_fcf._cgf._bcb)}
	}
	if _fcf._cgf._fga == 0x0009 || _fcf._cgf._fga == 0x000c {
		_fcf._cdbd = uint32(1 << _fcf._cgf._fga)
	} else {
		return Error{ErrFormat, "\u0069\u006c\u006c\u0065ga\u006c\u0020\u0073\u0065\u0063\u0074\u006f\u0072\u0020\u0073\u0069\u007a\u0065", int64(_fcf._cgf._fga)}
	}
	if _fcf._cgf._aegf > 0 {
		_fbdg := (_fcf._cdbd / 4) - 1
		if int(_fcf._cgf._aegf*_fbdg+109) < 0 {
			return Error{ErrFormat, "\u0044I\u0046A\u0054\u0020\u0069\u006e\u0074 \u006f\u0076e\u0072\u0066\u006c\u006f\u0077", int64(_fcf._cgf._aegf)}
		}
		if _fcf._cgf._aegf*_fbdg+109 > _fcf._cgf._ebd+_fbdg {
			return Error{ErrFormat, "\u006e\u0075\u006d\u0020\u0044\u0049\u0046\u0041\u0054\u0073 \u0065\u0078\u0063\u0065\u0065\u0064\u0073 \u0046\u0041\u0054\u0020\u0073\u0065\u0063\u0074\u006f\u0072\u0073", int64(_fcf._cgf._aegf)}
		}
	}
	if _fcf._cgf._cad > 0 {
		if int(_fcf._cdbd/4*_fcf._cgf._cad) < 0 {
			return Error{ErrFormat, "m\u0069\u006e\u0069\u0020FA\u0054 \u0069\u006e\u0074\u0020\u006fv\u0065\u0072\u0066\u006c\u006f\u0077", int64(_fcf._cgf._cad)}
		}
		if _fcf._cgf._cad > _fcf._cgf._ebd*(_fcf._cdbd/_eba) {
			return Error{ErrFormat, "\u006e\u0075\u006d\u0020\u006d\u0069n\u0069\u0020\u0046\u0041\u0054\u0073\u0020\u0065\u0078\u0063\u0065\u0065\u0064s\u0020\u0046\u0041\u0054\u0020\u0073\u0065c\u0074\u006f\u0072\u0073", int64(_fcf._cgf._ebd)}
		}
	}
	return nil
}

func (_fdb *File) SetEntryContent(b []byte) error {
	if _gag := _fdb.ensureWriterAt(); _gag != nil {
		return _gag
	}
	_fdb.reset()
	if _ea := _fdb.changeSize(int64(len(b))); _ea != nil {
		return _ea
	}
	_, _fcg := _fdb.Write(b)
	return _fcg
}

func _fee(_caf []byte) *directoryEntryFields {
	_fbf := &directoryEntryFields{}
	for _dc := range _fbf._fg {
		_fbf._fg[_dc] = _aa.LittleEndian.Uint16(_caf[_dc*2 : _dc*2+2])
	}
	_fbf._fdd = _aa.LittleEndian.Uint16(_caf[64:66])
	_fbf._da = uint8(_caf[66])
	_fbf._gd = uint8(_caf[67])
	_fbf._eg = _aa.LittleEndian.Uint32(_caf[68:72])
	_fbf._ag = _aa.LittleEndian.Uint32(_caf[72:76])
	_fbf._de = _aa.LittleEndian.Uint32(_caf[76:80])
	_fbf._ef = _aaa.MustGuid(_caf[80:96])
	copy(_fbf._gb[:], _caf[96:100])
	_fbf._aafc = _aaa.MustFileTime(_caf[100:108])
	_fbf._fb = _aaa.MustFileTime(_caf[108:116])
	_fbf._ce = _aa.LittleEndian.Uint32(_caf[116:120])
	copy(_fbf._fc[:], _caf[120:128])
	return _fbf
}

func (_df *Reader) setDirEntries() error {
	_fgc := 20
	if _df._cgf._ggcf > 0 {
		_fgc = int(_df._cgf._ggcf)
	}
	_dec := make([]*File, 0, _fgc)
	_cef := make(map[uint32]bool)
	_cb := int(_df._cdbd / _dbgg)
	_dee := _df._cgf._dfc
	for _dee != _cdg {
		_cg, _bb := _df.readAt(_feg(_df._cdbd, _dee), int(_df._cdbd))
		if _bb != nil {
			return Error{ErrRead, "\u0064\u0069\u0072\u0065\u0063\u0074\u006f\u0072\u0079\u0020e\u006e\u0074\u0072\u0069\u0065\u0073\u0020r\u0065\u0061\u0064\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0028" + _bb.Error() + "\u0029", _feg(_df._cdbd, _dee)}
		}
		for _dcb := 0; _dcb < _cb; _dcb++ {
			_ee := &File{_cefd: _df}
			_ee.directoryEntryFields = _fee(_cg[_dcb*int(_dbgg):])
			_bba(_df._cgf._acea, _ee)
			_ee._agd = _ee._ce
			_dec = append(_dec, _ee)
		}
		_cc, _bb := _df.findNext(_dee, false)
		if _bb != nil {
			return Error{ErrRead, "d\u0069\u0072\u0065\u0063\u0074\u006f\u0072\u0079\u0020\u0065\u006e\u0074\u0072\u0069\u0065\u0073\u0020\u0065r\u0072\u006f\u0072\u0020\u0066\u0069\u006e\u0064\u0069\u006eg \u0073\u0065\u0063t\u006fr\u0020\u0028" + _bb.Error() + "\u0029", int64(_cc)}
		}
		if _cc <= _dee {
			if _cc == _dee || _cef[_cc] {
				return Error{ErrRead, "\u0064\u0069\u0072\u0065\u0063\u0074\u006f\u0072\u0079\u0020e\u006e\u0074\u0072\u0069\u0065\u0073\u0020s\u0065\u0063\u0074\u006f\u0072\u0020\u0063\u0079\u0063\u006c\u0065", int64(_cc)}
			}
			_cef[_cc] = true
		}
		_dee = _cc
	}
	_df._dfaf = _dec
	return nil
}

func (_ceb *File) Created() _c.Time { return _ceb._aafc.Time() }

func (_abg *Reader) traverse() error {
	_abg.File = make([]*File, 0, len(_abg._dfaf))
	var (
		_gba func(int, []string)
		_bbe error
		_cbc int
	)
	_gba = func(_bbad int, _be []string) {
		_cbc++
		if _cbc > len(_abg._dfaf) {
			_bbe = Error{ErrTraverse, "\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c\u0020\u0063o\u0075\u006e\u0074\u0065\u0072\u0020\u006f\u0076\u0065\u0072f\u006c\u006f\u0077", int64(_bbad)}
			return
		}
		if _bbad < 0 || _bbad >= len(_abg._dfaf) {
			_bbe = Error{ErrTraverse, "\u0069\u006c\u006ceg\u0061\u006c\u0020\u0074\u0072\u0061\u0076\u0065\u0072\u0073\u0061\u006c\u0020\u0069\u006e\u0064\u0065\u0078", int64(_bbad)}
			return
		}
		_dac := _abg._dfaf[_bbad]
		if _dac._eg != _dada {
			_gba(int(_dac._eg), _be)
		}
		_abg.File = append(_abg.File, _dac)
		_dac.Path = _be
		if _dac._de != _dada {
			if _bbad > 0 {
				_gba(int(_dac._de), append(_be, _dac.Name))
			} else {
				_gba(int(_dac._de), _be)
			}
		}
		if _dac._ag != _dada {
			_gba(int(_dac._ag), _be)
		}
		return
	}
	_gba(0, []string{})
	return _bbe
}

func _cbb(_gce *directoryEntryFields) (*_d.Buffer, error) {
	_ebf := _d.NewBuffer([]byte{})
	for _, _ec := range _gce._fg {
		if _fea := _aa.Write(_ebf, _aa.LittleEndian, &_ec); _fea != nil {
			return nil, _fea
		}
	}
	if _bgf := _aa.Write(_ebf, _aa.LittleEndian, &_gce._fdd); _bgf != nil {
		return nil, _bgf
	}
	if _egf := _aa.Write(_ebf, _aa.LittleEndian, &_gce._da); _egf != nil {
		return nil, _egf
	}
	if _dgc := _aa.Write(_ebf, _aa.LittleEndian, &_gce._gd); _dgc != nil {
		return nil, _dgc
	}
	if _cgb := _aa.Write(_ebf, _aa.LittleEndian, &_gce._eg); _cgb != nil {
		return nil, _cgb
	}
	if _ggd := _aa.Write(_ebf, _aa.LittleEndian, &_gce._ag); _ggd != nil {
		return nil, _ggd
	}
	if _gga := _aa.Write(_ebf, _aa.LittleEndian, &_gce._de); _gga != nil {
		return nil, _gga
	}
	if _egc := _aa.Write(_ebf, _aa.LittleEndian, &_gce._ef.DataA); _egc != nil {
		return nil, _egc
	}
	if _abe := _aa.Write(_ebf, _aa.LittleEndian, &_gce._ef.DataB); _abe != nil {
		return nil, _abe
	}
	if _ggc := _aa.Write(_ebf, _aa.LittleEndian, &_gce._ef.DataC); _ggc != nil {
		return nil, _ggc
	}
	if _, _dad := _ebf.Write(_gce._ef.DataD[:]); _dad != nil {
		return nil, _dad
	}
	if _, _fec := _ebf.Write(_gce._gb[:]); _fec != nil {
		return nil, _fec
	}
	if _eea := _aa.Write(_ebf, _aa.LittleEndian, &_gce._aafc.Low); _eea != nil {
		return nil, _eea
	}
	if _afb := _aa.Write(_ebf, _aa.LittleEndian, &_gce._aafc.High); _afb != nil {
		return nil, _afb
	}
	if _egfe := _aa.Write(_ebf, _aa.LittleEndian, &_gce._fb.Low); _egfe != nil {
		return nil, _egfe
	}
	if _add := _aa.Write(_ebf, _aa.LittleEndian, &_gce._fb.High); _add != nil {
		return nil, _add
	}
	if _agbgg := _aa.Write(_ebf, _aa.LittleEndian, &_gce._ce); _agbgg != nil {
		return nil, _agbgg
	}
	if _, _gfed := _ebf.Write(_gce._fc[:]); _gfed != nil {
		return nil, _gfed
	}
	return _ebf, nil
}

func (_cag *Reader) readAt(_aag int64, _gfd int) ([]byte, error) {
	if _cag._abd {
		_cgbe, _eebc := _cag._edf.(slicer).Slice(_aag, _gfd)
		if _eebc != nil {
			return nil, Error{ErrRead, "\u0073\u006c\u0069\u0063er\u0020\u0072\u0065\u0061\u0064\u0020\u0065\u0072\u0072\u006f\u0072\u0020\u0028" + _eebc.Error() + "\u0029", _aag}
		}
		return _cgbe, nil
	}
	if _gfd > len(_cag._fgd) {
		return nil, Error{ErrRead, "\u0072\u0065ad\u0020\u006c\u0065n\u0067\u0074\u0068\u0020gre\u0061te\u0072\u0020\u0074\u0068\u0061\u006e\u0020re\u0061\u0064\u0020\u0062\u0075\u0066\u0066e\u0072", int64(_gfd)}
	}
	if _, _ccb := _cag._edf.ReadAt(_cag._fgd[:_gfd], _aag); _ccb != nil {
		return nil, Error{ErrRead, _ccb.Error(), _aag}
	}
	return _cag._fgd[:_gfd], nil
}

func (_ad fileInfo) Sys() interface{} { return nil }

func (_gfc *Reader) exportDirEntries(_bad *_af.Writer) error {
	if int64(_bad.Len()) != _feg(_gfc._cdbd, _gfc._cgf._dfc) {
		return Error{ErrWrite, _a.Sprintf("I\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0077\u0072\u0069\u0074\u0065\u0072\u0020l\u0065\u006e\u0067t\u0068:\u0020\u0025\u0076", _bad.Len()), 0}
	}
	for _, _bdeb := range _gfc._dfaf {
		_bbbb, _aeb := _cbb(_bdeb.directoryEntryFields)
		if _aeb != nil {
			return _aeb
		}
		if _, _gbf := _fde.Copy(_bad, _bbbb); _gbf != nil {
			return _gbf
		}
	}
	return nil
}

func (_gcbg *Reader) saveToFatLocs(_bca uint32, _cged interface{}, _acbe bool) error {
	_faee := _d.NewBuffer([]byte{})
	if _cbga := _aa.Write(_faee, _aa.LittleEndian, _cged); _cbga != nil {
		return _cbga
	}
	_dgbbc := _gcbg.findFatLocsOffset(_acbe) + int64(_bca*4)
	_, _dcbc := _gcbg._cbd.WriteAt(_faee.Bytes(), _dgbbc)
	return _dcbc
}

func (_bd *File) mode() _cf.FileMode {
	if _bd._da != _aaf {
		return _cf.ModeDir | 0777
	}
	return 0666
}

type File struct {
	Name    string
	Initial uint16
	Path    []string
	Size    int64
	_dd     int64
	_agd    uint32
	_ge     int64
	*directoryEntryFields
	_cefd *Reader
}

func (_aacb *File) Seek(offset int64, whence int) (int64, error) {
	var _gdfc int64
	switch whence {
	default:
		return 0, Error{ErrSeek, "\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u0077h\u0065\u006e\u0063\u0065", int64(whence)}
	case 0:
		_gdfc = offset
	case 1:
		_gdfc = _aacb._dd + offset
	case 2:
		_gdfc = _aacb.Size - offset
	}
	switch {
	case _gdfc < 0:
		return _aacb._dd, Error{ErrSeek, "\u0063\u0061\u006e'\u0074\u0020\u0073\u0065e\u006b\u0020\u0062\u0065\u0066\u006f\u0072e\u0020\u0073\u0074\u0061\u0072\u0074\u0020\u006f\u0066\u0020\u0046\u0069\u006c\u0065", _gdfc}
	case _gdfc >= _aacb.Size:
		return _aacb._dd, Error{ErrSeek, "c\u0061\u006e\u0027\u0074\u0020\u0073e\u0065\u006b\u0020\u0070\u0061\u0073\u0074\u0020\u0046i\u006c\u0065\u0020l\u0065n\u0067\u0074\u0068", _gdfc}
	case _gdfc == _aacb._dd:
		return _gdfc, nil
	case _gdfc > _aacb._dd:
		_abb := _aacb._dd
		_aacb._dd = _gdfc
		return _aacb._dd, _aacb.seek(_gdfc - _abb)
	}
	if _aacb._ge >= _aacb._dd-_gdfc {
		_aacb._ge = _aacb._ge - (_aacb._dd - _gdfc)
		_aacb._dd = _gdfc
		return _aacb._dd, nil
	}
	_aacb._ge = 0
	_aacb._agd = _aacb._ce
	_aacb._dd = _gdfc
	return _aacb._dd, _aacb.seek(_gdfc)
}

type slicer interface {
	Slice(_fgag int64, _ecf int) ([]byte, error)
}

const (
	ErrFormat = iota
	ErrRead
	ErrSeek
	ErrWrite
	ErrTraverse
)

const _e int = 64 + 4*4 + 16 + 4 + 8*2 + 4 + 8

const (
	_gef  uint64 = 0xE11AB1A1E011CFD0
	_eba  uint32 = 64
	_fce  int64  = 4096
	_dbgg uint32 = 128
)

const (
	_egfb uint32 = 0xFFFFFFFA
	_fef  uint32 = 0xFFFFFFFC
	_fbe  uint32 = 0xFFFFFFFD
	_cdg  uint32 = 0xFFFFFFFE
	_dgb  uint32 = 0xFFFFFFFF
	_aff  byte   = 0xFF
	_efg  uint32 = 0xFFFFFFFA
	_dada uint32 = 0xFFFFFFFF
)

func (_ac fileInfo) IsDir() bool { return _ac.mode().IsDir() }

func _db(_gdc *File) {
	if _gdc._fdd < 4 || _gdc._fdd > 64 {
		return
	}
	_cfd := int(_gdc._fdd/2 - 1)
	_gdc.Initial = _gdc._fg[0]
	var _fgb int
	if !_fd.IsPrint(rune(_gdc.Initial)) {
		_fgb = 1
	}
	_gdc.Name = string(_fe.Decode(_gdc._fg[_fgb:_cfd]))
}

func (_dba *Reader) Next() (*File, error) {
	_dba._afg++
	if _dba._afg >= len(_dba.File) {
		return nil, _fde.EOF
	}
	return _dba.File[_dba._afg], nil
}

func (_eab *Reader) GetHeader() *header { return _eab._cgf }

func (_fge *File) findLast(_gaa bool) (uint32, error) {
	_fba := _fge._ce
	for {
		_dfg, _cga := _fge._cefd.findNext(_fba, _gaa)
		if _cga != nil {
			return 0, Error{ErrRead, "\u0062\u0061\u0064\u0020\u0072\u0065\u0061\u0064\u0020\u0066i\u006e\u0064\u0069\u006e\u0067\u0020\u006ee\u0078\u0074\u0020\u0073\u0065\u0063\u0074\u006f\u0072\u0020\u0028" + _cga.Error() + "\u0029", 0}
		}
		if _dfg == _cdg {
			break
		}
		_fba = _dfg
	}
	return _fba, nil
}

func (_fae *Reader) exportHeader(_gbag *_af.Writer) error {
	if _aegdb := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._bcb); _aegdb != nil {
		return _aegdb
	}
	if _ccc := _gbag.Skip(16); _ccc != nil {
		return _ccc
	}
	if _fca := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._dbdd); _fca != nil {
		return _fca
	}
	if _fcc := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._acea); _fcc != nil {
		return _fcc
	}
	if _eac := _aa.Write(_gbag, _aa.LittleEndian, uint16(0xfffe)); _eac != nil {
		return _eac
	}
	if _gff := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._fga); _gff != nil {
		return _gff
	}
	if _bfc := _aa.Write(_gbag, _aa.LittleEndian, uint16(0x0006)); _bfc != nil {
		return _bfc
	}
	if _fabe := _gbag.Skip(6); _fabe != nil {
		return _fabe
	}
	if _fff := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._ggcf); _fff != nil {
		return _fff
	}
	if _cdae := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._ebd); _cdae != nil {
		return _cdae
	}
	if _bdga := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._dfc); _bdga != nil {
		return _bdga
	}
	if _ebgd := _gbag.Skip(4); _ebgd != nil {
		return _ebgd
	}
	if _ffa := _aa.Write(_gbag, _aa.LittleEndian, uint32(0x00001000)); _ffa != nil {
		return _ffa
	}
	if _bfgd := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._bea); _bfgd != nil {
		return _bfgd
	}
	if _agdc := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._cad); _agdc != nil {
		return _agdc
	}
	if _cdbc := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._cedc); _cdbc != nil {
		return _cdbc
	}
	if _bbf := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._aegf); _bbf != nil {
		return _bbf
	}
	for _bag := 0; _bag < 109; _bag++ {
		if _eacc := _aa.Write(_gbag, _aa.LittleEndian, &_fae._cgf._eecb[_bag]); _eacc != nil {
			return _eacc
		}
	}
	return nil
}

const _gae int = 8 + 16 + 10 + 6 + 12 + 8 + 16 + 109*4

type directoryEntryFields struct {
	_fg   [32]uint16
	_fdd  uint16
	_da   uint8
	_gd   uint8
	_eg   uint32
	_ag   uint32
	_de   uint32
	_ef   _aaa.Guid
	_gb   [4]byte
	_aafc _aaa.FileTime
	_fb   _aaa.FileTime
	_ce   uint32
	_fc   [8]byte
}

func (_dcgb *Reader) ID() string { return _dcgb.File[0].ID() }

func _daaa(_ebb [][2]int64) [][2]int64 {
	_gfe := len(_ebb)
	for _fedd, _ace := 0, 0; _fedd < _gfe && _ace+1 < len(_ebb); _fedd++ {
		if _ebb[_ace][0]+_ebb[_ace][1] == _ebb[_ace+1][0] {
			_ebb[_ace][1] = _ebb[_ace][1] + _ebb[_ace+1][1]
			for _geg := range _ebb[_ace+1 : len(_ebb)-1] {
				_ebb[_ace+1+_geg] = _ebb[_geg+_ace+2]
			}
			_ebb = _ebb[:len(_ebb)-1]
		} else {
			_ace += 1
		}
	}
	return _ebb
}

func (_dfea *Reader) Created() _c.Time { return _dfea.File[0].Created() }

func (_cdbg Error) Error() string {
	return "\u006ds\u0063\u0066\u0062\u003a\u0020" + _cdbg._cfe + "\u003b\u0020" + _b.FormatInt(_cdbg._acfd, 10)
}

func (_efc *File) reset() { _efc._dd = 0; _efc._ge = 0; _efc._agd = _efc._ce }

func (_gf fileInfo) Mode() _cf.FileMode { return _gf.File.mode() }

func (_ceg *Reader) exportFAT(_fbab *_af.Writer, _cfege []uint32) error {
	if _ceg._cgf._ebd == 0 {
		return nil
	}
	_dfcg := _d.NewBuffer([]byte{})
	if _dfeg := _aa.Write(_dfcg, _aa.LittleEndian, _fbe); _dfeg != nil {
		return _dfeg
	}
	for _ecb := 0; _ecb < len(_cfege)-1; _ecb++ {
		for _ebgdc := _cfege[_ecb]; _ebgdc < _cfege[_ecb+1]-1; _ebgdc++ {
			if _fgbb := _aa.Write(_dfcg, _aa.LittleEndian, _ebgdc); _fgbb != nil {
				return _fgbb
			}
		}
		if _acfc := _aa.Write(_dfcg, _aa.LittleEndian, _cdg); _acfc != nil {
			return _acfc
		}
	}
	_gcee := 512
	for _, _cge := range _dfcg.Bytes() {
		if _ded := _fbab.WriteByteAt(_cge, _gcee); _ded != nil {
			return _ded
		}
		_gcee++
	}
	return nil
}
