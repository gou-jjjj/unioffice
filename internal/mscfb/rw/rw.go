//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package rw

import (
	_c "bytes"
	_f "encoding/binary"
	_d "errors"
	_ae "fmt"
	_b "io"
	_e "io/ioutil"
	_af "reflect"
)

func PopRightUI64(v uint64) (bool, uint64) { return (v & uint64(1)) == 1, v >> 1 }

type Reader struct{ *_c.Reader }

func (_eg *Writer) tryGrowByReslice(_fa int) (int, bool) {
	if _bge := len(_eg._gd); _fa <= cap(_eg._gd)-_bge {
		_eg._gd = _eg._gd[:_bge+_fa]
		return _bge, true
	}
	return 0, false
}
func (_ecc *Writer) Len() int            { return len(_ecc._gd) - _ecc._ed }
func (_edb *Writer) Bytes() []byte       { return _edb._gd }
func (_efa *Writer) align(_gc int) error { return _efa.Skip((_gc - (_efa.Len())%_gc) % _gc) }
func (_gbd *Writer) reset()              { _gbd._gd = _gbd._gd[:0]; _gbd._ed = 0 }
func (_dbg *Writer) WriteTo(wTo _b.Writer) (_gbb int64, _dd error) {
	if _ecef := _dbg.Len(); _ecef > 0 {
		_df, _ddg := wTo.Write(_dbg._gd[_dbg._ed:])
		if _df > _ecef {
			return 0, _d.New("\u0072\u0077\u002e\u0057\u0072\u0069\u0074\u0065\u0072\u002e\u0057\u0072\u0069\u0074\u0065\u0054\u006f\u003a\u0020\u0069\u006e\u0076\u0061\u006ci\u0064\u0020\u0057\u0072\u0069t\u0065\u0020c\u006f\u0075\u006e\u0074")
		}
		_dbg._ed += _df
		_gbb = int64(_df)
		if _ddg != nil {
			return _gbb, _ddg
		}
		if _df != _ecef {
			return _gbb, _b.ErrShortWrite
		}
	}
	_dbg.reset()
	return _gbb, nil
}
func (_g *Reader) ReadPairProperty(p interface{}) error {
	if _gb := _g.align(4); _gb != nil {
		return _gb
	}
	_ff := _af.ValueOf(p)
	for _ff.Kind() == _af.Ptr {
		_ff = _ff.Elem()
	}
	if !_ff.IsValid() {
		return _ae.Errorf("\u0076a\u006cu\u0065\u0020\u0069\u0073\u0020n\u006f\u0074 \u0076\u0061\u006c\u0069\u0064")
	}
	if _cc := _f.Read(_g, _f.LittleEndian, p); _cc != nil {
		return _cc
	}
	return nil
}
func (_efbb *Writer) curPos() int { return int(_efbb.Cap()) - _efbb.Len() }

type Writer struct {
	_gd []byte
	_ed int
}

func (_ea *Writer) AlignLength(alignTo int) error {
	_fea := _ea.Len() % alignTo
	if _fea > 0 {
		_, _ece := _ea.Write(make([]byte, alignTo-_fea))
		if _ece != nil {
			return _ece
		}
	}
	return nil
}
func (_ge *Writer) WriteProperty(a interface{}) error {
	if _ec := _ge.align(int(_af.TypeOf(a).Size())); _ec != nil {
		return _ec
	}
	return _ge.WritePropertyNoAlign(a)
}

const _cg = int(^uint(0) >> 1)

func _da(_dbgg int) []byte {
	defer func() {
		if recover() != nil {
			panic(_ccf)
		}
	}()
	return make([]byte, _dbgg)
}
func PopRightUI32(v uint32) (bool, uint32) { return (v & uint32(1)) == 1, v >> 1 }
func (_efe *Writer) Write(p []byte) (_fd int, _feb error) {
	_ffb, _cga := _efe.tryGrowByReslice(len(p))
	if !_cga {
		var _ab error
		_ffb, _ab = _efe.grow(len(p))
		if _ab != nil {
			return 0, _ab
		}
	}
	return copy(_efe._gd[_ffb:], p), nil
}
func (_ef *Reader) curPos() int { return int(_ef.Size()) - _ef.Len() }
func PushLeftUI32(v uint32, flag bool) uint32 {
	v >>= 1
	if flag {
		v |= 1 << 31
	}
	return v
}
func (_bdf *Writer) grow(_cgc int) (int, error) {
	_bf := _bdf.Len()
	if _bf == 0 && _bdf._ed != 0 {
		_bdf.reset()
	}
	if _bcg, _bcf := _bdf.tryGrowByReslice(_cgc); _bcf {
		return _bcg, nil
	}
	if _bdf._gd == nil && _cgc <= _gde {
		_bdf._gd = make([]byte, _cgc, _gde)
		return 0, nil
	}
	_ee := cap(_bdf._gd)
	if _cgc <= _ee/2-_bf {
		copy(_bdf._gd, _bdf._gd[_bdf._ed:])
	} else if _ee > _cg-_ee-_cgc {
		return 0, _ccf
	} else {
		_gce := _da(2*_ee + _cgc)
		copy(_gce, _bdf._gd[_bdf._ed:])
		_bdf._gd = _gce
	}
	_bdf._ed = 0
	_bdf._gd = _bdf._gd[:_bf+_cgc]
	return _bf, nil
}
func (_ad *Writer) WriteStringProperty(s string) error {
	_ad.align(4)
	_ada := []byte(s)
	if _geb := _f.Write(_ad, _f.LittleEndian, &_ada); _geb != nil {
		return _geb
	}
	return nil
}

var _ccf = _d.New("r\u0077.\u0057\u0072\u0069\u0074\u0065\u0072\u003a\u0020t\u006f\u006f\u0020\u006car\u0067\u0065")

func NewWriter() *Writer { return &Writer{_gd: []byte{}} }
func (_ecg *Writer) WriteByteAt(b byte, off int) error {
	if off >= len(_ecg._gd) {
		return _d.New("\u004f\u0075\u0074\u0020\u006f\u0066\u0020\u0062\u006f\u0075\u006e\u0064\u0073")
	}
	_ecg._gd[off] = b
	return nil
}
func (_bb *Reader) align(_ag int) error { return _bb.skip((_ag - _bb.curPos()%_ag) % _ag) }
func (_cf *Reader) skip(_db int) error {
	_, _bc := _b.CopyN(_e.Discard, _cf, int64(_db))
	if _bc != nil {
		return _bc
	}
	return nil
}
func (_ca *Writer) WritePropertyNoAlign(a interface{}) error {
	if _aec := _f.Write(_ca, _f.LittleEndian, a); _aec != nil {
		return _aec
	}
	return nil
}
func (_ce *Reader) ReadProperty(a interface{}) error {
	_aed := _af.ValueOf(a)
	for _aed.Kind() == _af.Ptr {
		_aed = _aed.Elem()
	}
	if !_aed.IsValid() {
		return _ae.Errorf("\u0076a\u006cu\u0065\u0020\u0069\u0073\u0020n\u006f\u0074 \u0076\u0061\u006c\u0069\u0064")
	}
	if _fe := _ce.align(int(_aed.Type().Size())); _fe != nil {
		return _fe
	}
	if _cb := _f.Read(_ce, _f.LittleEndian, a); _cb != nil {
		return _cb
	}
	return nil
}
func (_ccb *Writer) FillWithByte(fillSize int, b byte) error {
	for _gebg := 0; _gebg < fillSize; _gebg++ {
		if _ffbg := _ccb.WritePropertyNoAlign(b); _ffbg != nil {
			return _ffbg
		}
	}
	return nil
}

const _gde = 64

func (_dg *Writer) Cap() int              { return cap(_dg._gd) }
func NewReader(b []byte) (*Reader, error) { return &Reader{_c.NewReader(b)}, nil }
func PushLeftUI64(v uint64, flag bool) uint64 {
	v >>= 1
	if flag {
		v |= 1 << 63
	}
	return v
}
func (_gf *Reader) ReadStringProperty(n uint32) (string, error) {
	if _ga := _gf.align(4); _ga != nil {
		return "", _ga
	}
	_efb := make([]byte, n)
	if _bd := _f.Read(_gf, _f.LittleEndian, &_efb); _bd != nil {
		return "", _bd
	}
	return string(_efb), nil
}
func (_ffc *Writer) Skip(n int) error {
	if n == 0 {
		return nil
	}
	_, _cfa := _ffc.Write(make([]byte, n))
	return _cfa
}
