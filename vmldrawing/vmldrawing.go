//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package vmldrawing

import (
	_ca "encoding/xml"
	_d "fmt"
	_cg "strconv"
	_a "strings"

	_cd "github.com/gou-jjjj/unioffice"
	_f "github.com/gou-jjjj/unioffice/common/logger"
	_ag "github.com/gou-jjjj/unioffice/schema/soo/ofc/sharedTypes"
	_ad "github.com/gou-jjjj/unioffice/schema/urn/schemas_microsoft_com/office/excel"
	_fb "github.com/gou-jjjj/unioffice/schema/urn/schemas_microsoft_com/vml"
)

// SetFontFamily sets text's fontFamily.
func (_ege *TextpathStyle) SetFontFamily(fontFamily string) { _ege._fc = fontFamily }

// ToString generate string of TextpathStyle.
func (_dafd *TextpathStyle) String() string {
	_bgb := ""
	_bgb += _d.Sprintf("\u0066o\u006et\u002d\u0066\u0061\u006d\u0069\u006c\u0079\u003a\u0025\u0073\u003b", _dafd._fc)
	_bgb += _d.Sprintf("\u0066o\u006et\u002d\u0073\u0069\u007a\u0065\u003a\u0025\u0064\u0070\u0074\u003b", _dafd._cec)
	if _dafd._ggd {
		_bgb += "\u0066o\u006et\u002d\u0073\u0074\u0079\u006ce\u003a\u0069t\u0061\u006c\u0069\u0063\u003b"
	}
	if _dafd._ffe {
		_bgb += "\u0066\u006f\u006e\u0074\u002d\u0077\u0065\u0069\u0067\u0068\u0074\u003ab\u006f\u006c\u0064\u003b"
	}
	return _bgb
}
func (_bf *Container) UnmarshalXML(d *_ca.Decoder, start _ca.StartElement) error {
	_bf.Shape = nil
_gc:
	for {
		_ec, _bg := d.Token()
		if _bg != nil {
			return _bg
		}
		switch _ce := _ec.(type) {
		case _ca.StartElement:
			switch _ce.Name.Local {
			case "s\u0068\u0061\u0070\u0065\u006c\u0061\u0079\u006f\u0075\u0074":
				_bf.Layout = _fb.NewOfcShapelayout()
				if _db := d.DecodeElement(_bf.Layout, &_ce); _db != nil {
					return _db
				}
			case "\u0073h\u0061\u0070\u0065\u0074\u0079\u0070e":
				_bf.ShapeType = _fb.NewShapetype()
				if _aabe := d.DecodeElement(_bf.ShapeType, &_ce); _aabe != nil {
					return _aabe
				}
			case "\u0073\u0068\u0061p\u0065":
				_bc := _fb.NewShape()
				if _gdf := d.DecodeElement(_bc, &_ce); _gdf != nil {
					return _gdf
				}
				_bf.Shape = append(_bf.Shape, _bc)
			}
		case _ca.EndElement:
			break _gc
		}
	}
	return nil
}

// SetBold sets text to bold.
func (_bgf *TextpathStyle) SetBold(bold bool) { _bgf._ffe = bold }

// Bottom get bottom attribute of shape style.
func (_dgf *ShapeStyle) Bottom() float64 { return _dgf._bga }

// FontSize returns fontSize of the text.
func (_def *TextpathStyle) FontSize() int64 { return _def._cec }

// Width return width of shape.
func (_ecd *ShapeStyle) Width() float64 { return _ecd._fba }
func NewContainer() *Container          { return &Container{} }

// IsItalic returns true if text is italic.
func (_eae *TextpathStyle) IsItalic() bool { return _eae._ggd }

// SetWidth set width of shape.
func (_cf *ShapeStyle) SetWidth(width float64) { _cf._fba = width }

// MSOPositionHorizontalRelative get `mso-position-horizontal-relative` attribute of shape style.
func (_bd *ShapeStyle) MSOPositionHorizontalRelative() string { return _bd._be }

type Container struct {
	Layout    *_fb.OfcShapelayout
	ShapeType *_fb.Shapetype
	Shape     []*_fb.Shape
}

// Position get position attribute of shape style.
func (_cfc *ShapeStyle) Position() string { return _cfc._dc }

// Height return height of shape.
func (_ff *ShapeStyle) Height() float64 { return _ff._dg }

// Right get right attribute of shape style.
func (_cgg *ShapeStyle) Right() float64 { return _cgg._ea }

// SetItalic sets text to italic.
func (_ef *TextpathStyle) SetItalic(italic bool) { _ef._ggd = italic }

// SetHeight set height of shape.
func (_eaa *ShapeStyle) SetHeight(height float64) { _eaa._dg = height }

// NewCommentShape creates a new comment shape for a given cell index.  The
// indices here are zero based.
func NewCommentShape(col, row int64) *_fb.Shape {
	_aab := _fb.NewShape()
	_aab.IdAttr = _cd.String(_d.Sprintf("\u0063\u0073\u005f\u0025\u0064\u005f\u0025\u0064", col, row))
	_aab.TypeAttr = _cd.String("\u0023\u005f\u00780\u0030\u0030\u0030\u005f\u0074\u0032\u0030\u0032")
	_aab.StyleAttr = _cd.String("\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u003a\u0061\u0062\u0073\u006f\u006cu\u0074\u0065\u003b\u006d\u0061\u0072\u0067\u0069\u006e\u002d\u006c\u0065\u0066\u0074:\u0038\u0030\u0070\u0074;\u006d\u0061\u0072\u0067\u0069n-\u0074o\u0070\u003a\u0032pt\u003b\u0077\u0069\u0064\u0074\u0068\u003a1\u0030\u0034\u0070\u0074\u003b\u0068\u0065\u0069\u0067\u0068\u0074\u003a\u0037\u0036\u0070\u0074\u003b\u007a\u002d\u0069\u006e\u0064\u0065x\u003a\u0031\u003bv\u0069\u0073\u0069\u0062\u0069\u006c\u0069t\u0079\u003a\u0068\u0069\u0064\u0064\u0065\u006e")
	_aab.FillcolorAttr = _cd.String("\u0023f\u0062\u0066\u0036\u0064\u0036")
	_aab.StrokecolorAttr = _cd.String("\u0023e\u0064\u0065\u0061\u0061\u0031")
	_e := _fb.NewFill()
	_e.Color2Attr = _cd.String("\u0023f\u0062\u0066\u0065\u0038\u0032")
	_e.AngleAttr = _cd.Float64(-180)
	_e.TypeAttr = _fb.ST_FillTypeGradient
	_e.Fill = _fb.NewOfcFill()
	_e.Fill.ExtAttr = _fb.ST_ExtView
	_e.Fill.TypeAttr = _fb.OfcST_FillTypeGradientUnscaled
	_aab.ShapeChoice = append(_aab.ShapeChoice, &_fb.CT_ShapeChoice{ShapeElementsChoice: &_fb.EG_ShapeElementsChoice{Fill: _e}})
	_ed := _fb.NewShadow()
	_ed.OnAttr = _ag.ST_TrueFalseT
	_ed.ObscuredAttr = _ag.ST_TrueFalseT
	_aab.ShapeChoice = append(_aab.ShapeChoice, &_fb.CT_ShapeChoice{ShapeElementsChoice: &_fb.EG_ShapeElementsChoice{Shadow: _ed}})
	_agd := _fb.NewPath()
	_agd.ConnecttypeAttr = _fb.OfcST_ConnectTypeNone
	_aab.ShapeChoice = append(_aab.ShapeChoice, &_fb.CT_ShapeChoice{ShapeElementsChoice: &_fb.EG_ShapeElementsChoice{Path: _agd}})
	_da := _fb.NewTextbox()
	_da.StyleAttr = _cd.String("\u006d\u0073\u006f\u002ddi\u0072\u0065\u0063\u0074\u0069\u006f\u006e\u002d\u0061\u006c\u0074\u003a\u0061\u0075t\u006f")
	_aab.ShapeChoice = append(_aab.ShapeChoice, &_fb.CT_ShapeChoice{ShapeElementsChoice: &_fb.EG_ShapeElementsChoice{Textbox: _da}})
	_ac := _ad.NewClientData()
	_ac.ObjectTypeAttr = _ad.ST_ObjectTypeNote
	_ac.ClientDataChoice = []*_ad.CT_ClientDataChoice{{MoveWithCells: _ag.ST_TrueFalseBlankT}, {SizeWithCells: _ag.ST_TrueFalseBlankT}, {Anchor: _cd.String("\u0031,\u0020\u0031\u0035\u002c\u0020\u0030\u002c\u0020\u0032\u002c\u00202\u002c\u0020\u0035\u0034\u002c\u0020\u0035\u002c\u0020\u0033")}, {AutoFill: _ag.ST_TrueFalseBlankFalse}, {Row: _cd.Int64(row)}, {Column: _cd.Int64(col)}}
	_aab.ShapeChoice = append(_aab.ShapeChoice, &_fb.CT_ShapeChoice{ShapeElementsChoice: &_fb.EG_ShapeElementsChoice{ClientData: _ac}})
	return _aab
}

// FontFamily returns fontFamily of the text.
func (_ace *TextpathStyle) FontFamily() string { return _ace._fc }

// NewTextpathStyle accept value of string style attribute of element v:textpath and format it to generate TextpathStyle.
func NewTextpathStyle(style string) TextpathStyle {
	_ggf := TextpathStyle{_fc: "\u0022C\u0061\u006c\u0069\u0062\u0072\u0069\"", _cec: 44, _ffe: false, _ggd: false}
	_bea := _a.Split(style, "\u003b")
	for _, _acf := range _bea {
		_ecde := _a.Split(_acf, "\u003a")
		if len(_ecde) != 2 {
			continue
		}
		switch _ecde[0] {
		case "f\u006f\u006e\u0074\u002d\u0066\u0061\u006d\u0069\u006c\u0079":
			_ggf._fc = _ecde[1]
			break
		case "\u0066o\u006e\u0074\u002d\u0073\u0069\u007ae":
			_ggf._cec, _ = _cg.ParseInt(_a.ReplaceAll(_ecde[1], "\u0070\u0074", ""), 10, 64)
			break
		case "f\u006f\u006e\u0074\u002d\u0077\u0065\u0069\u0067\u0068\u0074":
			_ggf._ffe = _ecde[1] == "\u0062\u006f\u006c\u0064"
			break
		case "\u0066\u006f\u006e\u0074\u002d\u0073\u0074\u0079\u006c\u0065":
			_ggf._ggd = _ecde[1] == "\u0069\u0074\u0061\u006c\u0069\u0063"
			break
		}
	}
	return _ggf
}

// NewCommentDrawing constructs a new comment drawing.
func NewCommentDrawing() *Container {
	_aa := NewContainer()
	_aa.Layout = _fb.NewOfcShapelayout()
	_aa.Layout.ExtAttr = _fb.ST_ExtEdit
	_aa.Layout.Idmap = _fb.NewOfcCT_IdMap()
	_aa.Layout.Idmap.DataAttr = _cd.String("\u0031")
	_aa.Layout.Idmap.ExtAttr = _fb.ST_ExtEdit
	_aa.ShapeType = _fb.NewShapetype()
	_aa.ShapeType.IdAttr = _cd.String("_\u0078\u0030\u0030\u0030\u0030\u005f\u0074\u0032\u0030\u0032")
	_aa.ShapeType.CoordsizeAttr = _cd.String("2\u0031\u0036\u0030\u0030\u002c\u0032\u0031\u0036\u0030\u0030")
	_aa.ShapeType.SptAttr = _cd.Float32(202)
	_aa.ShapeType.PathAttr = _cd.String("\u006d\u0030\u002c0l\u0030\u002c\u0032\u0031\u0036\u0030\u0030\u002c\u00321\u00360\u0030,\u00321\u0036\u0030\u0030\u002c\u0032\u0031\u0036\u0030\u0030\u002c\u0030\u0078\u0065")
	_g := _fb.NewEG_ShapeElements()
	_aa.ShapeType.EG_ShapeElements = append(_aa.ShapeType.EG_ShapeElements, _g)
	_g.ShapeElementsChoice.Path = _fb.NewPath()
	_g.ShapeElementsChoice.Path.GradientshapeokAttr = _ag.ST_TrueFalseT
	_g.ShapeElementsChoice.Path.ConnecttypeAttr = _fb.OfcST_ConnectTypeRect
	return _aa
}

// Margins get margin top, left, bottom, and right of shape style.
func (_ccf *ShapeStyle) Margins() (float64, float64, float64, float64) {
	return _ccf._ab, _ccf._df, _ccf._eg, _ccf._de
}
func (_fa *Container) MarshalXML(e *_ca.Encoder, start _ca.StartElement) error {
	start.Attr = append(start.Attr, _ca.Attr{Name: _ca.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0076"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002d\u0063\u006f\u006d:v\u006d\u006c"})
	start.Attr = append(start.Attr, _ca.Attr{Name: _ca.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u006f"}, Value: "\u0075\u0072\u006e\u003a\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002d\u006di\u0063\u0072\u006f\u0073\u006f\u0066t\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065\u003a\u006ff\u0066\u0069\u0063\u0065"})
	start.Attr = append(start.Attr, _ca.Attr{Name: _ca.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078"}, Value: "\u0075\u0072\u006e\u003a\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002d\u0063\u006fm\u003a\u006f\u0066\u0066\u0069c\u0065\u003ae\u0078\u0063\u0065\u006c"})
	start.Name.Local = "\u0078\u006d\u006c"
	e.EncodeToken(start)
	if _fa.Layout != nil {
		_af := _ca.StartElement{Name: _ca.Name{Local: "\u006f\u003a\u0073\u0068\u0061\u0070\u0065\u006c\u0061\u0079\u006f\u0075\u0074"}}
		e.EncodeElement(_fa.Layout, _af)
	}
	if _fa.ShapeType != nil {
		_ge := _ca.StartElement{Name: _ca.Name{Local: "v\u003a\u0073\u0068\u0061\u0070\u0065\u0074\u0079\u0070\u0065"}}
		e.EncodeElement(_fa.ShapeType, _ge)
	}
	for _, _gd := range _fa.Shape {
		_faa := _ca.StartElement{Name: _ca.Name{Local: "\u0076:\u0073\u0068\u0061\u0070\u0065"}}
		e.EncodeElement(_gd, _faa)
	}
	return e.EncodeToken(_ca.EndElement{Name: start.Name})
}

// Left get left attribute of shape style.
func (_daf *ShapeStyle) Left() float64 { return _daf._agda }

// SetFontSize sets text's fontSize.
func (_ga *TextpathStyle) SetFontSize(fontSize int64) { _ga._cec = fontSize }

// ShapeStyle is style attribute of v:shape element.
type ShapeStyle struct {
	_dc   string
	_ab   float64
	_df   float64
	_eg   float64
	_de   float64
	_ee   float64
	_agda float64
	_bga  float64
	_ea   float64
	_fba  float64
	_dg   float64
	_dd   int64
	_cc   string
	_be   string
	_eec  string
	_ead  string
}

// ToString formatting ShapeStyle to string.
func (_acc *ShapeStyle) String() string {
	_gg := ""
	_gg += _d.Sprintf("\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u003a\u0025\u0073\u003b", _acc._dc)
	_gg += _d.Sprintf("\u006da\u0072g\u0069\u006e\u002d\u006c\u0065\u0066\u0074\u003a\u0025\u0064\u003b", int64(_acc._df))
	_gg += _d.Sprintf("\u006d\u0061\u0072\u0067\u0069\u006e\u002d\u0074\u006fp\u003a\u0025\u0064\u003b", int64(_acc._ab))
	_gg += _d.Sprintf("w\u0069\u0064\u0074\u0068\u003a\u0025\u0064\u0070\u0074\u003b", int64(_acc._fba))
	_gg += _d.Sprintf("\u0068\u0065\u0069g\u0068\u0074\u003a\u0025\u0064\u0070\u0074\u003b", int64(_acc._dg))
	_gg += _d.Sprintf("z\u002d\u0069\u006e\u0064\u0065\u0078\u003a\u0025\u0064\u003b", _acc._dd)
	_gg += _d.Sprintf("m\u0073\u006f\u002d\u0070\u006f\u0073i\u0074\u0069\u006f\u006e\u002d\u0068\u006f\u0072\u0069z\u006f\u006e\u0074a\u006c:\u0025\u0073\u003b", _acc._cc)
	_gg += _d.Sprintf("\u006d\u0073o-\u0070\u006f\u0073i\u0074\u0069\u006f\u006e-ho\u0072iz\u006f\u006e\u0074\u0061\u006c\u002d\u0072el\u0061\u0074\u0069\u0076\u0065\u003a\u0025s\u003b", _acc._be)
	_gg += _d.Sprintf("\u006ds\u006f\u002d\u0070\u006fs\u0069\u0074\u0069\u006f\u006e-\u0076e\u0072t\u0069\u0063\u0061\u006c\u003a\u0025\u0073;", _acc._eec)
	_gg += _d.Sprintf("\u006d\u0073\u006f-p\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u002d\u0076e\u0072t\u0069c\u0061l\u002d\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065\u003a\u0025\u0073\u003b", _acc._ead)
	return _gg
}

// Top get top attribute of shape style.
func (_eed *ShapeStyle) Top() float64 { return _eed._ee }

// MSOPositionVerticalRelative get `mso-position-vertical-relative` attribute of shape style.
func (_agb *ShapeStyle) MSOPositionVerticalRelative() string { return _agb._ead }

// CreateFormula creates F element for typeFormulas.
func CreateFormula(s string) *_fb.CT_F { _ccb := _fb.NewCT_F(); _ccb.EqnAttr = &s; return _ccb }

const (
	ShapeStylePositionAbsolute = "\u0061\u0062\u0073\u006f\u006c\u0075\u0074\u0065"
	ShapeStylePositionRelative = "\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065"
)

// NewShapeStyle accept value of string style attribute in v:shape and format it to generate ShapeStyle.
func NewShapeStyle(style string) ShapeStyle {
	_eca := ShapeStyle{_fba: 0, _dg: 0}
	_eac := _a.Split(style, "\u003b")
	for _, _fg := range _eac {
		_edc := _a.Split(_fg, "\u003a")
		if len(_edc) != 2 {
			continue
		}
		var _beg error
		switch _edc[0] {
		case "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e":
			_eca._dc = _edc[1]
			break
		case "\u006d\u0061\u0072\u0067\u0069\u006e\u002d\u0074\u006f\u0070":
			_eca._ab, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "m\u0061\u0072\u0067\u0069\u006e\u002d\u006c\u0065\u0066\u0074":
			_eca._df, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u006d\u0061\u0072\u0067\u0069\u006e\u002d\u0062\u006f\u0074\u0074\u006f\u006d":
			_eca._eg, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u006d\u0061\u0072g\u0069\u006e\u002d\u0072\u0069\u0067\u0068\u0074":
			_eca._de, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u0074\u006f\u0070":
			_eca._ee, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u006c\u0065\u0066\u0074":
			_eca._agda, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u0062\u006f\u0074\u0074\u006f\u006d":
			_eca._bga, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u0072\u0069\u0067h\u0074":
			_eca._ea, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u0077\u0069\u0064t\u0068":
			_eca._fba, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u0068\u0065\u0069\u0067\u0068\u0074":
			_eca._dg, _beg = _cg.ParseFloat(_a.ReplaceAll(_edc[1], "\u0070\u0074", ""), 64)
			break
		case "\u007a-\u0069\u006e\u0064\u0065\u0078":
			_eca._dd, _beg = _cg.ParseInt(_edc[1], 10, 64)
			break
		case "\u006d\u0073\u006f-p\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u002d\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c":
			_eca._cc = _edc[1]
			break
		case "\u006d\u0073\u006f\u002d\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u002d\u0068\u006fr\u0069z\u006f\u006e\u0074\u0061\u006c\u002d\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":
			_eca._be = _edc[1]
			break
		case "m\u0073\u006f\u002d\u0070os\u0069t\u0069\u006f\u006e\u002d\u0076e\u0072\u0074\u0069\u0063\u0061\u006c":
			_eca._eec = _edc[1]
			break
		case "\u006d\u0073\u006f\u002d\u0070\u006f\u0073\u0069\u0074\u0069o\u006e\u002d\u0076\u0065\u0072\u0074\u0069c\u0061\u006c\u002d\u0072\u0065\u006c\u0061\u0074\u0069\u0076\u0065":
			_eca._ead = _edc[1]
			break
		}
		if _beg != nil {
			_f.Log.Debug("\u0055n\u0061\u0062l\u0065\u0020\u0074o\u0020\u0070\u0061\u0072\u0073\u0065\u0020s\u0074\u0079\u006c\u0065\u0020\u0061t\u0074\u0072\u0069\u0062\u0075\u0074\u0065\u003a\u0020\u0025\u0073 \u0076\u0061\u006c\u0075\u0065\u003a\u0020\u0025\u0076", _edc[0], _edc[1])
		}
	}
	return _eca
}

// TextpathStyle is style attribute of element v:textpath.
type TextpathStyle struct {
	_fc  string
	_cec int64
	_ffe bool
	_ggd bool
}

// IsBold returns true if text is bold.
func (_edg *TextpathStyle) IsBold() bool { return _edg._ffe }
