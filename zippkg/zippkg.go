//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package zippkg

import (
	_a "archive/zip"
	_d "bytes"
	_e "encoding/xml"
	_ag "fmt"
	_ae "io"
	_gc "path"
	_gb "sort"
	_c "strings"
	_f "time"
	_cc "unioffice"
	_eae "unioffice/common/tempstorage"
	_b "unioffice/internal/sort"
	_ea "unioffice/schema/soo/pkg/relationships"
)

// AddFileFromStorage reads a file from internal storage and adds it at a given path to a zip file.
// NOTE: If disk storage cannot be used, memory storage can be used instead by calling memstore.SetAsStorage().
func AddFileFromStorage(z *_a.Writer, zipPath, storagePath string) error {
	_efa, _dfb := z.Create(zipPath)
	if _dfb != nil {
		return _ag.Errorf("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073", zipPath, _dfb)
	}
	_fac, _dfb := _eae.Open(storagePath)
	if _dfb != nil {
		return _ag.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", storagePath, _dfb)
	}
	defer _fac.Close()
	_, _dfb = _ae.Copy(_efa, _fac)
	return _dfb
}

// RelationsPathFor returns the relations path for a given filename.
func RelationsPathFor(path string) string {
	_ce := _c.Split(path, "\u002f")
	_gd := _c.Join(_ce[0:len(_ce)-1], "\u002f")
	_fea := _ce[len(_ce)-1]
	_gd += "\u002f_\u0072\u0065\u006c\u0073\u002f"
	_fea += "\u002e\u0072\u0065l\u0073"
	return _gd + _fea
}

// ExtractToDiskTmp extracts a zip file to a temporary file in a given path,
// returning the name of the file.
func ExtractToDiskTmp(f *_a.File, path string) (string, error) {
	_de, _feb := _eae.TempFile(path, "\u007a\u007a")
	if _feb != nil {
		return "", _feb
	}
	defer _de.Close()
	_edf, _feb := f.Open()
	if _feb != nil {
		return "", _feb
	}
	defer _edf.Close()
	_, _feb = _ae.Copy(_de, _edf)
	if _feb != nil {
		return "", _feb
	}
	return _de.Name(), nil
}

// AddTarget allows documents to register decode targets. Path is a path that
// will be found in the zip file and ifc is an XML element that the file will be
// unmarshaled to.  filePath is the absolute path to the target, ifc is the
// object to decode into, sourceFileType is the type of file that the reference
// was discovered in, and index is the index of the source file type.
func (_bd *DecodeMap) AddTarget(filePath string, ifc interface{}, sourceFileType string, idx uint32) bool {
	if _bd._eb == nil {
		_bd._eb = make(map[string]Target)
		_bd._dc = make(map[*_ea.Relationships]string)
		_bd._fg = make(map[string]struct{})
		_bd._da = make(map[string]int)
	}
	if _gc.IsAbs(filePath) {
		filePath = _c.TrimPrefix(filePath, "\u002f")
	}
	_df := _gc.Clean(filePath)
	if _, _be := _bd._fg[_df]; _be {
		return false
	}
	_bd._fg[_df] = struct{}{}
	_bd._eb[_df] = Target{Path: _df, Typ: sourceFileType, Ifc: ifc, Index: idx}
	return true
}

const XMLHeader = "\u003c\u003f\u0078\u006d\u006c\u0020\u0076e\u0072\u0073\u0069o\u006e\u003d\u00221\u002e\u0030\"\u0020\u0065\u006e\u0063\u006f\u0064i\u006eg=\u0022\u0055\u0054\u0046\u002d\u0038\u0022\u0020\u0073\u0074\u0061\u006e\u0064\u0061\u006c\u006f\u006e\u0065\u003d\u0022\u0079\u0065\u0073\u0022\u003f\u003e" + "\u000a"

// MarshalXML creates a file inside of a zip and marshals an object as xml, prefixing it
// with a standard XML header.
func MarshalXML(z *_a.Writer, filename string, v interface{}) error {
	_bcd := &_a.FileHeader{}
	_bcd.Method = _a.Deflate
	_bcd.Name = filename
	_bcd.SetModTime(_f.Now())
	_bea, _dce := z.CreateHeader(_bcd)
	if _dce != nil {
		return _ag.Errorf("\u0063\u0072\u0065\u0061ti\u006e\u0067\u0020\u0025\u0073\u0020\u0069\u006e\u0020\u007a\u0069\u0070\u003a\u0020%\u0073", filename, _dce)
	}
	_, _dce = _bea.Write([]byte(XMLHeader))
	if _dce != nil {
		return _ag.Errorf("\u0063\u0072e\u0061\u0074\u0069\u006e\u0067\u0020\u0078\u006d\u006c\u0020\u0068\u0065\u0061\u0064\u0065\u0072\u0020\u0074\u006f\u0020\u0025\u0073: \u0025\u0073", filename, _dce)
	}
	if _dce = _e.NewEncoder(SelfClosingWriter{_bea}).Encode(v); _dce != nil {
		return _ag.Errorf("\u006d\u0061\u0072\u0073\u0068\u0061\u006c\u0069\u006e\u0067\u0020\u0025s\u003a\u0020\u0025\u0073", filename, _dce)
	}
	_, _dce = _bea.Write(_edd)
	return _dce
}
func MarshalXMLByType(z *_a.Writer, dt _cc.DocType, typ string, v interface{}) error {
	_fead := _cc.AbsoluteFilename(dt, typ, 0)
	return MarshalXML(z, _fead, v)
}
func (_af *DecodeMap) RecordIndex(path string, idx int) { _af._da[path] = idx }

// SetOnNewRelationshipFunc sets the function to be called when a new
// relationship has been discovered.
func (_gfg *DecodeMap) SetOnNewRelationshipFunc(fn OnNewRelationshipFunc) { _gfg._ef = fn }

// AddFileFromBytes takes a byte array and adds it at a given path to a zip file.
func AddFileFromBytes(z *_a.Writer, zipPath string, data []byte) error {
	_bba, _bed := z.Create(zipPath)
	if _bed != nil {
		return _ag.Errorf("e\u0072\u0072\u006f\u0072 c\u0072e\u0061\u0074\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073", zipPath, _bed)
	}
	_, _bed = _ae.Copy(_bba, _d.NewReader(data))
	return _bed
}

type Target struct {
	Path  string
	Typ   string
	Ifc   interface{}
	Index uint32
}

// DecodeMap is used to walk a tree of relationships, decoding files and passing
// control back to the document.
type DecodeMap struct {
	_eb map[string]Target
	_dc map[*_ea.Relationships]string
	_gf []Target
	_ef OnNewRelationshipFunc
	_fg map[string]struct{}
	_da map[string]int
}

var _edd = []byte{'\r', '\n'}
var _fad = []byte{'/', '>'}

func (_ceb SelfClosingWriter) Write(b []byte) (int, error) {
	_gfa := 0
	_aeb := 0
	for _gfga := 0; _gfga < len(b)-2; _gfga++ {
		if b[_gfga] == '>' && b[_gfga+1] == '<' && b[_gfga+2] == '/' {
			_edff := []byte{}
			_gaa := _gfga
			for _gccd := _gfga; _gccd >= 0; _gccd-- {
				if b[_gccd] == ' ' {
					_gaa = _gccd
				} else if b[_gccd] == '<' {
					_edff = b[_gccd+1 : _gaa]
					break
				}
			}
			_eda := []byte{}
			for _cga := _gfga + 3; _cga < len(b); _cga++ {
				if b[_cga] == '>' {
					_eda = b[_gfga+3 : _cga]
					break
				}
			}
			if !_d.Equal(_edff, _eda) {
				continue
			}
			_afd, _gga := _ceb.W.Write(b[_gfa:_gfga])
			if _gga != nil {
				return _aeb + _afd, _gga
			}
			_aeb += _afd
			_, _gga = _ceb.W.Write(_fad)
			if _gga != nil {
				return _aeb, _gga
			}
			_aeb += 3
			for _ace := _gfga + 2; _ace < len(b) && b[_ace] != '>'; _ace++ {
				_aeb++
				_gfa = _ace + 2
				_gfga = _gfa
			}
		}
	}
	_ecd, _bfc := _ceb.W.Write(b[_gfa:])
	return _ecd + _aeb, _bfc
}

// SelfClosingWriter wraps a writer and replaces XML tags of the
// type <foo></foo> with <foo/>
type SelfClosingWriter struct{ W _ae.Writer }

// Decode loops decoding targets registered with AddTarget and calling th
func (_dg *DecodeMap) Decode(files []*_a.File) error {
	_gcc := 1
	for _gcc > 0 {
		for len(_dg._gf) > 0 {
			_aef := _dg._gf[0]
			_dg._gf = _dg._gf[1:]
			_ga := _aef.Ifc.(*_ea.Relationships)
			for _, _gea := range _ga.Relationship {
				_fb := _dg._dc[_ga]
				_ec := _c.TrimPrefix(_gea.TargetAttr, "\u002f")
				if _c.HasPrefix(_gea.TargetAttr, "\u002f") {
					_ = _dg._ef(_dg, _ec, _gea.TypeAttr, files, _gea, _aef)
				} else {
					if _c.IndexByte(_fb, '/') > -1 {
						_bc := _fb[:_c.IndexByte(_fb, '/')+1]
						if _c.HasPrefix(_ec, _bc) {
							_fb = ""
						}
					}
					if _c.HasPrefix(_ec, _fb) {
						_fb = ""
					}
					_ = _dg._ef(_dg, _fb+_ec, _gea.TypeAttr, files, _gea, _aef)
				}
			}
		}
		for _fe, _cb := range files {
			if _cb == nil {
				continue
			}
			if _fd, _eeg := _dg._eb[_cb.Name]; _eeg {
				delete(_dg._eb, _cb.Name)
				if _dae := Decode(_cb, _fd.Ifc); _dae != nil {
					return _dae
				}
				files[_fe] = nil
				if _ba, _fa := _fd.Ifc.(*_ea.Relationships); _fa {
					_dg._gf = append(_dg._gf, _fd)
					_ac, _ := _gc.Split(_gc.Clean(_cb.Name + "\u002f\u002e\u002e\u002f"))
					_dg._dc[_ba] = _ac
					_gcc++
				}
			}
		}
		_gcc--
	}
	return nil
}

// Decode unmarshals the content of a *zip.File as XML to a given destination.
func Decode(f *_a.File, dest interface{}) error {
	_bfb, _dda := f.Open()
	if _dda != nil {
		return _ag.Errorf("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", f.Name, _dda)
	}
	defer _bfb.Close()
	_cg := _e.NewDecoder(_bfb)
	if _ebd := _cg.Decode(dest); _ebd != nil {
		return _ag.Errorf("e\u0072\u0072\u006f\u0072 d\u0065c\u006f\u0064\u0069\u006e\u0067 \u0025\u0073\u003a\u0020\u0025\u0073", f.Name, _ebd)
	}
	if _ebe, _aee := dest.(*_ea.Relationships); _aee {
		for _ccd, _gff := range _ebe.Relationship {
			switch _gff.TypeAttr {
			case _cc.OfficeDocumentTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.OfficeDocumentType
			case _cc.StylesTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.StylesType
			case _cc.ThemeTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.ThemeType
			case _cc.ControlTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.ControlType
			case _cc.SettingsTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.SettingsType
			case _cc.ImageTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.ImageType
			case _cc.CommentsTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.CommentsType
			case _cc.ThumbnailTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.ThumbnailType
			case _cc.DrawingTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.DrawingType
			case _cc.ChartTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.ChartType
			case _cc.ExtendedPropertiesTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.ExtendedPropertiesType
			case _cc.CustomXMLTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.CustomXMLType
			case _cc.WorksheetTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.WorksheetType
			case _cc.SharedStringsTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.SharedStringsType
			case _cc.TableTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.TableType
			case _cc.HeaderTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.HeaderType
			case _cc.FooterTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.FooterType
			case _cc.NumberingTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.NumberingType
			case _cc.FontTableTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.FontTableType
			case _cc.WebSettingsTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.WebSettingsType
			case _cc.FootNotesTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.FootNotesType
			case _cc.EndNotesTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.EndNotesType
			case _cc.SlideTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.SlideType
			case _cc.VMLDrawingTypeStrict:
				_ebe.Relationship[_ccd].TypeAttr = _cc.VMLDrawingType
			}
		}
		_gb.Slice(_ebe.Relationship, func(_agg, _aab int) bool {
			_faf := _ebe.Relationship[_agg]
			_bg := _ebe.Relationship[_aab]
			return _b.NaturalCompare(_faf.IdAttr, _bg.IdAttr)
		})
	}
	return nil
}
func (_dcc *DecodeMap) IndexFor(path string) int { return _dcc._da[path] }

// OnNewRelationshipFunc is called when a new relationship has been discovered.
//
// target is a resolved path that takes into account the location of the
// relationships file source and should be the path in the zip file.
//
// files are passed so non-XML files that can't be handled by AddTarget can be
// decoded directly (e.g. images)
//
// rel is the actual relationship so its target can be modified if the source
// target doesn't match where unioffice will write the file (e.g. read in
// 'xl/worksheets/MyWorksheet.xml' and we'll write out
// 'xl/worksheets/sheet1.xml')
type OnNewRelationshipFunc func(_bb *DecodeMap, _ge, _ee string, _fc []*_a.File, _aa *_ea.Relationship, _bbd Target) error

func MarshalXMLByTypeIndex(z *_a.Writer, dt _cc.DocType, typ string, idx int, v interface{}) error {
	_baf := _cc.AbsoluteFilename(dt, typ, idx)
	return MarshalXML(z, _baf, v)
}
