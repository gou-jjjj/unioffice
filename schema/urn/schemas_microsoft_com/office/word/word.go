//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package word

import (
	_d "encoding/xml"
	_b "fmt"
	_a "strconv"
	_f "unioffice"
)

func (_ee *Wrap) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0077\u0072\u0061\u0070"
	return _ee.CT_Wrap.MarshalXML(e, start)
}
func (_cdca ST_WrapSide) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_cdca.String(), start)
}
func (_gad ST_BorderShadow) ValidateWithPath(path string) error {
	switch _gad {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_gad))
	}
	return nil
}
func (_fag *ST_HorizontalAnchor) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_fag = 0
	case "\u006d\u0061\u0072\u0067\u0069\u006e":
		*_fag = 1
	case "\u0070\u0061\u0067\u0065":
		*_fag = 2
	case "\u0074\u0065\u0078\u0074":
		*_fag = 3
	case "\u0063\u0068\u0061\u0072":
		*_fag = 4
	}
	return nil
}

const (
	ST_VerticalAnchorUnset  ST_VerticalAnchor = 0
	ST_VerticalAnchorMargin ST_VerticalAnchor = 1
	ST_VerticalAnchorPage   ST_VerticalAnchor = 2
	ST_VerticalAnchorText   ST_VerticalAnchor = 3
	ST_VerticalAnchorLine   ST_VerticalAnchor = 4
)

func NewWrap() *Wrap                   { _agbc := &Wrap{}; _agbc.CT_Wrap = *NewCT_Wrap(); return _agbc }
func NewCT_AnchorLock() *CT_AnchorLock { _dcb := &CT_AnchorLock{}; return _dcb }
func (_egdf ST_WrapType) String() string {
	switch _egdf {
	case 0:
		return ""
	case 1:
		return "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d"
	case 2:
		return "\u0073\u0071\u0075\u0061\u0072\u0065"
	case 3:
		return "\u006e\u006f\u006e\u0065"
	case 4:
		return "\u0074\u0069\u0067h\u0074"
	case 5:
		return "\u0074h\u0072\u006f\u0075\u0067\u0068"
	}
	return ""
}

// ValidateWithPath validates the Borderright and its children, prefixing error messages with path
func (_bde *Borderright) ValidateWithPath(path string) error {
	if _ac := _bde.CT_Border.ValidateWithPath(path); _ac != nil {
		return _ac
	}
	return nil
}

type CT_Wrap struct {

	// Wrapping type
	TypeAttr ST_WrapType

	// Wrapping side
	SideAttr ST_WrapSide

	// Horizontal Positioning Base
	AnchorxAttr ST_HorizontalAnchor

	// Vertical Positioning Base
	AnchoryAttr ST_VerticalAnchor
}
type Bordertop struct{ CT_Border }
type Borderright struct{ CT_Border }

// ValidateWithPath validates the CT_Wrap and its children, prefixing error messages with path
func (_ebfg *CT_Wrap) ValidateWithPath(path string) error {
	if _ege := _ebfg.TypeAttr.ValidateWithPath(path + "\u002fT\u0079\u0070\u0065\u0041\u0074\u0074r"); _ege != nil {
		return _ege
	}
	if _egc := _ebfg.SideAttr.ValidateWithPath(path + "\u002fS\u0069\u0064\u0065\u0041\u0074\u0074r"); _egc != nil {
		return _egc
	}
	if _dag := _ebfg.AnchorxAttr.ValidateWithPath(path + "\u002f\u0041\u006ec\u0068\u006f\u0072\u0078\u0041\u0074\u0074\u0072"); _dag != nil {
		return _dag
	}
	if _aec := _ebfg.AnchoryAttr.ValidateWithPath(path + "\u002f\u0041\u006ec\u0068\u006f\u0072\u0079\u0041\u0074\u0074\u0072"); _aec != nil {
		return _aec
	}
	return nil
}
func (_bgba *ST_WrapSide) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bcd, _dbe := d.Token()
	if _dbe != nil {
		return _dbe
	}
	if _afda, _bdc := _bcd.(_d.EndElement); _bdc && _afda.Name == start.Name {
		*_bgba = 1
		return nil
	}
	if _dge, _eceb := _bcd.(_d.CharData); !_eceb {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bcd)
	} else {
		switch string(_dge) {
		case "":
			*_bgba = 0
		case "\u0062\u006f\u0074\u0068":
			*_bgba = 1
		case "\u006c\u0065\u0066\u0074":
			*_bgba = 2
		case "\u0072\u0069\u0067h\u0074":
			*_bgba = 3
		case "\u006ca\u0072\u0067\u0065\u0073\u0074":
			*_bgba = 4
		}
	}
	_bcd, _dbe = d.Token()
	if _dbe != nil {
		return _dbe
	}
	if _cfb, _dbb := _bcd.(_d.EndElement); _dbb && _cfb.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bcd)
}
func NewBorderbottom() *Borderbottom {
	_db := &Borderbottom{}
	_db.CT_Border = *NewCT_Border()
	return _db
}
func (_fcbe *ST_BorderType) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_fcbe = 0
	case "\u006e\u006f\u006e\u0065":
		*_fcbe = 1
	case "\u0073\u0069\u006e\u0067\u006c\u0065":
		*_fcbe = 2
	case "\u0074\u0068\u0069c\u006b":
		*_fcbe = 3
	case "\u0064\u006f\u0075\u0062\u006c\u0065":
		*_fcbe = 4
	case "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065":
		*_fcbe = 5
	case "\u0064\u006f\u0074":
		*_fcbe = 6
	case "\u0064\u0061\u0073\u0068":
		*_fcbe = 7
	case "\u0064o\u0074\u0044\u0061\u0073\u0068":
		*_fcbe = 8
	case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074":
		*_fcbe = 9
	case "\u0074\u0072\u0069\u0070\u006c\u0065":
		*_fcbe = 10
	case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c":
		*_fcbe = 11
	case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c":
		*_fcbe = 12
	case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c":
		*_fcbe = 13
	case "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k":
		*_fcbe = 14
	case "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n":
		*_fcbe = 15
	case "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e":
		*_fcbe = 16
	case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065":
		*_fcbe = 17
	case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065":
		*_fcbe = 18
	case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065":
		*_fcbe = 19
	case "\u0077\u0061\u0076\u0065":
		*_fcbe = 20
	case "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065":
		*_fcbe = 21
	case "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c":
		*_fcbe = 22
	case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064":
		*_fcbe = 23
	case "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073":
		*_fcbe = 24
	case "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065":
		*_fcbe = 25
	case "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074":
		*_fcbe = 26
	case "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t":
		*_fcbe = 27
	}
	return nil
}
func NewCT_Border() *CT_Border { _afe := &CT_Border{}; return _afe }

type ST_BorderShadow byte

// ValidateWithPath validates the Borderleft and its children, prefixing error messages with path
func (_ga *Borderleft) ValidateWithPath(path string) error {
	if _fab := _ga.CT_Border.ValidateWithPath(path); _fab != nil {
		return _fab
	}
	return nil
}
func (_afc *ST_VerticalAnchor) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_baeb, _fcbef := d.Token()
	if _fcbef != nil {
		return _fcbef
	}
	if _dece, _bdee := _baeb.(_d.EndElement); _bdee && _dece.Name == start.Name {
		*_afc = 1
		return nil
	}
	if _def, _ceb := _baeb.(_d.CharData); !_ceb {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _baeb)
	} else {
		switch string(_def) {
		case "":
			*_afc = 0
		case "\u006d\u0061\u0072\u0067\u0069\u006e":
			*_afc = 1
		case "\u0070\u0061\u0067\u0065":
			*_afc = 2
		case "\u0074\u0065\u0078\u0074":
			*_afc = 3
		case "\u006c\u0069\u006e\u0065":
			*_afc = 4
		}
	}
	_baeb, _fcbef = d.Token()
	if _fcbef != nil {
		return _fcbef
	}
	if _ggf, _fcf := _baeb.(_d.EndElement); _fcf && _ggf.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _baeb)
}
func (_ad ST_BorderShadow) String() string {
	switch _ad {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0074\u0072\u0075\u0065"
	case 3:
		return "\u0066"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}

type ST_WrapSide byte

func (_faa ST_VerticalAnchor) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_faa.String(), start)
}
func (_ggd ST_VerticalAnchor) String() string {
	switch _ggd {
	case 0:
		return ""
	case 1:
		return "\u006d\u0061\u0072\u0067\u0069\u006e"
	case 2:
		return "\u0070\u0061\u0067\u0065"
	case 3:
		return "\u0074\u0065\u0078\u0074"
	case 4:
		return "\u006c\u0069\u006e\u0065"
	}
	return ""
}

type ST_BorderType byte
type ST_VerticalAnchor byte

func (_gbd ST_BorderShadow) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_gbd.String(), start)
}

// Validate validates the Bordertop and its children
func (_fad *Bordertop) Validate() error {
	return _fad.ValidateWithPath("\u0042o\u0072\u0064\u0065\u0072\u0074\u006fp")
}
func (_bdfe *ST_HorizontalAnchor) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gdef, _cbd := d.Token()
	if _cbd != nil {
		return _cbd
	}
	if _cfbc, _geg := _gdef.(_d.EndElement); _geg && _cfbc.Name == start.Name {
		*_bdfe = 1
		return nil
	}
	if _gcfc, _gbab := _gdef.(_d.CharData); !_gbab {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gdef)
	} else {
		switch string(_gcfc) {
		case "":
			*_bdfe = 0
		case "\u006d\u0061\u0072\u0067\u0069\u006e":
			*_bdfe = 1
		case "\u0070\u0061\u0067\u0065":
			*_bdfe = 2
		case "\u0074\u0065\u0078\u0074":
			*_bdfe = 3
		case "\u0063\u0068\u0061\u0072":
			*_bdfe = 4
		}
	}
	_gdef, _cbd = d.Token()
	if _cbd != nil {
		return _cbd
	}
	if _faed, _eaa := _gdef.(_d.EndElement); _eaa && _faed.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gdef)
}
func (_gcf *CT_AnchorLock) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for {
		_acf, _bc := d.Token()
		if _bc != nil {
			return _b.Errorf("\u0070a\u0072\u0073\u0069\u006eg\u0020\u0043\u0054\u005f\u0041n\u0063h\u006fr\u004c\u006f\u0063\u006b\u003a\u0020\u0025s", _bc)
		}
		if _cad, _fac := _acf.(_d.EndElement); _fac && _cad.Name == start.Name {
			break
		}
	}
	return nil
}
func (_cgc *CT_AnchorLock) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_dbc *Borderleft) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_dbc.CT_Border = *NewCT_Border()
	for _, _fae := range start.Attr {
		if _fae.Name.Local == "\u0074\u0079\u0070\u0065" {
			_dbc.TypeAttr.UnmarshalXMLAttr(_fae)
			continue
		}
		if _fae.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_dgg, _feg := _a.ParseUint(_fae.Value, 10, 32)
			if _feg != nil {
				return _feg
			}
			_bac := uint32(_dgg)
			_dbc.WidthAttr = &_bac
			continue
		}
		if _fae.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_dbc.ShadowAttr.UnmarshalXMLAttr(_fae)
			continue
		}
	}
	for {
		_cb, _agc := d.Token()
		if _agc != nil {
			return _b.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0042\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074\u003a\u0020%\u0073", _agc)
		}
		if _gd, _cg := _cb.(_d.EndElement); _cg && _gd.Name == start.Name {
			break
		}
	}
	return nil
}

const (
	ST_BorderShadowUnset ST_BorderShadow = 0
	ST_BorderShadowT     ST_BorderShadow = 1
	ST_BorderShadowTrue  ST_BorderShadow = 2
	ST_BorderShadowF     ST_BorderShadow = 3
	ST_BorderShadowFalse ST_BorderShadow = 4
)

func (_gcd *ST_BorderShadow) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_gcd = 0
	case "\u0074":
		*_gcd = 1
	case "\u0074\u0072\u0075\u0065":
		*_gcd = 2
	case "\u0066":
		*_gcd = 3
	case "\u0066\u0061\u006cs\u0065":
		*_gcd = 4
	}
	return nil
}
func (_fe *Borderleft) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074"
	return _fe.CT_Border.MarshalXML(e, start)
}

const (
	ST_BorderTypeUnset                 ST_BorderType = 0
	ST_BorderTypeNone                  ST_BorderType = 1
	ST_BorderTypeSingle                ST_BorderType = 2
	ST_BorderTypeThick                 ST_BorderType = 3
	ST_BorderTypeDouble                ST_BorderType = 4
	ST_BorderTypeHairline              ST_BorderType = 5
	ST_BorderTypeDot                   ST_BorderType = 6
	ST_BorderTypeDash                  ST_BorderType = 7
	ST_BorderTypeDotDash               ST_BorderType = 8
	ST_BorderTypeDashDotDot            ST_BorderType = 9
	ST_BorderTypeTriple                ST_BorderType = 10
	ST_BorderTypeThinThickSmall        ST_BorderType = 11
	ST_BorderTypeThickThinSmall        ST_BorderType = 12
	ST_BorderTypeThickBetweenThinSmall ST_BorderType = 13
	ST_BorderTypeThinThick             ST_BorderType = 14
	ST_BorderTypeThickThin             ST_BorderType = 15
	ST_BorderTypeThickBetweenThin      ST_BorderType = 16
	ST_BorderTypeThinThickLarge        ST_BorderType = 17
	ST_BorderTypeThickThinLarge        ST_BorderType = 18
	ST_BorderTypeThickBetweenThinLarge ST_BorderType = 19
	ST_BorderTypeWave                  ST_BorderType = 20
	ST_BorderTypeDoubleWave            ST_BorderType = 21
	ST_BorderTypeDashedSmall           ST_BorderType = 22
	ST_BorderTypeDashDotStroked        ST_BorderType = 23
	ST_BorderTypeThreeDEmboss          ST_BorderType = 24
	ST_BorderTypeThreeDEngrave         ST_BorderType = 25
	ST_BorderTypeHTMLOutset            ST_BorderType = 26
	ST_BorderTypeHTMLInset             ST_BorderType = 27
)

func NewBordertop() *Bordertop {
	_aae := &Bordertop{}
	_aae.CT_Border = *NewCT_Border()
	return _aae
}
func NewCT_Wrap() *CT_Wrap { _fcb := &CT_Wrap{}; return _fcb }
func (_aca *CT_Wrap) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _dde := range start.Attr {
		if _dde.Name.Local == "\u0074\u0079\u0070\u0065" {
			_aca.TypeAttr.UnmarshalXMLAttr(_dde)
			continue
		}
		if _dde.Name.Local == "\u0073\u0069\u0064\u0065" {
			_aca.SideAttr.UnmarshalXMLAttr(_dde)
			continue
		}
		if _dde.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0078" {
			_aca.AnchorxAttr.UnmarshalXMLAttr(_dde)
			continue
		}
		if _dde.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0079" {
			_aca.AnchoryAttr.UnmarshalXMLAttr(_dde)
			continue
		}
	}
	for {
		_deg, _ccf := d.Token()
		if _ccf != nil {
			return _b.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0043\u0054\u005f\u0057\u0072\u0061\u0070\u003a\u0020\u0025\u0073", _ccf)
		}
		if _gcb, _bfe := _deg.(_d.EndElement); _bfe && _gcb.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_AnchorLock and its children, prefixing error messages with path
func (_ae *CT_AnchorLock) ValidateWithPath(path string) error { return nil }
func (_gfg ST_VerticalAnchor) ValidateWithPath(path string) error {
	switch _gfg {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_gfg))
	}
	return nil
}
func (_afd ST_BorderType) ValidateWithPath(path string) error {
	switch _afd {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_afd))
	}
	return nil
}

// Validate validates the Borderleft and its children
func (_abc *Borderleft) Validate() error {
	return _abc.ValidateWithPath("\u0042\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074")
}
func (_egg ST_WrapType) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_egg.String(), start)
}

// Validate validates the CT_Border and its children
func (_aeb *CT_Border) Validate() error {
	return _aeb.ValidateWithPath("\u0043T\u005f\u0042\u006f\u0072\u0064\u0065r")
}
func (_bgb *Wrap) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bgb.CT_Wrap = *NewCT_Wrap()
	for _, _efb := range start.Attr {
		if _efb.Name.Local == "\u0074\u0079\u0070\u0065" {
			_bgb.TypeAttr.UnmarshalXMLAttr(_efb)
			continue
		}
		if _efb.Name.Local == "\u0073\u0069\u0064\u0065" {
			_bgb.SideAttr.UnmarshalXMLAttr(_efb)
			continue
		}
		if _efb.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0078" {
			_bgb.AnchorxAttr.UnmarshalXMLAttr(_efb)
			continue
		}
		if _efb.Name.Local == "\u0061n\u0063\u0068\u006f\u0072\u0079" {
			_bgb.AnchoryAttr.UnmarshalXMLAttr(_efb)
			continue
		}
	}
	for {
		_cadb, _bca := d.Token()
		if _bca != nil {
			return _b.Errorf("\u0070\u0061r\u0073\u0069\u006eg\u0020\u0057\u0072\u0061\u0070\u003a\u0020\u0025\u0073", _bca)
		}
		if _cbe, _cf := _cadb.(_d.EndElement); _cf && _cbe.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the Borderbottom and its children, prefixing error messages with path
func (_ea *Borderbottom) ValidateWithPath(path string) error {
	if _ag := _ea.CT_Border.ValidateWithPath(path); _ag != nil {
		return _ag
	}
	return nil
}

type ST_WrapType byte

func NewAnchorlock() *Anchorlock {
	_ba := &Anchorlock{}
	_ba.CT_AnchorLock = *NewCT_AnchorLock()
	return _ba
}
func (_beb *Bordertop) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062o\u0072\u0064\u0065\u0072\u0074\u006fp"
	return _beb.CT_Border.MarshalXML(e, start)
}
func (_gafe ST_BorderType) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_dcf := _d.Attr{}
	_dcf.Name = name
	switch _gafe {
	case ST_BorderTypeUnset:
		_dcf.Value = ""
	case ST_BorderTypeNone:
		_dcf.Value = "\u006e\u006f\u006e\u0065"
	case ST_BorderTypeSingle:
		_dcf.Value = "\u0073\u0069\u006e\u0067\u006c\u0065"
	case ST_BorderTypeThick:
		_dcf.Value = "\u0074\u0068\u0069c\u006b"
	case ST_BorderTypeDouble:
		_dcf.Value = "\u0064\u006f\u0075\u0062\u006c\u0065"
	case ST_BorderTypeHairline:
		_dcf.Value = "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065"
	case ST_BorderTypeDot:
		_dcf.Value = "\u0064\u006f\u0074"
	case ST_BorderTypeDash:
		_dcf.Value = "\u0064\u0061\u0073\u0068"
	case ST_BorderTypeDotDash:
		_dcf.Value = "\u0064o\u0074\u0044\u0061\u0073\u0068"
	case ST_BorderTypeDashDotDot:
		_dcf.Value = "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074"
	case ST_BorderTypeTriple:
		_dcf.Value = "\u0074\u0072\u0069\u0070\u006c\u0065"
	case ST_BorderTypeThinThickSmall:
		_dcf.Value = "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThickThinSmall:
		_dcf.Value = "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThickBetweenThinSmall:
		_dcf.Value = "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c"
	case ST_BorderTypeThinThick:
		_dcf.Value = "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k"
	case ST_BorderTypeThickThin:
		_dcf.Value = "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n"
	case ST_BorderTypeThickBetweenThin:
		_dcf.Value = "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e"
	case ST_BorderTypeThinThickLarge:
		_dcf.Value = "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065"
	case ST_BorderTypeThickThinLarge:
		_dcf.Value = "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065"
	case ST_BorderTypeThickBetweenThinLarge:
		_dcf.Value = "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065"
	case ST_BorderTypeWave:
		_dcf.Value = "\u0077\u0061\u0076\u0065"
	case ST_BorderTypeDoubleWave:
		_dcf.Value = "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065"
	case ST_BorderTypeDashedSmall:
		_dcf.Value = "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c"
	case ST_BorderTypeDashDotStroked:
		_dcf.Value = "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064"
	case ST_BorderTypeThreeDEmboss:
		_dcf.Value = "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073"
	case ST_BorderTypeThreeDEngrave:
		_dcf.Value = "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065"
	case ST_BorderTypeHTMLOutset:
		_dcf.Value = "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074"
	case ST_BorderTypeHTMLInset:
		_dcf.Value = "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t"
	}
	return _dcf, nil
}

type Wrap struct{ CT_Wrap }

// ValidateWithPath validates the Anchorlock and its children, prefixing error messages with path
func (_be *Anchorlock) ValidateWithPath(path string) error {
	if _df := _be.CT_AnchorLock.ValidateWithPath(path); _df != nil {
		return _df
	}
	return nil
}

// Validate validates the CT_Wrap and its children
func (_bg *CT_Wrap) Validate() error {
	return _bg.ValidateWithPath("\u0043T\u005f\u0057\u0072\u0061\u0070")
}

const (
	ST_WrapSideUnset   ST_WrapSide = 0
	ST_WrapSideBoth    ST_WrapSide = 1
	ST_WrapSideLeft    ST_WrapSide = 2
	ST_WrapSideRight   ST_WrapSide = 3
	ST_WrapSideLargest ST_WrapSide = 4
)

func (_geb ST_WrapSide) String() string {
	switch _geb {
	case 0:
		return ""
	case 1:
		return "\u0062\u006f\u0074\u0068"
	case 2:
		return "\u006c\u0065\u0066\u0074"
	case 3:
		return "\u0072\u0069\u0067h\u0074"
	case 4:
		return "\u006ca\u0072\u0067\u0065\u0073\u0074"
	}
	return ""
}
func (_gae *Borderright) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "b\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074"
	return _gae.CT_Border.MarshalXML(e, start)
}

type Anchorlock struct{ CT_AnchorLock }

func (_afg ST_WrapSide) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_cgf := _d.Attr{}
	_cgf.Name = name
	switch _afg {
	case ST_WrapSideUnset:
		_cgf.Value = ""
	case ST_WrapSideBoth:
		_cgf.Value = "\u0062\u006f\u0074\u0068"
	case ST_WrapSideLeft:
		_cgf.Value = "\u006c\u0065\u0066\u0074"
	case ST_WrapSideRight:
		_cgf.Value = "\u0072\u0069\u0067h\u0074"
	case ST_WrapSideLargest:
		_cgf.Value = "\u006ca\u0072\u0067\u0065\u0073\u0074"
	}
	return _cgf, nil
}

// Validate validates the Wrap and its children
func (_ed *Wrap) Validate() error { return _ed.ValidateWithPath("\u0057\u0072\u0061\u0070") }
func (_dec ST_WrapType) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_ffc := _d.Attr{}
	_ffc.Name = name
	switch _dec {
	case ST_WrapTypeUnset:
		_ffc.Value = ""
	case ST_WrapTypeTopAndBottom:
		_ffc.Value = "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d"
	case ST_WrapTypeSquare:
		_ffc.Value = "\u0073\u0071\u0075\u0061\u0072\u0065"
	case ST_WrapTypeNone:
		_ffc.Value = "\u006e\u006f\u006e\u0065"
	case ST_WrapTypeTight:
		_ffc.Value = "\u0074\u0069\u0067h\u0074"
	case ST_WrapTypeThrough:
		_ffc.Value = "\u0074h\u0072\u006f\u0075\u0067\u0068"
	}
	return _ffc, nil
}
func NewBorderright() *Borderright {
	_aa := &Borderright{}
	_aa.CT_Border = *NewCT_Border()
	return _aa
}

// ValidateWithPath validates the Wrap and its children, prefixing error messages with path
func (_fge *Wrap) ValidateWithPath(path string) error {
	if _cde := _fge.CT_Wrap.ValidateWithPath(path); _cde != nil {
		return _cde
	}
	return nil
}

const (
	ST_HorizontalAnchorUnset  ST_HorizontalAnchor = 0
	ST_HorizontalAnchorMargin ST_HorizontalAnchor = 1
	ST_HorizontalAnchorPage   ST_HorizontalAnchor = 2
	ST_HorizontalAnchorText   ST_HorizontalAnchor = 3
	ST_HorizontalAnchorChar   ST_HorizontalAnchor = 4
)

func (_gde *ST_BorderType) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_aaea, _eae := d.Token()
	if _eae != nil {
		return _eae
	}
	if _gcc, _cdc := _aaea.(_d.EndElement); _cdc && _gcc.Name == start.Name {
		*_gde = 1
		return nil
	}
	if _fbec, _bgg := _aaea.(_d.CharData); !_bgg {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _aaea)
	} else {
		switch string(_fbec) {
		case "":
			*_gde = 0
		case "\u006e\u006f\u006e\u0065":
			*_gde = 1
		case "\u0073\u0069\u006e\u0067\u006c\u0065":
			*_gde = 2
		case "\u0074\u0068\u0069c\u006b":
			*_gde = 3
		case "\u0064\u006f\u0075\u0062\u006c\u0065":
			*_gde = 4
		case "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065":
			*_gde = 5
		case "\u0064\u006f\u0074":
			*_gde = 6
		case "\u0064\u0061\u0073\u0068":
			*_gde = 7
		case "\u0064o\u0074\u0044\u0061\u0073\u0068":
			*_gde = 8
		case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074":
			*_gde = 9
		case "\u0074\u0072\u0069\u0070\u006c\u0065":
			*_gde = 10
		case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c":
			*_gde = 11
		case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c":
			*_gde = 12
		case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c":
			*_gde = 13
		case "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k":
			*_gde = 14
		case "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n":
			*_gde = 15
		case "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e":
			*_gde = 16
		case "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065":
			*_gde = 17
		case "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065":
			*_gde = 18
		case "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065":
			*_gde = 19
		case "\u0077\u0061\u0076\u0065":
			*_gde = 20
		case "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065":
			*_gde = 21
		case "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c":
			*_gde = 22
		case "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064":
			*_gde = 23
		case "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073":
			*_gde = 24
		case "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065":
			*_gde = 25
		case "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074":
			*_gde = 26
		case "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t":
			*_gde = 27
		}
	}
	_aaea, _eae = d.Token()
	if _eae != nil {
		return _eae
	}
	if _bae, _fee := _aaea.(_d.EndElement); _fee && _bae.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _aaea)
}
func (_ef *Bordertop) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ef.CT_Border = *NewCT_Border()
	for _, _gc := range start.Attr {
		if _gc.Name.Local == "\u0074\u0079\u0070\u0065" {
			_ef.TypeAttr.UnmarshalXMLAttr(_gc)
			continue
		}
		if _gc.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_gaf, _de := _a.ParseUint(_gc.Value, 10, 32)
			if _de != nil {
				return _de
			}
			_ca := uint32(_gaf)
			_ef.WidthAttr = &_ca
			continue
		}
		if _gc.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_ef.ShadowAttr.UnmarshalXMLAttr(_gc)
			continue
		}
	}
	for {
		_cee, _cag := d.Token()
		if _cag != nil {
			return _b.Errorf("p\u0061\u0072\u0073\u0069ng\u0020B\u006f\u0072\u0064\u0065\u0072t\u006f\u0070\u003a\u0020\u0025\u0073", _cag)
		}
		if _bdda, _af := _cee.(_d.EndElement); _af && _bdda.Name == start.Name {
			break
		}
	}
	return nil
}
func (_deeb ST_HorizontalAnchor) ValidateWithPath(path string) error {
	switch _deeb {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_deeb))
	}
	return nil
}

// Validate validates the CT_AnchorLock and its children
func (_fbf *CT_AnchorLock) Validate() error {
	return _fbf.ValidateWithPath("\u0043\u0054\u005f\u0041\u006e\u0063\u0068\u006f\u0072\u004c\u006f\u0063\u006b")
}
func NewBorderleft() *Borderleft {
	_dfc := &Borderleft{}
	_dfc.CT_Border = *NewCT_Border()
	return _dfc
}

type Borderbottom struct{ CT_Border }

func (_gdb *ST_WrapType) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bed, _bdf := d.Token()
	if _bdf != nil {
		return _bdf
	}
	if _cba, _eca := _bed.(_d.EndElement); _eca && _cba.Name == start.Name {
		*_gdb = 1
		return nil
	}
	if _aed, _dbd := _bed.(_d.CharData); !_dbd {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bed)
	} else {
		switch string(_aed) {
		case "":
			*_gdb = 0
		case "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d":
			*_gdb = 1
		case "\u0073\u0071\u0075\u0061\u0072\u0065":
			*_gdb = 2
		case "\u006e\u006f\u006e\u0065":
			*_gdb = 3
		case "\u0074\u0069\u0067h\u0074":
			*_gdb = 4
		case "\u0074h\u0072\u006f\u0075\u0067\u0068":
			*_gdb = 5
		}
	}
	_bed, _bdf = d.Token()
	if _bdf != nil {
		return _bdf
	}
	if _eef, _bbc := _bed.(_d.EndElement); _bbc && _eef.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bed)
}
func (_c *Borderbottom) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0062\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d"
	return _c.CT_Border.MarshalXML(e, start)
}

type ST_HorizontalAnchor byte

func (_g *Anchorlock) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064"})
	start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0061\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b"
	return _g.CT_AnchorLock.MarshalXML(e, start)
}
func (_gac ST_BorderType) Validate() error { return _gac.ValidateWithPath("") }
func (_add ST_VerticalAnchor) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_cfe := _d.Attr{}
	_cfe.Name = name
	switch _add {
	case ST_VerticalAnchorUnset:
		_cfe.Value = ""
	case ST_VerticalAnchorMargin:
		_cfe.Value = "\u006d\u0061\u0072\u0067\u0069\u006e"
	case ST_VerticalAnchorPage:
		_cfe.Value = "\u0070\u0061\u0067\u0065"
	case ST_VerticalAnchorText:
		_cfe.Value = "\u0074\u0065\u0078\u0074"
	case ST_VerticalAnchorLine:
		_cfe.Value = "\u006c\u0069\u006e\u0065"
	}
	return _cfe, nil
}
func (_ab *Anchorlock) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_ab.CT_AnchorLock = *NewCT_AnchorLock()
	for {
		_fa, _dg := d.Token()
		if _dg != nil {
			return _b.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0041\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b\u003a\u0020%\u0073", _dg)
		}
		if _bf, _ff := _fa.(_d.EndElement); _ff && _bf.Name == start.Name {
			break
		}
	}
	return nil
}
func (_bdce ST_VerticalAnchor) Validate() error { return _bdce.ValidateWithPath("") }
func (_cda ST_WrapType) Validate() error        { return _cda.ValidateWithPath("") }

const (
	ST_WrapTypeUnset        ST_WrapType = 0
	ST_WrapTypeTopAndBottom ST_WrapType = 1
	ST_WrapTypeSquare       ST_WrapType = 2
	ST_WrapTypeNone         ST_WrapType = 3
	ST_WrapTypeTight        ST_WrapType = 4
	ST_WrapTypeThrough      ST_WrapType = 5
)

// ValidateWithPath validates the CT_Border and its children, prefixing error messages with path
func (_dgb *CT_Border) ValidateWithPath(path string) error {
	if _ffa := _dgb.TypeAttr.ValidateWithPath(path + "\u002fT\u0079\u0070\u0065\u0041\u0074\u0074r"); _ffa != nil {
		return _ffa
	}
	if _cd := _dgb.ShadowAttr.ValidateWithPath(path + "/\u0053\u0068\u0061\u0064\u006f\u0077\u0041\u0074\u0074\u0072"); _cd != nil {
		return _cd
	}
	return nil
}
func (_dea ST_HorizontalAnchor) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_dea.String(), start)
}
func (_bfd *Borderright) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bfd.CT_Border = *NewCT_Border()
	for _, _ddg := range start.Attr {
		if _ddg.Name.Local == "\u0074\u0079\u0070\u0065" {
			_bfd.TypeAttr.UnmarshalXMLAttr(_ddg)
			continue
		}
		if _ddg.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_age, _bdd := _a.ParseUint(_ddg.Value, 10, 32)
			if _bdd != nil {
				return _bdd
			}
			_aga := uint32(_age)
			_bfd.WidthAttr = &_aga
			continue
		}
		if _ddg.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_bfd.ShadowAttr.UnmarshalXMLAttr(_ddg)
			continue
		}
	}
	for {
		_cc, _bfc := d.Token()
		if _bfc != nil {
			return _b.Errorf("\u0070\u0061\u0072si\u006e\u0067\u0020\u0042\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074\u003a\u0020\u0025\u0073", _bfc)
		}
		if _ccc, _eb := _cc.(_d.EndElement); _eb && _ccc.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the Borderright and its children
func (_daa *Borderright) Validate() error {
	return _daa.ValidateWithPath("B\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074")
}
func (_bbg *CT_Border) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	for _, _dbf := range start.Attr {
		if _dbf.Name.Local == "\u0074\u0079\u0070\u0065" {
			_bbg.TypeAttr.UnmarshalXMLAttr(_dbf)
			continue
		}
		if _dbf.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_dbff, _dee := _a.ParseUint(_dbf.Value, 10, 32)
			if _dee != nil {
				return _dee
			}
			_aeg := uint32(_dbff)
			_bbg.WidthAttr = &_aeg
			continue
		}
		if _dbf.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_bbg.ShadowAttr.UnmarshalXMLAttr(_dbf)
			continue
		}
	}
	for {
		_agag, _ffg := d.Token()
		if _ffg != nil {
			return _b.Errorf("p\u0061\u0072\u0073\u0069ng\u0020C\u0054\u005f\u0042\u006f\u0072d\u0065\u0072\u003a\u0020\u0025\u0073", _ffg)
		}
		if _fcdb, _ecf := _agag.(_d.EndElement); _ecf && _fcdb.Name == start.Name {
			break
		}
	}
	return nil
}
func (_gba ST_BorderType) String() string {
	switch _gba {
	case 0:
		return ""
	case 1:
		return "\u006e\u006f\u006e\u0065"
	case 2:
		return "\u0073\u0069\u006e\u0067\u006c\u0065"
	case 3:
		return "\u0074\u0068\u0069c\u006b"
	case 4:
		return "\u0064\u006f\u0075\u0062\u006c\u0065"
	case 5:
		return "\u0068\u0061\u0069\u0072\u006c\u0069\u006e\u0065"
	case 6:
		return "\u0064\u006f\u0074"
	case 7:
		return "\u0064\u0061\u0073\u0068"
	case 8:
		return "\u0064o\u0074\u0044\u0061\u0073\u0068"
	case 9:
		return "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0044\u006f\u0074"
	case 10:
		return "\u0074\u0072\u0069\u0070\u006c\u0065"
	case 11:
		return "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bS\u006d\u0061\u006c\u006c"
	case 12:
		return "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eS\u006d\u0061\u006c\u006c"
	case 13:
		return "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u0053\u006d\u0061\u006c\u006c"
	case 14:
		return "\u0074h\u0069\u006e\u0054\u0068\u0069\u0063k"
	case 15:
		return "\u0074h\u0069\u0063\u006b\u0054\u0068\u0069n"
	case 16:
		return "\u0074\u0068i\u0063\u006b\u0042e\u0074\u0077\u0065\u0065\u006e\u0054\u0068\u0069\u006e"
	case 17:
		return "\u0074\u0068\u0069\u006e\u0054\u0068\u0069\u0063\u006bL\u0061\u0072\u0067\u0065"
	case 18:
		return "\u0074\u0068\u0069\u0063\u006b\u0054\u0068\u0069\u006eL\u0061\u0072\u0067\u0065"
	case 19:
		return "t\u0068\u0069\u0063\u006bBe\u0074w\u0065\u0065\u006e\u0054\u0068i\u006e\u004c\u0061\u0072\u0067\u0065"
	case 20:
		return "\u0077\u0061\u0076\u0065"
	case 21:
		return "\u0064\u006f\u0075\u0062\u006c\u0065\u0057\u0061\u0076\u0065"
	case 22:
		return "d\u0061\u0073\u0068\u0065\u0064\u0053\u006d\u0061\u006c\u006c"
	case 23:
		return "\u0064\u0061\u0073\u0068\u0044\u006f\u0074\u0053\u0074r\u006f\u006b\u0065\u0064"
	case 24:
		return "\u0074\u0068\u0072e\u0065\u0044\u0045\u006d\u0062\u006f\u0073\u0073"
	case 25:
		return "\u0074\u0068\u0072\u0065\u0065\u0044\u0045\u006e\u0067\u0072\u0061\u0076\u0065"
	case 26:
		return "\u0048\u0054\u004d\u004c\u004f\u0075\u0074\u0073\u0065\u0074"
	case 27:
		return "\u0048T\u004d\u004c\u0049\u006e\u0073\u0065t"
	}
	return ""
}
func (_bddb ST_HorizontalAnchor) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_egf := _d.Attr{}
	_egf.Name = name
	switch _bddb {
	case ST_HorizontalAnchorUnset:
		_egf.Value = ""
	case ST_HorizontalAnchorMargin:
		_egf.Value = "\u006d\u0061\u0072\u0067\u0069\u006e"
	case ST_HorizontalAnchorPage:
		_egf.Value = "\u0070\u0061\u0067\u0065"
	case ST_HorizontalAnchorText:
		_egf.Value = "\u0074\u0065\u0078\u0074"
	case ST_HorizontalAnchorChar:
		_egf.Value = "\u0063\u0068\u0061\u0072"
	}
	return _egf, nil
}
func (_gg ST_WrapSide) ValidateWithPath(path string) error {
	switch _gg {
	case 0, 1, 2, 3, 4:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_gg))
	}
	return nil
}
func (_gfa ST_HorizontalAnchor) Validate() error { return _gfa.ValidateWithPath("") }
func (_ace *CT_Wrap) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _ace.TypeAttr != ST_WrapTypeUnset {
		_cgg, _fef := _ace.TypeAttr.MarshalXMLAttr(_d.Name{Local: "\u0074\u0079\u0070\u0065"})
		if _fef != nil {
			return _fef
		}
		start.Attr = append(start.Attr, _cgg)
	}
	if _ace.SideAttr != ST_WrapSideUnset {
		_eag, _aea := _ace.SideAttr.MarshalXMLAttr(_d.Name{Local: "\u0073\u0069\u0064\u0065"})
		if _aea != nil {
			return _aea
		}
		start.Attr = append(start.Attr, _eag)
	}
	if _ace.AnchorxAttr != ST_HorizontalAnchorUnset {
		_bee, _abcf := _ace.AnchorxAttr.MarshalXMLAttr(_d.Name{Local: "\u0061n\u0063\u0068\u006f\u0072\u0078"})
		if _abcf != nil {
			return _abcf
		}
		start.Attr = append(start.Attr, _bee)
	}
	if _ace.AnchoryAttr != ST_VerticalAnchorUnset {
		_ebf, _cge := _ace.AnchoryAttr.MarshalXMLAttr(_d.Name{Local: "\u0061n\u0063\u0068\u006f\u0072\u0079"})
		if _cge != nil {
			return _cge
		}
		start.Attr = append(start.Attr, _ebf)
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}
func (_gcbd ST_WrapSide) Validate() error { return _gcbd.ValidateWithPath("") }
func (_bb *Borderbottom) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_bb.CT_Border = *NewCT_Border()
	for _, _fb := range start.Attr {
		if _fb.Name.Local == "\u0074\u0079\u0070\u0065" {
			_bb.TypeAttr.UnmarshalXMLAttr(_fb)
			continue
		}
		if _fb.Name.Local == "\u0077\u0069\u0064t\u0068" {
			_bd, _da := _a.ParseUint(_fb.Value, 10, 32)
			if _da != nil {
				return _da
			}
			_fc := uint32(_bd)
			_bb.WidthAttr = &_fc
			continue
		}
		if _fb.Name.Local == "\u0073\u0068\u0061\u0064\u006f\u0077" {
			_bb.ShadowAttr.UnmarshalXMLAttr(_fb)
			continue
		}
	}
	for {
		_eg, _dc := d.Token()
		if _dc != nil {
			return _b.Errorf("\u0070a\u0072\u0073\u0069\u006e\u0067\u0020\u0042\u006f\u0072\u0064\u0065r\u0062\u006f\u0074\u0074\u006f\u006d\u003a\u0020\u0025\u0073", _dc)
		}
		if _dd, _fcd := _eg.(_d.EndElement); _fcd && _dd.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the Anchorlock and its children
func (_gb *Anchorlock) Validate() error {
	return _gb.ValidateWithPath("\u0041\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b")
}
func (_cea ST_WrapType) ValidateWithPath(path string) error {
	switch _cea {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _b.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_cea))
	}
	return nil
}
func (_bdfa *ST_VerticalAnchor) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_bdfa = 0
	case "\u006d\u0061\u0072\u0067\u0069\u006e":
		*_bdfa = 1
	case "\u0070\u0061\u0067\u0065":
		*_bdfa = 2
	case "\u0074\u0065\u0078\u0074":
		*_bdfa = 3
	case "\u006c\u0069\u006e\u0065":
		*_bdfa = 4
	}
	return nil
}
func (_dga ST_BorderShadow) MarshalXMLAttr(name _d.Name) (_d.Attr, error) {
	_gded := _d.Attr{}
	_gded.Name = name
	switch _dga {
	case ST_BorderShadowUnset:
		_gded.Value = ""
	case ST_BorderShadowT:
		_gded.Value = "\u0074"
	case ST_BorderShadowTrue:
		_gded.Value = "\u0074\u0072\u0075\u0065"
	case ST_BorderShadowF:
		_gded.Value = "\u0066"
	case ST_BorderShadowFalse:
		_gded.Value = "\u0066\u0061\u006cs\u0065"
	}
	return _gded, nil
}
func (_egd ST_BorderShadow) Validate() error { return _egd.ValidateWithPath("") }
func (_cce *ST_BorderShadow) UnmarshalXML(d *_d.Decoder, start _d.StartElement) error {
	_gea, _ece := d.Token()
	if _ece != nil {
		return _ece
	}
	if _bba, _fed := _gea.(_d.EndElement); _fed && _bba.Name == start.Name {
		*_cce = 1
		return nil
	}
	if _gf, _ddf := _gea.(_d.CharData); !_ddf {
		return _b.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gea)
	} else {
		switch string(_gf) {
		case "":
			*_cce = 0
		case "\u0074":
			*_cce = 1
		case "\u0074\u0072\u0075\u0065":
			*_cce = 2
		case "\u0066":
			*_cce = 3
		case "\u0066\u0061\u006cs\u0065":
			*_cce = 4
		}
	}
	_gea, _ece = d.Token()
	if _ece != nil {
		return _ece
	}
	if _gfb, _faef := _gea.(_d.EndElement); _faef && _gfb.Name == start.Name {
		return nil
	}
	return _b.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gea)
}
func (_eggd ST_HorizontalAnchor) String() string {
	switch _eggd {
	case 0:
		return ""
	case 1:
		return "\u006d\u0061\u0072\u0067\u0069\u006e"
	case 2:
		return "\u0070\u0061\u0067\u0065"
	case 3:
		return "\u0074\u0065\u0078\u0074"
	case 4:
		return "\u0063\u0068\u0061\u0072"
	}
	return ""
}
func (_fcc *ST_WrapSide) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_fcc = 0
	case "\u0062\u006f\u0074\u0068":
		*_fcc = 1
	case "\u006c\u0065\u0066\u0074":
		*_fcc = 2
	case "\u0072\u0069\u0067h\u0074":
		*_fcc = 3
	case "\u006ca\u0072\u0067\u0065\u0073\u0074":
		*_fcc = 4
	}
	return nil
}

type Borderleft struct{ CT_Border }
type CT_AnchorLock struct{}

// Validate validates the Borderbottom and its children
func (_abd *Borderbottom) Validate() error {
	return _abd.ValidateWithPath("\u0042\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d")
}
func (_acee ST_BorderType) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	return e.EncodeElement(_acee.String(), start)
}
func (_ecd *ST_WrapType) UnmarshalXMLAttr(attr _d.Attr) error {
	switch attr.Value {
	case "":
		*_ecd = 0
	case "\u0074\u006f\u0070A\u006e\u0064\u0042\u006f\u0074\u0074\u006f\u006d":
		*_ecd = 1
	case "\u0073\u0071\u0075\u0061\u0072\u0065":
		*_ecd = 2
	case "\u006e\u006f\u006e\u0065":
		*_ecd = 3
	case "\u0074\u0069\u0067h\u0074":
		*_ecd = 4
	case "\u0074h\u0072\u006f\u0075\u0067\u0068":
		*_ecd = 5
	}
	return nil
}
func (_ec *CT_Border) MarshalXML(e *_d.Encoder, start _d.StartElement) error {
	if _ec.TypeAttr != ST_BorderTypeUnset {
		_ge, _cgcd := _ec.TypeAttr.MarshalXMLAttr(_d.Name{Local: "\u0074\u0079\u0070\u0065"})
		if _cgcd != nil {
			return _cgcd
		}
		start.Attr = append(start.Attr, _ge)
	}
	if _ec.WidthAttr != nil {
		start.Attr = append(start.Attr, _d.Attr{Name: _d.Name{Local: "\u0077\u0069\u0064t\u0068"}, Value: _b.Sprintf("\u0025\u0076", *_ec.WidthAttr)})
	}
	if _ec.ShadowAttr != ST_BorderShadowUnset {
		_ecb, _gce := _ec.ShadowAttr.MarshalXMLAttr(_d.Name{Local: "\u0073\u0068\u0061\u0064\u006f\u0077"})
		if _gce != nil {
			return _gce
		}
		start.Attr = append(start.Attr, _ecb)
	}
	e.EncodeToken(start)
	e.EncodeToken(_d.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Bordertop and its children, prefixing error messages with path
func (_agb *Bordertop) ValidateWithPath(path string) error {
	if _dca := _agb.CT_Border.ValidateWithPath(path); _dca != nil {
		return _dca
	}
	return nil
}

type CT_Border struct {

	// Border Style
	TypeAttr ST_BorderType

	// Border Width
	WidthAttr *uint32

	// Border shadow
	ShadowAttr ST_BorderShadow
}

func init() {
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043T\u005f\u0042\u006f\u0072\u0064\u0065r", NewCT_Border)
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043T\u005f\u0057\u0072\u0061\u0070", NewCT_Wrap)
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0043\u0054\u005f\u0041\u006e\u0063\u0068\u006f\u0072\u004c\u006f\u0063\u006b", NewCT_AnchorLock)
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062o\u0072\u0064\u0065\u0072\u0074\u006fp", NewBordertop)
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062\u006f\u0072\u0064\u0065\u0072\u006c\u0065\u0066\u0074", NewBorderleft)
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "b\u006f\u0072\u0064\u0065\u0072\u0072\u0069\u0067\u0068\u0074", NewBorderright)
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0062\u006f\u0072d\u0065\u0072\u0062\u006f\u0074\u0074\u006f\u006d", NewBorderbottom)
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0077\u0072\u0061\u0070", NewWrap)
	_f.RegisterConstructor("\u0075\u0072n\u003a\u0073\u0063\u0068e\u006d\u0061s\u002d\u006d\u0069\u0063\u0072\u006f\u0073\u006ff\u0074\u002d\u0063\u006f\u006d\u003a\u006f\u0066\u0066\u0069\u0063\u0065:\u0077\u006f\u0072\u0064", "\u0061\u006e\u0063\u0068\u006f\u0072\u006c\u006f\u0063\u006b", NewAnchorlock)
}
