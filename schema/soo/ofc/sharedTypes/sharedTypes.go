//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package sharedTypes

import (
	_g "encoding/xml"
	_gf "fmt"
	_gb "regexp"
	_gc "time"
)

const ST_PositivePercentagePattern = "\u005b0\u002d9\u005d\u002b\u0028\u005c\u002e[\u0030\u002d9\u005d\u002b\u0029\u003f\u0025"

func (_aa ST_OnOff) String() string {
	if _aa.Bool != nil {
		return _gf.Sprintf("\u0025\u0076", *_aa.Bool)
	}
	if _aa.ST_OnOff1 != ST_OnOff1Unset {
		return _aa.ST_OnOff1.String()
	}
	return ""
}
func (_dde ST_YAlign) String() string {
	switch _dde {
	case 0:
		return ""
	case 1:
		return "\u0069\u006e\u006c\u0069\u006e\u0065"
	case 2:
		return "\u0074\u006f\u0070"
	case 3:
		return "\u0063\u0065\u006e\u0074\u0065\u0072"
	case 4:
		return "\u0062\u006f\u0074\u0074\u006f\u006d"
	case 5:
		return "\u0069\u006e\u0073\u0069\u0064\u0065"
	case 6:
		return "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return ""
}
func (_afba *ST_AlgType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_afba = 0
	case "\u0074y\u0070\u0065\u0041\u006e\u0079":
		*_afba = 1
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_afba = 2
	}
	return nil
}

type ST_TrueFalse byte
type ST_CryptProv byte

func (_fbf *ST_VerticalAlignRun) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fbf = 0
	case "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":
		*_fbf = 1
	case "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074":
		*_fbf = 2
	case "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t":
		*_fbf = 3
	}
	return nil
}
func (_fcb *ST_OnOff1) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_gdea, _aab := d.Token()
	if _aab != nil {
		return _aab
	}
	if _ebe, _aed := _gdea.(_g.EndElement); _aed && _ebe.Name == start.Name {
		*_fcb = 1
		return nil
	}
	if _gae, _fef := _gdea.(_g.CharData); !_fef {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _gdea)
	} else {
		switch string(_gae) {
		case "":
			*_fcb = 0
		case "\u006f\u006e":
			*_fcb = 1
		case "\u006f\u0066\u0066":
			*_fcb = 2
		}
	}
	_gdea, _aab = d.Token()
	if _aab != nil {
		return _aab
	}
	if _cdf, _fce := _gdea.(_g.EndElement); _fce && _cdf.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _gdea)
}
func (_ff ST_CalendarType) String() string {
	switch _ff {
	case 0:
		return ""
	case 1:
		return "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n"
	case 2:
		return "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073"
	case 3:
		return "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068"
	case 4:
		return "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063"
	case 5:
		return "\u0068\u0069\u006ar\u0069"
	case 6:
		return "\u0068\u0065\u0062\u0072\u0065\u0077"
	case 7:
		return "\u0074\u0061\u0069\u0077\u0061\u006e"
	case 8:
		return "\u006a\u0061\u0070a\u006e"
	case 9:
		return "\u0074\u0068\u0061\u0069"
	case 10:
		return "\u006b\u006f\u0072e\u0061"
	case 11:
		return "\u0073\u0061\u006b\u0061"
	case 12:
		return "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068"
	case 13:
		return "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068"
	case 14:
		return "\u006e\u006f\u006e\u0065"
	}
	return ""
}
func (_ba ST_AlgClass) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ba.String(), start)
}

const ST_UniversalMeasurePattern = "\u002d\u003f\u005b\u0030\u002d\u0039\u005d\u002b\u0028\u005c\u002e\u005b\u0030\u002d\u0039\u005d\u002b\u0029\u003f\u0028\u006d\u006d\u007c\u0063m\u007c\u0069\u006e\u007c\u0070t\u007c\u0070c\u007c\u0070\u0069\u0029"

func (_eeb ST_TrueFalse) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ffa := _g.Attr{}
	_ffa.Name = name
	switch _eeb {
	case ST_TrueFalseUnset:
		_ffa.Value = ""
	case ST_TrueFalseT:
		_ffa.Value = "\u0074"
	case ST_TrueFalseF:
		_ffa.Value = "\u0066"
	case ST_TrueFalseTrue:
		_ffa.Value = "\u0074\u0072\u0075\u0065"
	case ST_TrueFalseFalse:
		_ffa.Value = "\u0066\u0061\u006cs\u0065"
	}
	return _ffa, nil
}

var ST_PositiveFixedPercentagePatternRe = _gb.MustCompile(ST_PositiveFixedPercentagePattern)

func (_fee ST_XAlign) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fee.String(), start)
}
func (_gg ST_CalendarType) ValidateWithPath(path string) error {
	switch _gg {
	case 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_gg))
	}
	return nil
}
func (_gcf *ST_CryptProv) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aeg, _afb := d.Token()
	if _afb != nil {
		return _afb
	}
	if _cgf, _gde := _aeg.(_g.EndElement); _gde && _cgf.Name == start.Name {
		*_gcf = 1
		return nil
	}
	if _bag, _ea := _aeg.(_g.CharData); !_ea {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _aeg)
	} else {
		switch string(_bag) {
		case "":
			*_gcf = 0
		case "\u0072\u0073\u0061\u0041\u0045\u0053":
			*_gcf = 1
		case "\u0072s\u0061\u0046\u0075\u006c\u006c":
			*_gcf = 2
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_gcf = 3
		}
	}
	_aeg, _afb = d.Token()
	if _afb != nil {
		return _afb
	}
	if _be, _cd := _aeg.(_g.EndElement); _cd && _be.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _aeg)
}

type ST_AlgType byte

func (_dc ST_CryptProv) ValidateWithPath(path string) error {
	switch _dc {
	case 0, 1, 2, 3:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dc))
	}
	return nil
}
func (_faa ST_CryptProv) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_eda := _g.Attr{}
	_eda.Name = name
	switch _faa {
	case ST_CryptProvUnset:
		_eda.Value = ""
	case ST_CryptProvRsaAES:
		_eda.Value = "\u0072\u0073\u0061\u0041\u0045\u0053"
	case ST_CryptProvRsaFull:
		_eda.Value = "\u0072s\u0061\u0046\u0075\u006c\u006c"
	case ST_CryptProvCustom:
		_eda.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _eda, nil
}

var ST_GuidPatternRe = _gb.MustCompile(ST_GuidPattern)

func (_bbb ST_TrueFalseBlank) ValidateWithPath(path string) error {
	switch _bbb {
	case 0, 1, 2, 3, 4, 6, 7:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bbb))
	}
	return nil
}
func (_ggd ST_YAlign) Validate() error { return _ggd.ValidateWithPath("") }
func (_agd ST_VerticalAlignRun) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_agd.String(), start)
}
func (_becd ST_ConformanceClass) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_daf := _g.Attr{}
	_daf.Name = name
	switch _becd {
	case ST_ConformanceClassUnset:
		_daf.Value = ""
	case ST_ConformanceClassStrict:
		_daf.Value = "\u0073\u0074\u0072\u0069\u0063\u0074"
	case ST_ConformanceClassTransitional:
		_daf.Value = "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c"
	}
	return _daf, nil
}
func (_dca ST_AlgType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_dca.String(), start)
}
func (_gfff ST_OnOff1) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ag := _g.Attr{}
	_ag.Name = name
	switch _gfff {
	case ST_OnOff1Unset:
		_ag.Value = ""
	case ST_OnOff1On:
		_ag.Value = "\u006f\u006e"
	case ST_OnOff1Off:
		_ag.Value = "\u006f\u0066\u0066"
	}
	return _ag, nil
}
func (_dg *ST_TrueFalse) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ddfg, _ddb := d.Token()
	if _ddb != nil {
		return _ddb
	}
	if _cfd, _bfc := _ddfg.(_g.EndElement); _bfc && _cfd.Name == start.Name {
		*_dg = 1
		return nil
	}
	if _ebf, _aba := _ddfg.(_g.CharData); !_aba {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _ddfg)
	} else {
		switch string(_ebf) {
		case "":
			*_dg = 0
		case "\u0074":
			*_dg = 1
		case "\u0066":
			*_dg = 2
		case "\u0074\u0072\u0075\u0065":
			*_dg = 3
		case "\u0066\u0061\u006cs\u0065":
			*_dg = 4
		}
	}
	_ddfg, _ddb = d.Token()
	if _ddb != nil {
		return _ddb
	}
	if _ddd, _fgc := _ddfg.(_g.EndElement); _fgc && _ddd.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _ddfg)
}
func (_fa ST_AlgClass) Validate() error { return _fa.ValidateWithPath("") }
func (_ddf *ST_CalendarType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_ae, _gfd := d.Token()
	if _gfd != nil {
		return _gfd
	}
	if _eg, _ab := _ae.(_g.EndElement); _ab && _eg.Name == start.Name {
		*_ddf = 1
		return nil
	}
	if _fc, _df := _ae.(_g.CharData); !_df {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _ae)
	} else {
		switch string(_fc) {
		case "":
			*_ddf = 0
		case "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n":
			*_ddf = 1
		case "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073":
			*_ddf = 2
		case "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068":
			*_ddf = 3
		case "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063":
			*_ddf = 4
		case "\u0068\u0069\u006ar\u0069":
			*_ddf = 5
		case "\u0068\u0065\u0062\u0072\u0065\u0077":
			*_ddf = 6
		case "\u0074\u0061\u0069\u0077\u0061\u006e":
			*_ddf = 7
		case "\u006a\u0061\u0070a\u006e":
			*_ddf = 8
		case "\u0074\u0068\u0061\u0069":
			*_ddf = 9
		case "\u006b\u006f\u0072e\u0061":
			*_ddf = 10
		case "\u0073\u0061\u006b\u0061":
			*_ddf = 11
		case "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068":
			*_ddf = 12
		case "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068":
			*_ddf = 13
		case "\u006e\u006f\u006e\u0065":
			*_ddf = 14
		}
	}
	_ae, _gfd = d.Token()
	if _gfd != nil {
		return _gfd
	}
	if _gdf, _fgd := _ae.(_g.EndElement); _fgd && _gdf.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _ae)
}
func (_bca ST_OnOff1) ValidateWithPath(path string) error {
	switch _bca {
	case 0, 1, 2:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_bca))
	}
	return nil
}
func (_def ST_YAlign) ValidateWithPath(path string) error {
	switch _def {
	case 0, 1, 2, 3, 4, 5, 6:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_def))
	}
	return nil
}
func (_b *ST_TwipsMeasure) Validate() error { return _b.ValidateWithPath("") }

const (
	ST_TrueFalseBlankUnset  ST_TrueFalseBlank = 0
	ST_TrueFalseBlankT      ST_TrueFalseBlank = 1
	ST_TrueFalseBlankF      ST_TrueFalseBlank = 2
	ST_TrueFalseBlankTrue   ST_TrueFalseBlank = 3
	ST_TrueFalseBlankFalse  ST_TrueFalseBlank = 4
	ST_TrueFalseBlankTrue_  ST_TrueFalseBlank = 6
	ST_TrueFalseBlankFalse_ ST_TrueFalseBlank = 7
)

func (_baa ST_TrueFalse) ValidateWithPath(path string) error {
	switch _baa {
	case 0, 1, 2, 3, 4:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_baa))
	}
	return nil
}

const (
	ST_TrueFalseUnset ST_TrueFalse = 0
	ST_TrueFalseT     ST_TrueFalse = 1
	ST_TrueFalseF     ST_TrueFalse = 2
	ST_TrueFalseTrue  ST_TrueFalse = 3
	ST_TrueFalseFalse ST_TrueFalse = 4
)

func ParseUnionST_OnOff(s string) (ST_OnOff, error) {
	_ga := ST_OnOff{}
	switch s {
	case "\u0074\u0072\u0075\u0065", "\u0031", "\u006f\u006e":
		_f := true
		_ga.Bool = &_f
	default:
		_bc := false
		_ga.Bool = &_bc
	}
	return _ga, nil
}
func (_cef *ST_XAlign) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cef = 0
	case "\u006c\u0065\u0066\u0074":
		*_cef = 1
	case "\u0063\u0065\u006e\u0074\u0065\u0072":
		*_cef = 2
	case "\u0072\u0069\u0067h\u0074":
		*_cef = 3
	case "\u0069\u006e\u0073\u0069\u0064\u0065":
		*_cef = 4
	case "\u006fu\u0074\u0073\u0069\u0064\u0065":
		*_cef = 5
	}
	return nil
}
func FormatDate(t _gc.Time) string { return t.Format(_fg) }
func (_afbb *ST_XAlign) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dgg, _gee := d.Token()
	if _gee != nil {
		return _gee
	}
	if _bee, _dgca := _dgg.(_g.EndElement); _dgca && _bee.Name == start.Name {
		*_afbb = 1
		return nil
	}
	if _dggf, _cefc := _dgg.(_g.CharData); !_cefc {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _dgg)
	} else {
		switch string(_dggf) {
		case "":
			*_afbb = 0
		case "\u006c\u0065\u0066\u0074":
			*_afbb = 1
		case "\u0063\u0065\u006e\u0074\u0065\u0072":
			*_afbb = 2
		case "\u0072\u0069\u0067h\u0074":
			*_afbb = 3
		case "\u0069\u006e\u0073\u0069\u0064\u0065":
			*_afbb = 4
		case "\u006fu\u0074\u0073\u0069\u0064\u0065":
			*_afbb = 5
		}
	}
	_dgg, _gee = d.Token()
	if _gee != nil {
		return _gee
	}
	if _gfa, _cefa := _dgg.(_g.EndElement); _cefa && _gfa.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _dgg)
}
func (_cf *ST_AlgClass) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_cf = 0
	case "\u0068\u0061\u0073\u0068":
		*_cf = 1
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_cf = 2
	}
	return nil
}
func (_gedb *ST_YAlign) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_gedb = 0
	case "\u0069\u006e\u006c\u0069\u006e\u0065":
		*_gedb = 1
	case "\u0074\u006f\u0070":
		*_gedb = 2
	case "\u0063\u0065\u006e\u0074\u0065\u0072":
		*_gedb = 3
	case "\u0062\u006f\u0074\u0074\u006f\u006d":
		*_gedb = 4
	case "\u0069\u006e\u0073\u0069\u0064\u0065":
		*_gedb = 5
	case "\u006fu\u0074\u0073\u0069\u0064\u0065":
		*_gedb = 6
	}
	return nil
}
func (_egb ST_CryptProv) String() string {
	switch _egb {
	case 0:
		return ""
	case 1:
		return "\u0072\u0073\u0061\u0041\u0045\u0053"
	case 2:
		return "\u0072s\u0061\u0046\u0075\u006c\u006c"
	case 3:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}
func (_ccd ST_OnOff1) Validate() error { return _ccd.ValidateWithPath("") }
func (_fd ST_OnOff1) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_fd.String(), start)
}
func (_af *ST_AlgClass) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_fbef, _db := d.Token()
	if _db != nil {
		return _db
	}
	if _bbe, _dbg := _fbef.(_g.EndElement); _dbg && _bbe.Name == start.Name {
		*_af = 1
		return nil
	}
	if _dab, _ce := _fbef.(_g.CharData); !_ce {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _fbef)
	} else {
		switch string(_dab) {
		case "":
			*_af = 0
		case "\u0068\u0061\u0073\u0068":
			*_af = 1
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_af = 2
		}
	}
	_fbef, _db = d.Token()
	if _db != nil {
		return _db
	}
	if _ffd, _ged := _fbef.(_g.EndElement); _ged && _ffd.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _fbef)
}

const ST_FixedPercentagePattern = "-\u003f\u0028\u0028\u0031\u0030\u0030\u0029\u007c\u0028\u005b\u0030\u002d\u0039\u005d\u005b\u0030\u002d\u0039]\u003f\u0029\u0029\u0028\u005c\u002e\u005b\u0030\u002d\u0039][\u0030\u002d\u0039]\u003f)\u003f\u0025"
const (
	ST_AlgClassUnset  ST_AlgClass = 0
	ST_AlgClassHash   ST_AlgClass = 1
	ST_AlgClassCustom ST_AlgClass = 2
)

func (_bf ST_CalendarType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dd := _g.Attr{}
	_dd.Name = name
	switch _bf {
	case ST_CalendarTypeUnset:
		_dd.Value = ""
	case ST_CalendarTypeGregorian:
		_dd.Value = "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n"
	case ST_CalendarTypeGregorianUs:
		_dd.Value = "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073"
	case ST_CalendarTypeGregorianMeFrench:
		_dd.Value = "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068"
	case ST_CalendarTypeGregorianArabic:
		_dd.Value = "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063"
	case ST_CalendarTypeHijri:
		_dd.Value = "\u0068\u0069\u006ar\u0069"
	case ST_CalendarTypeHebrew:
		_dd.Value = "\u0068\u0065\u0062\u0072\u0065\u0077"
	case ST_CalendarTypeTaiwan:
		_dd.Value = "\u0074\u0061\u0069\u0077\u0061\u006e"
	case ST_CalendarTypeJapan:
		_dd.Value = "\u006a\u0061\u0070a\u006e"
	case ST_CalendarTypeThai:
		_dd.Value = "\u0074\u0068\u0061\u0069"
	case ST_CalendarTypeKorea:
		_dd.Value = "\u006b\u006f\u0072e\u0061"
	case ST_CalendarTypeSaka:
		_dd.Value = "\u0073\u0061\u006b\u0061"
	case ST_CalendarTypeGregorianXlitEnglish:
		_dd.Value = "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068"
	case ST_CalendarTypeGregorianXlitFrench:
		_dd.Value = "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068"
	case ST_CalendarTypeNone:
		_dd.Value = "\u006e\u006f\u006e\u0065"
	}
	return _dd, nil
}
func (_gef ST_TwipsMeasure) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _gef.ST_UnsignedDecimalNumber != nil {
		e.EncodeToken(_g.CharData(_gf.Sprintf("\u0025\u0064", *_gef.ST_UnsignedDecimalNumber)))
	}
	if _gef.ST_PositiveUniversalMeasure != nil {
		e.EncodeToken(_g.CharData(*_gef.ST_PositiveUniversalMeasure))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}

var ST_PercentagePatternRe = _gb.MustCompile(ST_PercentagePattern)

func (_ded ST_AlgType) ValidateWithPath(path string) error {
	switch _ded {
	case 0, 1, 2:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ded))
	}
	return nil
}
func (_dfc *ST_CryptProv) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dfc = 0
	case "\u0072\u0073\u0061\u0041\u0045\u0053":
		*_dfc = 1
	case "\u0072s\u0061\u0046\u0075\u006c\u006c":
		*_dfc = 2
	case "\u0063\u0075\u0073\u0074\u006f\u006d":
		*_dfc = 3
	}
	return nil
}
func (_gfb ST_TrueFalseBlank) Validate() error { return _gfb.ValidateWithPath("") }
func (_fde *ST_TrueFalseBlank) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fde = 0
	case "\u0074":
		*_fde = 1
	case "\u0066":
		*_fde = 2
	case "\u0074\u0072\u0075\u0065":
		*_fde = 3
	case "\u0066\u0061\u006cs\u0065":
		*_fde = 4
	case "\u0054\u0072\u0075\u0065":
		*_fde = 6
	case "\u0046\u0061\u006cs\u0065":
		*_fde = 7
	}
	return nil
}
func (_e *ST_OnOff) Validate() error { return _e.ValidateWithPath("") }

type ST_XAlign byte

func (_dda ST_AlgClass) ValidateWithPath(path string) error {
	switch _dda {
	case 0, 1, 2:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dda))
	}
	return nil
}
func (_dbc *ST_TrueFalse) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_dbc = 0
	case "\u0074":
		*_dbc = 1
	case "\u0066":
		*_dbc = 2
	case "\u0074\u0072\u0075\u0065":
		*_dbc = 3
	case "\u0066\u0061\u006cs\u0065":
		*_dbc = 4
	}
	return nil
}
func (_dbe ST_XAlign) ValidateWithPath(path string) error {
	switch _dbe {
	case 0, 1, 2, 3, 4, 5:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_dbe))
	}
	return nil
}

type ST_OnOff1 byte
type ST_CalendarType byte

const (
	ST_OnOff1Unset ST_OnOff1 = 0
	ST_OnOff1On    ST_OnOff1 = 1
	ST_OnOff1Off   ST_OnOff1 = 2
)

func (_fge ST_VerticalAlignRun) Validate() error { return _fge.ValidateWithPath("") }
func (_gac ST_VerticalAlignRun) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_aec := _g.Attr{}
	_aec.Name = name
	switch _gac {
	case ST_VerticalAlignRunUnset:
		_aec.Value = ""
	case ST_VerticalAlignRunBaseline:
		_aec.Value = "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065"
	case ST_VerticalAlignRunSuperscript:
		_aec.Value = "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074"
	case ST_VerticalAlignRunSubscript:
		_aec.Value = "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t"
	}
	return _aec, nil
}
func (_cgg *ST_VerticalAlignRun) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_aaed, _bfe := d.Token()
	if _bfe != nil {
		return _bfe
	}
	if _edac, _cgc := _aaed.(_g.EndElement); _cgc && _edac.Name == start.Name {
		*_cgg = 1
		return nil
	}
	if _bfa, _aea := _aaed.(_g.CharData); !_aea {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _aaed)
	} else {
		switch string(_bfa) {
		case "":
			*_cgg = 0
		case "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065":
			*_cgg = 1
		case "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074":
			*_cgg = 2
		case "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t":
			*_cgg = 3
		}
	}
	_aaed, _bfe = d.Token()
	if _bfe != nil {
		return _bfe
	}
	if _ead, _bd := _aaed.(_g.EndElement); _bd && _ead.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _aaed)
}
func FormatDateTime(t _gc.Time) string { return t.Format(_fb) }

const (
	ST_AlgTypeUnset   ST_AlgType = 0
	ST_AlgTypeTypeAny ST_AlgType = 1
	ST_AlgTypeCustom  ST_AlgType = 2
)
const (
	ST_CryptProvUnset   ST_CryptProv = 0
	ST_CryptProvRsaAES  ST_CryptProv = 1
	ST_CryptProvRsaFull ST_CryptProv = 2
	ST_CryptProvCustom  ST_CryptProv = 3
)

func (_fed *ST_ConformanceClass) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fed = 0
	case "\u0073\u0074\u0072\u0069\u0063\u0074":
		*_fed = 1
	case "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c":
		*_fed = 2
	}
	return nil
}
func (_aff ST_TrueFalseBlank) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_aff.String(), start)
}

type ST_TrueFalseBlank byte

// ST_TwipsMeasure is a union type
type ST_TwipsMeasure struct {
	ST_UnsignedDecimalNumber    *uint64
	ST_PositiveUniversalMeasure *string
}

const (
	ST_ConformanceClassUnset        ST_ConformanceClass = 0
	ST_ConformanceClassStrict       ST_ConformanceClass = 1
	ST_ConformanceClassTransitional ST_ConformanceClass = 2
)

func (_a ST_OnOff) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	e.EncodeToken(start)
	if _a.Bool != nil {
		e.EncodeToken(_g.CharData(_gf.Sprintf("\u0025\u0064", _d(*_a.Bool))))
	}
	if _a.ST_OnOff1 != ST_OnOff1Unset {
		e.EncodeToken(_g.CharData(_a.ST_OnOff1.String()))
	}
	return e.EncodeToken(_g.EndElement{Name: start.Name})
}
func (_cfbd ST_TrueFalseBlank) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_ced := _g.Attr{}
	_ced.Name = name
	switch _cfbd {
	case ST_TrueFalseBlankUnset:
		_ced.Value = ""
	case ST_TrueFalseBlankT:
		_ced.Value = "\u0074"
	case ST_TrueFalseBlankF:
		_ced.Value = "\u0066"
	case ST_TrueFalseBlankTrue:
		_ced.Value = "\u0074\u0072\u0075\u0065"
	case ST_TrueFalseBlankFalse:
		_ced.Value = "\u0066\u0061\u006cs\u0065"
	case ST_TrueFalseBlankTrue_:
		_ced.Value = "\u0054\u0072\u0075\u0065"
	case ST_TrueFalseBlankFalse_:
		_ced.Value = "\u0046\u0061\u006cs\u0065"
	}
	return _ced, nil
}
func (_fcf ST_XAlign) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_fgf := _g.Attr{}
	_fgf.Name = name
	switch _fcf {
	case ST_XAlignUnset:
		_fgf.Value = ""
	case ST_XAlignLeft:
		_fgf.Value = "\u006c\u0065\u0066\u0074"
	case ST_XAlignCenter:
		_fgf.Value = "\u0063\u0065\u006e\u0074\u0065\u0072"
	case ST_XAlignRight:
		_fgf.Value = "\u0072\u0069\u0067h\u0074"
	case ST_XAlignInside:
		_fgf.Value = "\u0069\u006e\u0073\u0069\u0064\u0065"
	case ST_XAlignOutside:
		_fgf.Value = "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return _fgf, nil
}
func (_geff ST_TrueFalseBlank) String() string {
	switch _geff {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0066"
	case 3:
		return "\u0074\u0072\u0075\u0065"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	case 6:
		return "\u0054\u0072\u0075\u0065"
	case 7:
		return "\u0046\u0061\u006cs\u0065"
	}
	return ""
}

const (
	ST_VerticalAlignRunUnset       ST_VerticalAlignRun = 0
	ST_VerticalAlignRunBaseline    ST_VerticalAlignRun = 1
	ST_VerticalAlignRunSuperscript ST_VerticalAlignRun = 2
	ST_VerticalAlignRunSubscript   ST_VerticalAlignRun = 3
)

func (_eab ST_TrueFalse) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_eab.String(), start)
}
func (_cba ST_TrueFalse) Validate() error { return _cba.ValidateWithPath("") }
func FormatTime(t _gc.Time) string        { return t.Format(_gd) }

const (
	ST_XAlignUnset   ST_XAlign = 0
	ST_XAlignLeft    ST_XAlign = 1
	ST_XAlignCenter  ST_XAlign = 2
	ST_XAlignRight   ST_XAlign = 3
	ST_XAlignInside  ST_XAlign = 4
	ST_XAlignOutside ST_XAlign = 5
)

func (_eba *ST_ConformanceClass) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dge, _eebe := d.Token()
	if _eebe != nil {
		return _eebe
	}
	if _cdb, _cbd := _dge.(_g.EndElement); _cbd && _cdb.Name == start.Name {
		*_eba = 1
		return nil
	}
	if _faf, _bfb := _dge.(_g.CharData); !_bfb {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _dge)
	} else {
		switch string(_faf) {
		case "":
			*_eba = 0
		case "\u0073\u0074\u0072\u0069\u0063\u0074":
			*_eba = 1
		case "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c":
			*_eba = 2
		}
	}
	_dge, _eebe = d.Token()
	if _eebe != nil {
		return _eebe
	}
	if _dcae, _fae := _dge.(_g.EndElement); _fae && _dcae.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _dge)
}
func (_egc ST_VerticalAlignRun) ValidateWithPath(path string) error {
	switch _egc {
	case 0, 1, 2, 3:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_egc))
	}
	return nil
}

const ST_PositiveFixedPercentagePattern = "\u0028\u0028\u0031\u0030\u0030\u0029\u007c\u0028\u005b\u0030\u002d\u0039\u005d\u005b\u0030\u002d\u0039\u005d\u003f\u0029\u0029\u0028\u005c\u002e[\u0030\u002d\u0039\u005d\u005b0\u002d\u0039]\u003f\u0029\u003f\u0025"

type ST_ConformanceClass byte

func (_bea ST_XAlign) Validate() error { return _bea.ValidateWithPath("") }
func (_bbd ST_CryptProv) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_bbd.String(), start)
}
func (_gcc ST_AlgType) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_cea := _g.Attr{}
	_cea.Name = name
	switch _gcc {
	case ST_AlgTypeUnset:
		_cea.Value = ""
	case ST_AlgTypeTypeAny:
		_cea.Value = "\u0074y\u0070\u0065\u0041\u006e\u0079"
	case ST_AlgTypeCustom:
		_cea.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _cea, nil
}

const ST_PositiveUniversalMeasurePattern = "\u005b\u0030-9\u005d\u002b\u0028\\\u002e\u005b\u0030\u002d9]+\u0029?(\u006d\u006d\u007c\u0063\u006d\u007c\u0069n|\u0070\u0074\u007c\u0070\u0063\u007c\u0070i\u0029"
const ST_PercentagePattern = "-\u003f[\u0030\u002d\u0039\u005d\u002b\u0028\u005c\u002e[\u0030\u002d\u0039\u005d+)\u003f\u0025"

func (_aae ST_TwipsMeasure) String() string {
	if _aae.ST_UnsignedDecimalNumber != nil {
		return _gf.Sprintf("\u0025\u0076", *_aae.ST_UnsignedDecimalNumber)
	}
	if _aae.ST_PositiveUniversalMeasure != nil {
		return _gf.Sprintf("\u0025\u0076", *_aae.ST_PositiveUniversalMeasure)
	}
	return ""
}
func (_cfb ST_TrueFalse) String() string {
	switch _cfb {
	case 0:
		return ""
	case 1:
		return "\u0074"
	case 2:
		return "\u0066"
	case 3:
		return "\u0074\u0072\u0075\u0065"
	case 4:
		return "\u0066\u0061\u006cs\u0065"
	}
	return ""
}
func (_abc ST_AlgType) String() string {
	switch _abc {
	case 0:
		return ""
	case 1:
		return "\u0074y\u0070\u0065\u0041\u006e\u0079"
	case 2:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}

const (
	_fg = "2\u0030\u0030\u0036\u002d\u004a\u0061\u006e\u002d\u0030\u0032"
	_gd = "\u0031\u0035\u003a\u0030\u0034\u003a\u0030\u0035"
	_fb = "\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300"
)
const (
	ST_YAlignUnset   ST_YAlign = 0
	ST_YAlignInline  ST_YAlign = 1
	ST_YAlignTop     ST_YAlign = 2
	ST_YAlignCenter  ST_YAlign = 3
	ST_YAlignBottom  ST_YAlign = 4
	ST_YAlignInside  ST_YAlign = 5
	ST_YAlignOutside ST_YAlign = 6
)

var ST_PositivePercentagePatternRe = _gb.MustCompile(ST_PositivePercentagePattern)

func (_gbe ST_ConformanceClass) String() string {
	switch _gbe {
	case 0:
		return ""
	case 1:
		return "\u0073\u0074\u0072\u0069\u0063\u0074"
	case 2:
		return "\u0074\u0072\u0061n\u0073\u0069\u0074\u0069\u006f\u006e\u0061\u006c"
	}
	return ""
}

const ST_GuidPattern = "\u005c\u007b\u005b\u0030\u002d\u0039\u0041\u002d\u0046\u005d\u007b\u0038\u007d\u002d\u005b\u0030\u002d9\u0041\u002d\u0046\u005d\u007b\u0034\u007d\u002d\u005b\u0030-\u0039\u0041\u002d\u0046\u005d\u007b\u0034\u007d\u002d\u005b\u0030\u002d\u0039\u0041\u002d\u0046\u005d\u007b4\u007d\u002d\u005b\u0030\u002d\u0039A\u002d\u0046]\u007b\u00312\u007d\\\u007d"

func (_eed *ST_YAlign) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dga, _fgcd := d.Token()
	if _fgcd != nil {
		return _fgcd
	}
	if _fgee, _cfc := _dga.(_g.EndElement); _cfc && _fgee.Name == start.Name {
		*_eed = 1
		return nil
	}
	if _bafbg, _abf := _dga.(_g.CharData); !_abf {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _dga)
	} else {
		switch string(_bafbg) {
		case "":
			*_eed = 0
		case "\u0069\u006e\u006c\u0069\u006e\u0065":
			*_eed = 1
		case "\u0074\u006f\u0070":
			*_eed = 2
		case "\u0063\u0065\u006e\u0074\u0065\u0072":
			*_eed = 3
		case "\u0062\u006f\u0074\u0074\u006f\u006d":
			*_eed = 4
		case "\u0069\u006e\u0073\u0069\u0064\u0065":
			*_eed = 5
		case "\u006fu\u0074\u0073\u0069\u0064\u0065":
			*_eed = 6
		}
	}
	_dga, _fgcd = d.Token()
	if _fgcd != nil {
		return _fgcd
	}
	if _cae, _age := _dga.(_g.EndElement); _age && _cae.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _dga)
}
func ParseStdlibTime(s string) (_gc.Time, error) {
	var _cc _gc.Time
	if _bb, _fe := _gc.Parse(_fg, s); _fe == nil {
		return _bb, nil
	}
	if _ed, _da := _gc.Parse(_gd, s); _da == nil {
		return _ed, nil
	}
	if _ac, _cb := _gc.Parse(_fb, s); _cb == nil {
		return _ac, nil
	}
	return _cc, _gf.Errorf("\u0070\u0061\u0072si\u006e\u0067\u0020\u0025\u0073\u0020\u0061\u0073\u0020\u0064\u0061\u0074\u0065\u002f\u0074\u0069\u006d\u0065", s)
}
func (_ddeb ST_ConformanceClass) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_ddeb.String(), start)
}
func (_gga ST_OnOff1) String() string {
	switch _gga {
	case 0:
		return ""
	case 1:
		return "\u006f\u006e"
	case 2:
		return "\u006f\u0066\u0066"
	}
	return ""
}

var ST_PositiveUniversalMeasurePatternRe = _gb.MustCompile(ST_PositiveUniversalMeasurePattern)

func (_ge *ST_OnOff) ValidateWithPath(path string) error {
	_ee := []string{}
	if _ge.Bool != nil {
		_ee = append(_ee, "\u0042\u006f\u006f\u006c")
	}
	if _ge.ST_OnOff1 != ST_OnOff1Unset {
		_ee = append(_ee, "\u0053T\u005f\u004f\u006e\u004f\u0066\u00661")
	}
	if len(_ee) > 1 {
		return _gf.Errorf("%\u0073\u0020\u0074\u006f\u006f\u0020m\u0061\u006e\u0079\u0020\u006d\u0065\u006d\u0062\u0065r\u0073\u0020\u0073e\u0074:\u0020\u0025\u0076", path, _ee)
	}
	return nil
}
func (_gff ST_AlgClass) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_de := _g.Attr{}
	_de.Name = name
	switch _gff {
	case ST_AlgClassUnset:
		_de.Value = ""
	case ST_AlgClassHash:
		_de.Value = "\u0068\u0061\u0073\u0068"
	case ST_AlgClassCustom:
		_de.Value = "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return _de, nil
}
func (_cde ST_YAlign) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cde.String(), start)
}
func (_gcg *ST_AlgType) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_bec, _bagf := d.Token()
	if _bagf != nil {
		return _bagf
	}
	if _edc, _ffe := _bec.(_g.EndElement); _ffe && _edc.Name == start.Name {
		*_gcg = 1
		return nil
	}
	if _efc, _baf := _bec.(_g.CharData); !_baf {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _bec)
	} else {
		switch string(_efc) {
		case "":
			*_gcg = 0
		case "\u0074y\u0070\u0065\u0041\u006e\u0079":
			*_gcg = 1
		case "\u0063\u0075\u0073\u0074\u006f\u006d":
			*_gcg = 2
		}
	}
	_bec, _bagf = d.Token()
	if _bagf != nil {
		return _bagf
	}
	if _efdf, _eb := _bec.(_g.EndElement); _eb && _efdf.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _bec)
}
func (_bbf ST_ConformanceClass) Validate() error { return _bbf.ValidateWithPath("") }
func (_eeg *ST_OnOff1) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_eeg = 0
	case "\u006f\u006e":
		*_eeg = 1
	case "\u006f\u0066\u0066":
		*_eeg = 2
	}
	return nil
}
func (_gbf ST_AlgClass) String() string {
	switch _gbf {
	case 0:
		return ""
	case 1:
		return "\u0068\u0061\u0073\u0068"
	case 2:
		return "\u0063\u0075\u0073\u0074\u006f\u006d"
	}
	return ""
}

var ST_FixedPercentagePatternRe = _gb.MustCompile(ST_FixedPercentagePattern)

func (_bafb ST_YAlign) MarshalXMLAttr(name _g.Name) (_g.Attr, error) {
	_dae := _g.Attr{}
	_dae.Name = name
	switch _bafb {
	case ST_YAlignUnset:
		_dae.Value = ""
	case ST_YAlignInline:
		_dae.Value = "\u0069\u006e\u006c\u0069\u006e\u0065"
	case ST_YAlignTop:
		_dae.Value = "\u0074\u006f\u0070"
	case ST_YAlignCenter:
		_dae.Value = "\u0063\u0065\u006e\u0074\u0065\u0072"
	case ST_YAlignBottom:
		_dae.Value = "\u0062\u006f\u0074\u0074\u006f\u006d"
	case ST_YAlignInside:
		_dae.Value = "\u0069\u006e\u0073\u0069\u0064\u0065"
	case ST_YAlignOutside:
		_dae.Value = "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return _dae, nil
}

const (
	ST_CalendarTypeUnset                ST_CalendarType = 0
	ST_CalendarTypeGregorian            ST_CalendarType = 1
	ST_CalendarTypeGregorianUs          ST_CalendarType = 2
	ST_CalendarTypeGregorianMeFrench    ST_CalendarType = 3
	ST_CalendarTypeGregorianArabic      ST_CalendarType = 4
	ST_CalendarTypeHijri                ST_CalendarType = 5
	ST_CalendarTypeHebrew               ST_CalendarType = 6
	ST_CalendarTypeTaiwan               ST_CalendarType = 7
	ST_CalendarTypeJapan                ST_CalendarType = 8
	ST_CalendarTypeThai                 ST_CalendarType = 9
	ST_CalendarTypeKorea                ST_CalendarType = 10
	ST_CalendarTypeSaka                 ST_CalendarType = 11
	ST_CalendarTypeGregorianXlitEnglish ST_CalendarType = 12
	ST_CalendarTypeGregorianXlitFrench  ST_CalendarType = 13
	ST_CalendarTypeNone                 ST_CalendarType = 14
)

func (_cg ST_CalendarType) Validate() error { return _cg.ValidateWithPath("") }

type ST_YAlign byte

// ST_OnOff is a union type
type ST_OnOff struct {
	Bool      *bool
	ST_OnOff1 ST_OnOff1
}
type ST_VerticalAlignRun byte

func (_bfac ST_XAlign) String() string {
	switch _bfac {
	case 0:
		return ""
	case 1:
		return "\u006c\u0065\u0066\u0074"
	case 2:
		return "\u0063\u0065\u006e\u0074\u0065\u0072"
	case 3:
		return "\u0072\u0069\u0067h\u0074"
	case 4:
		return "\u0069\u006e\u0073\u0069\u0064\u0065"
	case 5:
		return "\u006fu\u0074\u0073\u0069\u0064\u0065"
	}
	return ""
}
func (_ef *ST_TwipsMeasure) ValidateWithPath(path string) error {
	_bg := []string{}
	if _ef.ST_UnsignedDecimalNumber != nil {
		_bg = append(_bg, "\u0053T\u005f\u0055\u006e\u0073\u0069\u0067\u006e\u0065\u0064\u0044\u0065c\u0069\u006d\u0061\u006c\u004e\u0075\u006d\u0062\u0065\u0072")
	}
	if _ef.ST_PositiveUniversalMeasure != nil {
		_bg = append(_bg, "S\u0054\u005f\u0050\u006f\u0073\u0069t\u0069\u0076\u0065\u0055\u006e\u0069\u0076\u0065\u0072s\u0061\u006c\u004de\u0061s\u0075\u0072\u0065")
	}
	if len(_bg) > 1 {
		return _gf.Errorf("%\u0073\u0020\u0074\u006f\u006f\u0020m\u0061\u006e\u0079\u0020\u006d\u0065\u006d\u0062\u0065r\u0073\u0020\u0073e\u0074:\u0020\u0025\u0076", path, _bg)
	}
	return nil
}
func (_cfa ST_VerticalAlignRun) String() string {
	switch _cfa {
	case 0:
		return ""
	case 1:
		return "\u0062\u0061\u0073\u0065\u006c\u0069\u006e\u0065"
	case 2:
		return "s\u0075\u0070\u0065\u0072\u0073\u0063\u0072\u0069\u0070\u0074"
	case 3:
		return "\u0073u\u0062\u0073\u0063\u0072\u0069\u0070t"
	}
	return ""
}
func (_ca ST_AlgType) Validate() error { return _ca.ValidateWithPath("") }
func _d(_gbb bool) uint8 {
	if _gbb {
		return 1
	}
	return 0
}
func (_fbe *ST_CalendarType) UnmarshalXMLAttr(attr _g.Attr) error {
	switch attr.Value {
	case "":
		*_fbe = 0
	case "\u0067r\u0065\u0067\u006f\u0072\u0069\u0061n":
		*_fbe = 1
	case "g\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u0055\u0073":
		*_fbe = 2
	case "\u0067\u0072\u0065\u0067\u006f\u0072\u0069\u0061\u006e\u004d\u0065\u0046r\u0065\u006e\u0063\u0068":
		*_fbe = 3
	case "\u0067r\u0065g\u006f\u0072\u0069\u0061\u006e\u0041\u0072\u0061\u0062\u0069\u0063":
		*_fbe = 4
	case "\u0068\u0069\u006ar\u0069":
		*_fbe = 5
	case "\u0068\u0065\u0062\u0072\u0065\u0077":
		*_fbe = 6
	case "\u0074\u0061\u0069\u0077\u0061\u006e":
		*_fbe = 7
	case "\u006a\u0061\u0070a\u006e":
		*_fbe = 8
	case "\u0074\u0068\u0061\u0069":
		*_fbe = 9
	case "\u006b\u006f\u0072e\u0061":
		*_fbe = 10
	case "\u0073\u0061\u006b\u0061":
		*_fbe = 11
	case "g\u0072e\u0067\u006f\u0072\u0069\u0061\u006e\u0058\u006ci\u0074\u0045\u006e\u0067li\u0073\u0068":
		*_fbe = 12
	case "\u0067\u0072\u0065\u0067or\u0069\u0061\u006e\u0058\u006c\u0069\u0074\u0046\u0072\u0065\u006e\u0063\u0068":
		*_fbe = 13
	case "\u006e\u006f\u006e\u0065":
		*_fbe = 14
	}
	return nil
}
func (_fba ST_ConformanceClass) ValidateWithPath(path string) error {
	switch _fba {
	case 0, 1, 2:
	default:
		return _gf.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_fba))
	}
	return nil
}
func (_ad *ST_TrueFalseBlank) UnmarshalXML(d *_g.Decoder, start _g.StartElement) error {
	_dgc, _ggf := d.Token()
	if _ggf != nil {
		return _ggf
	}
	if _bga, _aef := _dgc.(_g.EndElement); _aef && _bga.Name == start.Name {
		*_ad = 1
		return nil
	}
	if _ebb, _gdb := _dgc.(_g.CharData); !_gdb {
		return _gf.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _dgc)
	} else {
		switch string(_ebb) {
		case "":
			*_ad = 0
		case "\u0074":
			*_ad = 1
		case "\u0066":
			*_ad = 2
		case "\u0074\u0072\u0075\u0065":
			*_ad = 3
		case "\u0066\u0061\u006cs\u0065":
			*_ad = 4
		case "\u0054\u0072\u0075\u0065":
			*_ad = 6
		case "\u0046\u0061\u006cs\u0065":
			*_ad = 7
		}
	}
	_dgc, _ggf = d.Token()
	if _ggf != nil {
		return _ggf
	}
	if _ffeg, _cab := _dgc.(_g.EndElement); _cab && _ffeg.Name == start.Name {
		return nil
	}
	return _gf.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _dgc)
}

type ST_AlgClass byte

var ST_UniversalMeasurePatternRe = _gb.MustCompile(ST_UniversalMeasurePattern)

func (_cbg ST_CalendarType) MarshalXML(e *_g.Encoder, start _g.StartElement) error {
	return e.EncodeElement(_cbg.String(), start)
}
func (_efd ST_CryptProv) Validate() error { return _efd.ValidateWithPath("") }
