//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package content_types

import (
	_b "encoding/xml"
	_e "fmt"
	_c "regexp"
	_d "unioffice"
	_cg "unioffice/common/logger"
)

type Override struct{ CT_Override }
type Types struct{ CT_Types }

func (_cbb *Types) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s"})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0054\u0079\u0070e\u0073"
	return _cbb.CT_Types.MarshalXML(e, start)
}
func NewCT_Override() *CT_Override {
	_fe := &CT_Override{}
	_fe.ContentTypeAttr = "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0078\u006d\u006c"
	return _fe
}

var ST_ExtensionPatternRe = _c.MustCompile(ST_ExtensionPattern)

// Validate validates the Override and its children
func (_efe *Override) Validate() error {
	return _efe.ValidateWithPath("\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065")
}
func (_dd *CT_Default) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dd.ExtensionAttr = "\u0078\u006d\u006c"
	_dd.ContentTypeAttr = "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0078\u006d\u006c"
	for _, _gb := range start.Attr {
		if _gb.Name.Local == "\u0045x\u0074\u0065\u006e\u0073\u0069\u006fn" {
			_f := _gb.Value
			_dd.ExtensionAttr = _f
			continue
		}
		if _gb.Name.Local == "C\u006f\u006e\u0074\u0065\u006e\u0074\u0054\u0079\u0070\u0065" {
			_ed := _gb.Value
			_dd.ContentTypeAttr = _ed
			continue
		}
	}
	for {
		_ac, _eda := d.Token()
		if _eda != nil {
			return _e.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0043\u0054\u005f\u0044\u0065\u0066\u0061\u0075\u006c\u0074\u003a\u0020%\u0073", _eda)
		}
		if _gc, _fg := _ac.(_b.EndElement); _fg && _gc.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Override struct {
	ContentTypeAttr string
	PartNameAttr    string
}

func (_eb *CT_Types) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
_eae:
	for {
		_eaf, _adg := d.Token()
		if _adg != nil {
			return _adg
		}
		switch _egf := _eaf.(type) {
		case _b.StartElement:
			switch _egf.Name {
			case _b.Name{Space: "ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", Local: "\u0044e\u0066\u0061\u0075\u006c\u0074"}:
				_afd := NewCT_TypesChoice()
				if _ee := d.DecodeElement(&_afd.Default, &_egf); _ee != nil {
					return _ee
				}
				_eb.TypesChoice = append(_eb.TypesChoice, _afd)
			case _b.Name{Space: "ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", Local: "\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065"}:
				_dfd := NewCT_TypesChoice()
				if _def := d.DecodeElement(&_dfd.Override, &_egf); _def != nil {
					return _def
				}
				_eb.TypesChoice = append(_eb.TypesChoice, _dfd)
			default:
				_cg.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069\u006eg\u0020\u0075\u006es\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0043\u0054\u005f\u0054\u0079\u0070\u0065\u0073\u0020\u0025\u0076", _egf.Name)
				if _cbf := d.Skip(); _cbf != nil {
					return _cbf
				}
			}
		case _b.EndElement:
			break _eae
		case _b.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the Override and its children, prefixing error messages with path
func (_afg *Override) ValidateWithPath(path string) error {
	if _fgbg := _afg.CT_Override.ValidateWithPath(path); _fgbg != nil {
		return _fgbg
	}
	return nil
}

// Validate validates the CT_Override and its children
func (_af *CT_Override) Validate() error {
	return _af.ValidateWithPath("C\u0054\u005f\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065")
}

// ValidateWithPath validates the Types and its children, prefixing error messages with path
func (_efb *Types) ValidateWithPath(path string) error {
	if _bda := _efb.CT_Types.ValidateWithPath(path); _bda != nil {
		return _bda
	}
	return nil
}
func (_ae *CT_TypesChoice) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _ae.Default != nil {
		_fgb := _b.StartElement{Name: _b.Name{Local: "\u0044e\u0066\u0061\u0075\u006c\u0074"}}
		e.EncodeElement(_ae.Default, _fgb)
	} else if _ae.Override != nil {
		_fb := _b.StartElement{Name: _b.Name{Local: "\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065"}}
		e.EncodeElement(_ae.Override, _fb)
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}
func NewCT_TypesChoice() *CT_TypesChoice { _ab := &CT_TypesChoice{}; return _ab }
func (_dg *Default) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_dg.CT_Default = *NewCT_Default()
	for _, _abd := range start.Attr {
		if _abd.Name.Local == "\u0045x\u0074\u0065\u006e\u0073\u0069\u006fn" {
			_ece := _abd.Value
			_dg.ExtensionAttr = _ece
			continue
		}
		if _abd.Name.Local == "C\u006f\u006e\u0074\u0065\u006e\u0074\u0054\u0079\u0070\u0065" {
			_ecb := _abd.Value
			_dg.ContentTypeAttr = _ecb
			continue
		}
	}
	for {
		_bc, _bea := d.Token()
		if _bea != nil {
			return _e.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0044\u0065\u0066\u0061\u0075\u006c\u0074\u003a\u0020\u0025\u0073", _bea)
		}
		if _bbf, _fc := _bc.(_b.EndElement); _fc && _bbf.Name == start.Name {
			break
		}
	}
	return nil
}
func NewDefault() *Default { _bec := &Default{}; _bec.CT_Default = *NewCT_Default(); return _bec }

type CT_TypesChoice struct {
	Default  *Default
	Override *Override
}

// Validate validates the Types and its children
func (_gd *Types) Validate() error { return _gd.ValidateWithPath("\u0054\u0079\u0070e\u0073") }
func NewOverride() *Override       { _fa := &Override{}; _fa.CT_Override = *NewCT_Override(); return _fa }
func (_fbb *Types) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_fbb.CT_Types = *NewCT_Types()
_abf:
	for {
		_gcd, _ead := d.Token()
		if _ead != nil {
			return _ead
		}
		switch _adf := _gcd.(type) {
		case _b.StartElement:
			switch _adf.Name {
			case _b.Name{Space: "ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", Local: "\u0044e\u0066\u0061\u0075\u006c\u0074"}:
				_bca := NewCT_TypesChoice()
				if _dbg := d.DecodeElement(&_bca.Default, &_adf); _dbg != nil {
					return _dbg
				}
				_fbb.TypesChoice = append(_fbb.TypesChoice, _bca)
			case _b.Name{Space: "ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", Local: "\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065"}:
				_cbc := NewCT_TypesChoice()
				if _gge := d.DecodeElement(&_cbc.Override, &_adf); _gge != nil {
					return _gge
				}
				_fbb.TypesChoice = append(_fbb.TypesChoice, _cbc)
			default:
				_cg.Log.Debug("s\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006fn \u0054\u0079\u0070e\u0073 \u0025\u0076", _adf.Name)
				if _dge := d.Skip(); _dge != nil {
					return _dge
				}
			}
		case _b.EndElement:
			break _abf
		case _b.CharData:
		}
	}
	return nil
}

type Default struct{ CT_Default }

func (_cfa *CT_TypesChoice) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_db := start
	switch start.Name {
	case _b.Name{Space: "ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", Local: "\u0044e\u0066\u0061\u0075\u006c\u0074"}:
		_cfa.Default = NewDefault()
		if _gg := d.DecodeElement(_cfa.Default, &_db); _gg != nil {
			return _gg
		}
	case _b.Name{Space: "ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", Local: "\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065"}:
		_cfa.Override = NewOverride()
		if _ge := d.DecodeElement(_cfa.Override, &_db); _ge != nil {
			return _ge
		}
	default:
		_cg.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u0065\u006d\u0065\u006et\u0020\u006f\u006e\u0020\u0043\u0054\u005f\u0054\u0079\u0070\u0065\u0073\u0043\u0068o\u0069c\u0065\u0020\u0025\u0076", _db.Name)
		if _cd := d.Skip(); _cd != nil {
			return _cd
		}
	}
	return nil
}
func (_aga *CT_Types) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	e.EncodeToken(start)
	if _aga.TypesChoice != nil {
		for _, _bd := range _aga.TypesChoice {
			_bd.MarshalXML(e, _b.StartElement{})
		}
	}
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the Default and its children, prefixing error messages with path
func (_ba *Default) ValidateWithPath(path string) error {
	if _aa := _ba.CT_Default.ValidateWithPath(path); _aa != nil {
		return _aa
	}
	return nil
}
func NewCT_Default() *CT_Default {
	_de := &CT_Default{}
	_de.ExtensionAttr = "\u0078\u006d\u006c"
	_de.ContentTypeAttr = "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0078\u006d\u006c"
	return _de
}
func (_bcc *Override) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _bcc.CT_Override.MarshalXML(e, start)
}

// Validate validates the CT_Types and its children
func (_cgb *CT_Types) Validate() error {
	return _cgb.ValidateWithPath("\u0043\u0054\u005f\u0054\u0079\u0070\u0065\u0073")
}

// Validate validates the CT_Default and its children
func (_ca *CT_Default) Validate() error {
	return _ca.ValidateWithPath("\u0043\u0054\u005f\u0044\u0065\u0066\u0061\u0075\u006c\u0074")
}
func (_eg *CT_Default) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "\u0045x\u0074\u0065\u006e\u0073\u0069\u006fn"}, Value: _e.Sprintf("\u0025\u0076", _eg.ExtensionAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "C\u006f\u006e\u0074\u0065\u006e\u0074\u0054\u0079\u0070\u0065"}, Value: _e.Sprintf("\u0025\u0076", _eg.ContentTypeAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

type CT_Default struct {
	ExtensionAttr   string
	ContentTypeAttr string
}

func (_cb *CT_Override) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_cb.ContentTypeAttr = "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0078\u006d\u006c"
	for _, _gf := range start.Attr {
		if _gf.Name.Local == "C\u006f\u006e\u0074\u0065\u006e\u0074\u0054\u0079\u0070\u0065" {
			_ff := _gf.Value
			_cb.ContentTypeAttr = _ff
			continue
		}
		if _gf.Name.Local == "\u0050\u0061\u0072\u0074\u004e\u0061\u006d\u0065" {
			_cf := _gf.Value
			_cb.PartNameAttr = _cf
			continue
		}
	}
	for {
		_ef, _cga := d.Token()
		if _cga != nil {
			return _e.Errorf("\u0070\u0061\u0072si\u006e\u0067\u0020\u0043\u0054\u005f\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065\u003a\u0020\u0025\u0073", _cga)
		}
		if _ec, _agd := _ef.(_b.EndElement); _agd && _ec.Name == start.Name {
			break
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Default and its children, prefixing error messages with path
func (_ea *CT_Default) ValidateWithPath(path string) error {
	if !ST_ExtensionPatternRe.MatchString(_ea.ExtensionAttr) {
		return _e.Errorf("\u0025s\u002f\u006d.\u0045\u0078\u0074\u0065n\u0073\u0069\u006fn\u0041\u0074\u0074\u0072\u0020\u006d\u0075\u0073\u0074 m\u0061\u0074\u0063h\u0020\u0027%\u0073\u0027\u0020\u0028\u0068\u0061v\u0065\u0020%\u0076\u0029", path, ST_ExtensionPatternRe, _ea.ExtensionAttr)
	}
	if !ST_ContentTypePatternRe.MatchString(_ea.ContentTypeAttr) {
		return _e.Errorf("\u0025\u0073/\u006d\u002e\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0054\u0079\u0070\u0065\u0041\u0074\u0074\u0072\u0020\u006d\u0075\u0073\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0027\u0025\u0073\u0027\u0020\u0028\u0068\u0061\u0076\u0065\u0020\u0025\u0076\u0029", path, ST_ContentTypePatternRe, _ea.ContentTypeAttr)
	}
	return nil
}

// Validate validates the Default and its children
func (_caf *Default) Validate() error {
	return _caf.ValidateWithPath("\u0044e\u0066\u0061\u0075\u006c\u0074")
}

// ValidateWithPath validates the CT_Override and its children, prefixing error messages with path
func (_df *CT_Override) ValidateWithPath(path string) error {
	if !ST_ContentTypePatternRe.MatchString(_df.ContentTypeAttr) {
		return _e.Errorf("\u0025\u0073/\u006d\u002e\u0043\u006f\u006e\u0074\u0065\u006e\u0074\u0054\u0079\u0070\u0065\u0041\u0074\u0074\u0072\u0020\u006d\u0075\u0073\u0074\u0020\u006d\u0061\u0074\u0063\u0068\u0020\u0027\u0025\u0073\u0027\u0020\u0028\u0068\u0061\u0076\u0065\u0020\u0025\u0076\u0029", path, ST_ContentTypePatternRe, _df.ContentTypeAttr)
	}
	return nil
}
func (_bb *Default) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	return _bb.CT_Default.MarshalXML(e, start)
}
func (_ag *CT_Override) MarshalXML(e *_b.Encoder, start _b.StartElement) error {
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "C\u006f\u006e\u0074\u0065\u006e\u0074\u0054\u0079\u0070\u0065"}, Value: _e.Sprintf("\u0025\u0076", _ag.ContentTypeAttr)})
	start.Attr = append(start.Attr, _b.Attr{Name: _b.Name{Local: "\u0050\u0061\u0072\u0074\u004e\u0061\u006d\u0065"}, Value: _e.Sprintf("\u0025\u0076", _ag.PartNameAttr)})
	e.EncodeToken(start)
	e.EncodeToken(_b.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_TypesChoice and its children, prefixing error messages with path
func (_aca *CT_TypesChoice) ValidateWithPath(path string) error {
	if _aca.Default != nil {
		if _fd := _aca.Default.ValidateWithPath(path + "\u002f\u0044\u0065\u0066\u0061\u0075\u006c\u0074"); _fd != nil {
			return _fd
		}
	}
	if _aca.Override != nil {
		if _fgc := _aca.Override.ValidateWithPath(path + "\u002fO\u0076\u0065\u0072\u0072\u0069\u0064e"); _fgc != nil {
			return _fgc
		}
	}
	return nil
}

var ST_ContentTypePatternRe = _c.MustCompile(ST_ContentTypePattern)

const ST_ContentTypePattern = "\u005e\\\u0070{\u004c\u0061\u0074\u0069\u006e\u007d\u002b\u002f\u002e\u002a\u0024"

func NewCT_Types() *CT_Types {
	_ad := &CT_Types{}
	return _ad
}

const ST_ExtensionPattern = "\u0028\u005b\u0021\u0024\u0026\u0027\\\u0028\u005c\u0029\u005c\u002a\\\u002b\u002c\u003a\u003d\u005d\u007c(\u0025\u005b\u0030\u002d\u0039a\u002d\u0066\u0041\u002d\u0046\u005d\u005b\u0030\u002d\u0039\u0061\u002df\u0041\u002d\u0046\u005d\u0029\u007c\u005b\u003a\u0040\u005d\u007c\u005b\u0061\u002d\u007aA\u002d\u005a\u0030\u002d\u0039\u005c\u002d\u005f~\u005d\u0029\u002b"

// Validate validates the CT_TypesChoice and its children
func (_bee *CT_TypesChoice) Validate() error {
	return _bee.ValidateWithPath("\u0043\u0054\u005f\u0054\u0079\u0070\u0065\u0073\u0043h\u006f\u0069\u0063\u0065")
}

// ValidateWithPath validates the CT_Types and its children, prefixing error messages with path
func (_da *CT_Types) ValidateWithPath(path string) error {
	for _gfc, _dde := range _da.TypesChoice {
		if _be := _dde.ValidateWithPath(_e.Sprintf("\u0025s\u002fT\u0079\u0070\u0065\u0073\u0043h\u006f\u0069c\u0065\u005b\u0025\u0064\u005d", path, _gfc)); _be != nil {
			return _be
		}
	}
	return nil
}
func NewTypes() *Types { _bef := &Types{}; _bef.CT_Types = *NewCT_Types(); return _bef }
func (_abb *Override) UnmarshalXML(d *_b.Decoder, start _b.StartElement) error {
	_abb.CT_Override = *NewCT_Override()
	for _, _cfb := range start.Attr {
		if _cfb.Name.Local == "C\u006f\u006e\u0074\u0065\u006e\u0074\u0054\u0079\u0070\u0065" {
			_ga := _cfb.Value
			_abb.ContentTypeAttr = _ga
			continue
		}
		if _cfb.Name.Local == "\u0050\u0061\u0072\u0074\u004e\u0061\u006d\u0065" {
			_aec := _cfb.Value
			_abb.PartNameAttr = _aec
			continue
		}
	}
	for {
		_ffa, _dbe := d.Token()
		if _dbe != nil {
			return _e.Errorf("p\u0061r\u0073\u0069\u006e\u0067\u0020\u004f\u0076\u0065r\u0072\u0069\u0064\u0065: \u0025\u0073", _dbe)
		}
		if _egd, _eeg := _ffa.(_b.EndElement); _eeg && _egd.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_Types struct{ TypesChoice []*CT_TypesChoice }

func init() {
	_d.RegisterConstructor("ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", "\u0043\u0054\u005f\u0054\u0079\u0070\u0065\u0073", NewCT_Types)
	_d.RegisterConstructor("ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", "\u0043\u0054\u005f\u0044\u0065\u0066\u0061\u0075\u006c\u0074", NewCT_Default)
	_d.RegisterConstructor("ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", "C\u0054\u005f\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065", NewCT_Override)
	_d.RegisterConstructor("ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", "\u0054\u0079\u0070e\u0073", NewTypes)
	_d.RegisterConstructor("ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", "\u0044e\u0066\u0061\u0075\u006c\u0074", NewDefault)
	_d.RegisterConstructor("ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0070\u0061\u0063\u006b\u0061\u0067\u0065\u002f\u00320\u00306\u002f\u0063\u006f\u006e\u0074\u0065\u006e\u0074-\u0074y\u0070\u0065s", "\u004f\u0076\u0065\u0072\u0072\u0069\u0064\u0065", NewOverride)
}
