//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package schemaLibrary

import (
	_c "encoding/xml"
	_e "fmt"

	_eb "github.com/gou-jjjj/unioffice"
	_a "github.com/gou-jjjj/unioffice/common/logger"
)

// ValidateWithPath validates the CT_Schema and its children, prefixing error messages with path
func (_gf *CT_Schema) ValidateWithPath(path string) error { return nil }

// Validate validates the CT_Schema and its children
func (_df *CT_Schema) Validate() error {
	return _df.ValidateWithPath("\u0043T\u005f\u0053\u0063\u0068\u0065\u006da")
}

// ValidateWithPath validates the CT_SchemaLibrary and its children, prefixing error messages with path
func (_ag *CT_SchemaLibrary) ValidateWithPath(path string) error {
	for _aeg, _aab := range _ag.Schema {
		if _gd := _aab.ValidateWithPath(_e.Sprintf("\u0025\u0073\u002f\u0053\u0063\u0068\u0065\u006d\u0061\u005b\u0025\u0064\u005d", path, _aeg)); _gd != nil {
			return _gd
		}
	}
	return nil
}

// ValidateWithPath validates the SchemaLibrary and its children, prefixing error messages with path
func (_gc *SchemaLibrary) ValidateWithPath(path string) error {
	if _cge := _gc.CT_SchemaLibrary.ValidateWithPath(path); _cge != nil {
		return _cge
	}
	return nil
}

type CT_Schema struct {

	// Custom XML Schema Namespace
	UriAttr *string

	// Supplementary XML File Location
	ManifestLocationAttr *string

	// Custom XML Schema Location
	SchemaLocationAttr *string

	// Schema Language
	SchemaLanguageAttr *string
}

func NewCT_SchemaLibrary() *CT_SchemaLibrary { _ae := &CT_SchemaLibrary{}; return _ae }
func (_gg *CT_SchemaLibrary) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	e.EncodeToken(start)
	if _gg.Schema != nil {
		_db := _c.StartElement{Name: _c.Name{Local: "\u006da\u003a\u0073\u0063\u0068\u0065\u006da"}}
		for _, _fb := range _gg.Schema {
			e.EncodeElement(_fb, _db)
		}
	}
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}

// Validate validates the CT_SchemaLibrary and its children
func (_gb *CT_SchemaLibrary) Validate() error {
	return _gb.ValidateWithPath("\u0043\u0054_\u0053\u0063\u0068e\u006d\u0061\u004c\u0069\u0062\u0072\u0061\u0072\u0079")
}
func (_b *CT_Schema) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	if _b.UriAttr != nil {
		start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u006d\u0061\u003a\u0075\u0072\u0069"}, Value: _e.Sprintf("\u0025\u0076", *_b.UriAttr)})
	}
	if _b.ManifestLocationAttr != nil {
		start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u006d\u0061\u003a\u006dan\u0069\u0066\u0065\u0073\u0074\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e"}, Value: _e.Sprintf("\u0025\u0076", *_b.ManifestLocationAttr)})
	}
	if _b.SchemaLocationAttr != nil {
		start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u006d\u0061\u003a\u0073\u0063\u0068\u0065\u006d\u0061\u004c\u006f\u0063a\u0074\u0069\u006f\u006e"}, Value: _e.Sprintf("\u0025\u0076", *_b.SchemaLocationAttr)})
	}
	if _b.SchemaLanguageAttr != nil {
		start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u006d\u0061\u003a\u0073\u0063\u0068\u0065\u006d\u0061\u004c\u0061\u006eg\u0075\u0061\u0067\u0065"}, Value: _e.Sprintf("\u0025\u0076", *_b.SchemaLanguageAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}
func NewSchemaLibrary() *SchemaLibrary {
	_ead := &SchemaLibrary{}
	_ead.CT_SchemaLibrary = *NewCT_SchemaLibrary()
	return _ead
}
func (_eda *SchemaLibrary) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0068\u0074\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067/\u0073\u0063\u0068\u0065\u006da\u004c\u0069\u0062\u0072\u0061\u0072\u0079\u002f\u0032\u0030\u0030\u0036\u002f\u006d\u0061\u0069\u006e"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006c\u006e\u0073\u003a\u006d\u0061"}, Value: "\u0068\u0074\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067/\u0073\u0063\u0068\u0065\u006da\u004c\u0069\u0062\u0072\u0061\u0072\u0079\u002f\u0032\u0030\u0030\u0036\u002f\u006d\u0061\u0069\u006e"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u006d\u0061:\u0073\u0063\u0068e\u006d\u0061\u004c\u0069\u0062\u0072\u0061\u0072\u0079"
	return _eda.CT_SchemaLibrary.MarshalXML(e, start)
}

type SchemaLibrary struct{ CT_SchemaLibrary }

func (_fbc *CT_SchemaLibrary) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
_cgc:
	for {
		_aa, _fg := d.Token()
		if _fg != nil {
			return _fg
		}
		switch _cf := _aa.(type) {
		case _c.StartElement:
			switch _cf.Name {
			case _c.Name{Space: "\u0068\u0074\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067/\u0073\u0063\u0068\u0065\u006da\u004c\u0069\u0062\u0072\u0061\u0072\u0079\u002f\u0032\u0030\u0030\u0036\u002f\u006d\u0061\u0069\u006e", Local: "\u0073\u0063\u0068\u0065\u006d\u0061"}:
				_da := NewCT_Schema()
				if _ab := d.DecodeElement(_da, &_cf); _ab != nil {
					return _ab
				}
				_fbc.Schema = append(_fbc.Schema, _da)
			default:
				_a.Log.Debug("\u0073\u006b\u0069\u0070\u0070i\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0043\u0054\u005f\u0053\u0063\u0068\u0065\u006d\u0061\u004c\u0069\u0062\u0072\u0061\u0072\u0079\u0020\u0025v", _cf.Name)
				if _ea := d.Skip(); _ea != nil {
					return _ea
				}
			}
		case _c.EndElement:
			break _cgc
		case _c.CharData:
		}
	}
	return nil
}
func (_fe *SchemaLibrary) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_fe.CT_SchemaLibrary = *NewCT_SchemaLibrary()
_ca:
	for {
		_aff, _dfe := d.Token()
		if _dfe != nil {
			return _dfe
		}
		switch _cgf := _aff.(type) {
		case _c.StartElement:
			switch _cgf.Name {
			case _c.Name{Space: "\u0068\u0074\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067/\u0073\u0063\u0068\u0065\u006da\u004c\u0069\u0062\u0072\u0061\u0072\u0079\u002f\u0032\u0030\u0030\u0036\u002f\u006d\u0061\u0069\u006e", Local: "\u0073\u0063\u0068\u0065\u006d\u0061"}:
				_abg := NewCT_Schema()
				if _ga := d.DecodeElement(_abg, &_cgf); _ga != nil {
					return _ga
				}
				_fe.Schema = append(_fe.Schema, _abg)
			default:
				_a.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067 \u0075\u006e\u0073up\u0070\u006f\u0072\u0074\u0065\u0064 \u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0053\u0063\u0068\u0065m\u0061\u004c\u0069\u0062\u0072\u0061\u0072\u0079 \u0025\u0076", _cgf.Name)
				if _cac := d.Skip(); _cac != nil {
					return _cac
				}
			}
		case _c.EndElement:
			break _ca
		case _c.CharData:
		}
	}
	return nil
}
func (_cc *CT_Schema) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	for _, _d := range start.Attr {
		if _d.Name.Local == "\u0075\u0072\u0069" {
			_cg := _d.Value
			_cc.UriAttr = &_cg
			continue
		}
		if _d.Name.Local == "\u006d\u0061n\u0069\u0066\u0065s\u0074\u004c\u006f\u0063\u0061\u0074\u0069\u006f\u006e" {
			_af := _d.Value
			_cc.ManifestLocationAttr = &_af
			continue
		}
		if _d.Name.Local == "\u0073\u0063\u0068\u0065\u006d\u0061\u004c\u006f\u0063a\u0074\u0069\u006f\u006e" {
			_eg := _d.Value
			_cc.SchemaLocationAttr = &_eg
			continue
		}
		if _d.Name.Local == "\u0073\u0063\u0068\u0065\u006d\u0061\u004c\u0061\u006eg\u0075\u0061\u0067\u0065" {
			_ed := _d.Value
			_cc.SchemaLanguageAttr = &_ed
			continue
		}
	}
	for {
		_ge, _de := d.Token()
		if _de != nil {
			return _e.Errorf("p\u0061\u0072\u0073\u0069ng\u0020C\u0054\u005f\u0053\u0063\u0068e\u006d\u0061\u003a\u0020\u0025\u0073", _de)
		}
		if _cb, _egb := _ge.(_c.EndElement); _egb && _cb.Name == start.Name {
			break
		}
	}
	return nil
}

type CT_SchemaLibrary struct {

	// Custom XML Schema Reference
	Schema []*CT_Schema
}

func NewCT_Schema() *CT_Schema { _ac := &CT_Schema{}; return _ac }

// Validate validates the SchemaLibrary and its children
func (_bf *SchemaLibrary) Validate() error {
	return _bf.ValidateWithPath("\u0053\u0063\u0068\u0065\u006d\u0061\u004c\u0069\u0062\u0072\u0061\u0072\u0079")
}
func init() {
	_eb.RegisterConstructor("\u0068\u0074\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067/\u0073\u0063\u0068\u0065\u006da\u004c\u0069\u0062\u0072\u0061\u0072\u0079\u002f\u0032\u0030\u0030\u0036\u002f\u006d\u0061\u0069\u006e", "\u0043T\u005f\u0053\u0063\u0068\u0065\u006da", NewCT_Schema)
	_eb.RegisterConstructor("\u0068\u0074\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067/\u0073\u0063\u0068\u0065\u006da\u004c\u0069\u0062\u0072\u0061\u0072\u0079\u002f\u0032\u0030\u0030\u0036\u002f\u006d\u0061\u0069\u006e", "\u0043\u0054_\u0053\u0063\u0068e\u006d\u0061\u004c\u0069\u0062\u0072\u0061\u0072\u0079", NewCT_SchemaLibrary)
	_eb.RegisterConstructor("\u0068\u0074\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067/\u0073\u0063\u0068\u0065\u006da\u004c\u0069\u0062\u0072\u0061\u0072\u0079\u002f\u0032\u0030\u0030\u0036\u002f\u006d\u0061\u0069\u006e", "\u0073\u0063\u0068\u0065\u006d\u0061\u004c\u0069\u0062\u0072\u0061\u0072\u0079", NewSchemaLibrary)
}
