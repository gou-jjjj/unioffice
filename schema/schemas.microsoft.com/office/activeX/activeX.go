//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package activeX

import (
	_gf "encoding/xml"
	_gb "fmt"
	_ab "unioffice"
	_a "unioffice/common/logger"
)

func NewCT_OcxPr() *CT_OcxPr { _dg := &CT_OcxPr{}; _dg.OcxPrChoice = NewCT_OcxPrChoice(); return _dg }
func (_bc *CT_OcxPr) UnmarshalXML(d *_gf.Decoder, start _gf.StartElement) error {
	_bc.OcxPrChoice = NewCT_OcxPrChoice()
	for _, _bb := range start.Attr {
		if _bb.Name.Local == "\u006e\u0061\u006d\u0065" {
			_de := _bb.Value
			_bc.NameAttr = _de
			continue
		}
		if _bb.Name.Local == "\u0076\u0061\u006cu\u0065" {
			_dgd := _bb.Value
			_bc.ValueAttr = &_dgd
			continue
		}
	}
_cb:
	for {
		_aee, _agd := d.Token()
		if _agd != nil {
			return _agd
		}
		switch _ee := _aee.(type) {
		case _gf.StartElement:
			switch _ee.Name {
			case _gf.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", Local: "\u0066\u006f\u006e\u0074"}:
				_bc.OcxPrChoice = NewCT_OcxPrChoice()
				if _dgg := d.DecodeElement(&_bc.OcxPrChoice.Font, &_ee); _dgg != nil {
					return _dgg
				}
			case _gf.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", Local: "\u0070i\u0063\u0074\u0075\u0072\u0065"}:
				_bc.OcxPrChoice = NewCT_OcxPrChoice()
				if _ce := d.DecodeElement(&_bc.OcxPrChoice.Picture, &_ee); _ce != nil {
					return _ce
				}
			default:
				_a.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069\u006eg\u0020\u0075\u006es\u0075\u0070\u0070\u006fr\u0074\u0065\u0064\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0043\u0054\u005f\u004f\u0063\u0078\u0050\u0072\u0020\u0025\u0076", _ee.Name)
				if _ff := d.Skip(); _ff != nil {
					return _ff
				}
			}
		case _gf.EndElement:
			break _cb
		case _gf.CharData:
		}
	}
	return nil
}
func NewOcx() *Ocx { _fbb := &Ocx{}; _fbb.CT_Ocx = *NewCT_Ocx(); return _fbb }

// Validate validates the CT_Ocx and its children
func (_cd *CT_Ocx) Validate() error {
	return _cd.ValidateWithPath("\u0043\u0054\u005f\u004f\u0063\u0078")
}
func NewCT_OcxPrChoice() *CT_OcxPrChoice { _bab := &CT_OcxPrChoice{}; return _bab }

// Validate validates the CT_OcxPrChoice and its children
func (_fdb *CT_OcxPrChoice) Validate() error {
	return _fdb.ValidateWithPath("\u0043\u0054\u005f\u004f\u0063\u0078\u0050\u0072\u0043h\u006f\u0069\u0063\u0065")
}
func (_cf *CT_Picture) MarshalXML(e *_gf.Encoder, start _gf.StartElement) error {
	if _cf.IdAttr != nil {
		start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0072\u003a\u0069\u0064"}, Value: _gb.Sprintf("\u0025\u0076", *_cf.IdAttr)})
	}
	e.EncodeToken(start)
	e.EncodeToken(_gf.EndElement{Name: start.Name})
	return nil
}

// ValidateWithPath validates the CT_Ocx and its children, prefixing error messages with path
func (_abc *CT_Ocx) ValidateWithPath(path string) error {
	if _abc.PersistenceAttr == ST_PersistenceUnset {
		return _gb.Errorf("\u0025\u0073\u002f\u0050\u0065\u0072\u0073\u0069\u0073\u0074\u0065\u006e\u0063e\u0041\u0074\u0074\u0072\u0020\u0069s\u0020\u0061\u0020\u006d\u0061\u006e\u0064\u0061\u0074\u006f\u0072\u0079\u0020f\u0069\u0065\u006c\u0064", path)
	}
	if _abd := _abc.PersistenceAttr.ValidateWithPath(path + "\u002f\u0050e\u0072\u0073\u0069s\u0074\u0065\u006e\u0063\u0065\u0041\u0074\u0074\u0072"); _abd != nil {
		return _abd
	}
	for _dd, _cg := range _abc.OcxPr {
		if _agg := _cg.ValidateWithPath(_gb.Sprintf("\u0025\u0073\u002fO\u0063\u0078\u0050\u0072\u005b\u0025\u0064\u005d", path, _dd)); _agg != nil {
			return _agg
		}
	}
	return nil
}
func (_gba *CT_Font) UnmarshalXML(d *_gf.Decoder, start _gf.StartElement) error {
	for _, _df := range start.Attr {
		if _df.Name.Space == "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068\u0065\u006da\u0073\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069c\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073h\u0069\u0070\u0073" && _df.Name.Local == "\u0069\u0064" || _df.Name.Space == "\u0068\u0074\u0074\u0070\u003a\u002f\u002fp\u0075\u0072\u006c.\u006f\u0063\u006cc\u002e\u006fr\u0067\u002f\u006f\u006f\u0078\u006dl\u002fof\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0072\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068\u0069\u0070\u0073" && _df.Name.Local == "\u0069\u0064" {
			_gd := _df.Value
			_gba.IdAttr = &_gd
			continue
		}
		if _df.Name.Local == "p\u0065\u0072\u0073\u0069\u0073\u0074\u0065\u006e\u0063\u0065" {
			_gba.PersistenceAttr.UnmarshalXMLAttr(_df)
			continue
		}
	}
_dff:
	for {
		_c, _be := d.Token()
		if _be != nil {
			return _be
		}
		switch _fb := _c.(type) {
		case _gf.StartElement:
			switch _fb.Name {
			case _gf.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", Local: "\u006f\u0063\u0078P\u0072"}:
				_dab := NewCT_OcxPr()
				if _aa := d.DecodeElement(_dab, &_fb); _aa != nil {
					return _aa
				}
				_gba.OcxPr = append(_gba.OcxPr, _dab)
			default:
				_a.Log.Debug("\u0073\u006b\u0069p\u0070\u0069\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0043T\u005f\u0046\u006f\u006e\u0074\u0020\u0025\u0076", _fb.Name)
				if _gg := d.Skip(); _gg != nil {
					return _gg
				}
			}
		case _gf.EndElement:
			break _dff
		case _gf.CharData:
		}
	}
	return nil
}
func (_ae *CT_OcxPr) MarshalXML(e *_gf.Encoder, start _gf.StartElement) error {
	start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0061x\u003a\u006e\u0061\u006d\u0065"}, Value: _gb.Sprintf("\u0025\u0076", _ae.NameAttr)})
	if _ae.ValueAttr != nil {
		start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0061\u0078\u003a\u0076\u0061\u006c\u0075\u0065"}, Value: _gb.Sprintf("\u0025\u0076", *_ae.ValueAttr)})
	}
	e.EncodeToken(start)
	_ae.OcxPrChoice.MarshalXML(e, _gf.StartElement{})
	e.EncodeToken(_gf.EndElement{Name: start.Name})
	return nil
}
func (_agdc ST_Persistence) MarshalXML(e *_gf.Encoder, start _gf.StartElement) error {
	return e.EncodeElement(_agdc.String(), start)
}
func (_ddc ST_Persistence) ValidateWithPath(path string) error {
	switch _ddc {
	case 0, 1, 2, 3, 4:
	default:
		return _gb.Errorf("\u0025s\u003a\u0020\u006f\u0075t\u0020\u006f\u0066\u0020\u0072a\u006eg\u0065 \u0076\u0061\u006c\u0075\u0065\u0020\u0025d", path, int(_ddc))
	}
	return nil
}

type CT_OcxPr struct {
	NameAttr    string
	ValueAttr   *string
	OcxPrChoice *CT_OcxPrChoice
}

func (_bgd *ST_Persistence) UnmarshalXML(d *_gf.Decoder, start _gf.StartElement) error {
	_fc, _bgdf := d.Token()
	if _bgdf != nil {
		return _bgdf
	}
	if _ada, _faf := _fc.(_gf.EndElement); _faf && _ada.Name == start.Name {
		*_bgd = 1
		return nil
	}
	if _gdg, _cfd := _fc.(_gf.CharData); !_cfd {
		return _gb.Errorf("\u0065\u0078\u0070\u0065\u0063\u0074\u0065\u0064\u0020\u0063\u0068a\u0072\u0020\u0064\u0061\u0074\u0061\u002c\u0020\u0067\u006ft\u0020\u0025\u0054", _fc)
	} else {
		switch string(_gdg) {
		case "":
			*_bgd = 0
		case "\u0070e\u0072s\u0069\u0073\u0074\u0050\u0072o\u0070\u0065r\u0074\u0079\u0042\u0061\u0067":
			*_bgd = 1
		case "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074\u0072\u0065\u0061\u006d":
			*_bgd = 2
		case "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074\u0072\u0065\u0061m\u0049\u006e\u0069\u0074":
			*_bgd = 3
		case "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074o\u0072\u0061\u0067\u0065":
			*_bgd = 4
		}
	}
	_fc, _bgdf = d.Token()
	if _bgdf != nil {
		return _bgdf
	}
	if _ceg, _dgf := _fc.(_gf.EndElement); _dgf && _ceg.Name == start.Name {
		return nil
	}
	return _gb.Errorf("\u0065\u0078\u0070\u0065c\u0074\u0065\u0064\u0020\u0065\u006e\u0064\u0020\u0065\u006ce\u006de\u006e\u0074\u002c\u0020\u0067\u006f\u0074 \u0025\u0076", _fc)
}

// Validate validates the CT_OcxPr and its children
func (_dga *CT_OcxPr) Validate() error {
	return _dga.ValidateWithPath("\u0043\u0054\u005f\u004f\u0063\u0078\u0050\u0072")
}

// ValidateWithPath validates the CT_OcxPrChoice and its children, prefixing error messages with path
func (_ca *CT_OcxPrChoice) ValidateWithPath(path string) error {
	if _ca.Font != nil {
		if _dbb := _ca.Font.ValidateWithPath(path + "\u002f\u0046\u006fn\u0074"); _dbb != nil {
			return _dbb
		}
	}
	if _ca.Picture != nil {
		if _fec := _ca.Picture.ValidateWithPath(path + "\u002f\u0050\u0069\u0063\u0074\u0075\u0072\u0065"); _fec != nil {
			return _fec
		}
	}
	return nil
}
func (_bbb ST_Persistence) String() string {
	switch _bbb {
	case 0:
		return ""
	case 1:
		return "\u0070e\u0072s\u0069\u0073\u0074\u0050\u0072o\u0070\u0065r\u0074\u0079\u0042\u0061\u0067"
	case 2:
		return "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074\u0072\u0065\u0061\u006d"
	case 3:
		return "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074\u0072\u0065\u0061m\u0049\u006e\u0069\u0074"
	case 4:
		return "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074o\u0072\u0061\u0067\u0065"
	}
	return ""
}

type CT_Ocx struct {
	ClassidAttr     string
	LicenseAttr     *string
	IdAttr          *string
	PersistenceAttr ST_Persistence
	OcxPr           []*CT_OcxPr
}
type CT_OcxPrChoice struct {
	Font    *CT_Font
	Picture *CT_Picture
}

// ValidateWithPath validates the CT_OcxPr and its children, prefixing error messages with path
func (_ggc *CT_OcxPr) ValidateWithPath(path string) error {
	if _ead := _ggc.OcxPrChoice.ValidateWithPath(path + "\u002f\u004f\u0063x\u0050\u0072\u0043\u0068\u006f\u0069\u0063\u0065"); _ead != nil {
		return _ead
	}
	return nil
}

// Validate validates the Ocx and its children
func (_gafeb *Ocx) Validate() error { return _gafeb.ValidateWithPath("\u004f\u0063\u0078") }

type CT_Picture struct{ IdAttr *string }

func NewCT_Picture() *CT_Picture { _dac := &CT_Picture{}; return _dac }
func NewCT_Ocx() *CT_Ocx {
	_ec := &CT_Ocx{}
	_ec.PersistenceAttr = ST_Persistence(1)
	return _ec
}

// ValidateWithPath validates the Ocx and its children, prefixing error messages with path
func (_gcb *Ocx) ValidateWithPath(path string) error {
	if _ad := _gcb.CT_Ocx.ValidateWithPath(path); _ad != nil {
		return _ad
	}
	return nil
}
func (_abdd ST_Persistence) MarshalXMLAttr(name _gf.Name) (_gf.Attr, error) {
	_fece := _gf.Attr{}
	_fece.Name = name
	switch _abdd {
	case ST_PersistenceUnset:
		_fece.Value = ""
	case ST_PersistencePersistPropertyBag:
		_fece.Value = "\u0070e\u0072s\u0069\u0073\u0074\u0050\u0072o\u0070\u0065r\u0074\u0079\u0042\u0061\u0067"
	case ST_PersistencePersistStream:
		_fece.Value = "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074\u0072\u0065\u0061\u006d"
	case ST_PersistencePersistStreamInit:
		_fece.Value = "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074\u0072\u0065\u0061m\u0049\u006e\u0069\u0074"
	case ST_PersistencePersistStorage:
		_fece.Value = "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074o\u0072\u0061\u0067\u0065"
	}
	return _fece, nil
}

type ST_Persistence byte

func (_fe *CT_OcxPrChoice) MarshalXML(e *_gf.Encoder, start _gf.StartElement) error {
	if _fe.Font != nil {
		_cbc := _gf.StartElement{Name: _gf.Name{Local: "\u0061x\u003a\u0066\u006f\u006e\u0074"}}
		e.EncodeElement(_fe.Font, _cbc)
	} else if _fe.Picture != nil {
		_fdf := _gf.StartElement{Name: _gf.Name{Local: "\u0061\u0078\u003a\u0070\u0069\u0063\u0074\u0075\u0072\u0065"}}
		e.EncodeElement(_fe.Picture, _fdf)
	}
	return nil
}
func (_ddb ST_Persistence) Validate() error { return _ddb.ValidateWithPath("") }

const (
	ST_PersistenceUnset              ST_Persistence = 0
	ST_PersistencePersistPropertyBag ST_Persistence = 1
	ST_PersistencePersistStream      ST_Persistence = 2
	ST_PersistencePersistStreamInit  ST_Persistence = 3
	ST_PersistencePersistStorage     ST_Persistence = 4
)

func (_gac *CT_Ocx) UnmarshalXML(d *_gf.Decoder, start _gf.StartElement) error {
	_gac.PersistenceAttr = ST_Persistence(1)
	for _, _abe := range start.Attr {
		if _abe.Name.Space == "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068\u0065\u006da\u0073\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069c\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073h\u0069\u0070\u0073" && _abe.Name.Local == "\u0069\u0064" || _abe.Name.Space == "\u0068\u0074\u0074\u0070\u003a\u002f\u002fp\u0075\u0072\u006c.\u006f\u0063\u006cc\u002e\u006fr\u0067\u002f\u006f\u006f\u0078\u006dl\u002fof\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0072\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068\u0069\u0070\u0073" && _abe.Name.Local == "\u0069\u0064" {
			_gafg := _abe.Value
			_gac.IdAttr = &_gafg
			continue
		}
		if _abe.Name.Local == "\u0063l\u0061\u0073\u0073\u0069\u0064" {
			_eg := _abe.Value
			_gac.ClassidAttr = _eg
			continue
		}
		if _abe.Name.Local == "\u006ci\u0063\u0065\u006e\u0073\u0065" {
			_dc := _abe.Value
			_gac.LicenseAttr = &_dc
			continue
		}
		if _abe.Name.Local == "p\u0065\u0072\u0073\u0069\u0073\u0074\u0065\u006e\u0063\u0065" {
			_gac.PersistenceAttr.UnmarshalXMLAttr(_abe)
			continue
		}
	}
_egb:
	for {
		_fda, _ba := d.Token()
		if _ba != nil {
			return _ba
		}
		switch _ea := _fda.(type) {
		case _gf.StartElement:
			switch _ea.Name {
			case _gf.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", Local: "\u006f\u0063\u0078P\u0072"}:
				_bd := NewCT_OcxPr()
				if _gafe := d.DecodeElement(_bd, &_ea); _gafe != nil {
					return _gafe
				}
				_gac.OcxPr = append(_gac.OcxPr, _bd)
			default:
				_a.Log.Debug("\u0073\u006b\u0069\u0070\u0070i\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0065\u006c\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0043\u0054\u005f\u004f\u0063\u0078\u0020\u0025\u0076", _ea.Name)
				if _bad := d.Skip(); _bad != nil {
					return _bad
				}
			}
		case _gf.EndElement:
			break _egb
		case _gf.CharData:
		}
	}
	return nil
}

// Validate validates the CT_Font and its children
func (_bf *CT_Font) Validate() error {
	return _bf.ValidateWithPath("\u0043T\u005f\u0046\u006f\u006e\u0074")
}
func (_dcg *CT_Picture) UnmarshalXML(d *_gf.Decoder, start _gf.StartElement) error {
	for _, _fgc := range start.Attr {
		if _fgc.Name.Space == "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068\u0065\u006da\u0073\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069c\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073h\u0069\u0070\u0073" && _fgc.Name.Local == "\u0069\u0064" || _fgc.Name.Space == "\u0068\u0074\u0074\u0070\u003a\u002f\u002fp\u0075\u0072\u006c.\u006f\u0063\u006cc\u002e\u006fr\u0067\u002f\u006f\u006f\u0078\u006dl\u002fof\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0072\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068\u0069\u0070\u0073" && _fgc.Name.Local == "\u0069\u0064" {
			_abcd := _fgc.Value
			_dcg.IdAttr = &_abcd
			continue
		}
	}
	for {
		_ddf, _bcb := d.Token()
		if _bcb != nil {
			return _gb.Errorf("\u0070\u0061\u0072\u0073in\u0067\u0020\u0043\u0054\u005f\u0050\u0069\u0063\u0074\u0075\u0072\u0065\u003a\u0020%\u0073", _bcb)
		}
		if _age, _bea := _ddf.(_gf.EndElement); _bea && _age.Name == start.Name {
			break
		}
	}
	return nil
}

// Validate validates the CT_Picture and its children
func (_fgb *CT_Picture) Validate() error {
	return _fgb.ValidateWithPath("\u0043\u0054\u005f\u0050\u0069\u0063\u0074\u0075\u0072\u0065")
}

type CT_Font struct {
	PersistenceAttr ST_Persistence
	IdAttr          *string
	OcxPr           []*CT_OcxPr
}

func (_eag *ST_Persistence) UnmarshalXMLAttr(attr _gf.Attr) error {
	switch attr.Value {
	case "":
		*_eag = 0
	case "\u0070e\u0072s\u0069\u0073\u0074\u0050\u0072o\u0070\u0065r\u0074\u0079\u0042\u0061\u0067":
		*_eag = 1
	case "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074\u0072\u0065\u0061\u006d":
		*_eag = 2
	case "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074\u0072\u0065\u0061m\u0049\u006e\u0069\u0074":
		*_eag = 3
	case "\u0070\u0065\u0072\u0073\u0069\u0073\u0074\u0053\u0074o\u0072\u0061\u0067\u0065":
		*_eag = 4
	}
	return nil
}
func (_bed *CT_Ocx) MarshalXML(e *_gf.Encoder, start _gf.StartElement) error {
	start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0061\u0078\u003a\u0063\u006c\u0061\u0073\u0073\u0069\u0064"}, Value: _gb.Sprintf("\u0025\u0076", _bed.ClassidAttr)})
	if _bed.LicenseAttr != nil {
		start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0061\u0078\u003a\u006c\u0069\u0063\u0065\u006e\u0073\u0065"}, Value: _gb.Sprintf("\u0025\u0076", *_bed.LicenseAttr)})
	}
	if _bed.IdAttr != nil {
		start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0072\u003a\u0069\u0064"}, Value: _gb.Sprintf("\u0025\u0076", *_bed.IdAttr)})
	}
	_eb, _ece := _bed.PersistenceAttr.MarshalXMLAttr(_gf.Name{Local: "\u0061\u0078\u003a\u0070\u0065\u0072\u0073\u0069\u0073t\u0065\u006e\u0063\u0065"})
	if _ece != nil {
		return _ece
	}
	start.Attr = append(start.Attr, _eb)
	e.EncodeToken(start)
	if _bed.OcxPr != nil {
		_gaf := _gf.StartElement{Name: _gf.Name{Local: "\u0061\u0078\u003a\u006f\u0063\u0078\u0050\u0072"}}
		for _, _bede := range _bed.OcxPr {
			e.EncodeElement(_bede, _gaf)
		}
	}
	e.EncodeToken(_gf.EndElement{Name: start.Name})
	return nil
}

type Ocx struct{ CT_Ocx }

// ValidateWithPath validates the CT_Picture and its children, prefixing error messages with path
func (_ac *CT_Picture) ValidateWithPath(path string) error { return nil }
func NewCT_Font() *CT_Font                                 { _ag := &CT_Font{}; return _ag }
func (_f *CT_Font) MarshalXML(e *_gf.Encoder, start _gf.StartElement) error {
	if _f.PersistenceAttr != ST_PersistenceUnset {
		_d, _b := _f.PersistenceAttr.MarshalXMLAttr(_gf.Name{Local: "\u0061\u0078\u003a\u0070\u0065\u0072\u0073\u0069\u0073t\u0065\u006e\u0063\u0065"})
		if _b != nil {
			return _b
		}
		start.Attr = append(start.Attr, _d)
	}
	if _f.IdAttr != nil {
		start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0072\u003a\u0069\u0064"}, Value: _gb.Sprintf("\u0025\u0076", *_f.IdAttr)})
	}
	e.EncodeToken(start)
	if _f.OcxPr != nil {
		_e := _gf.StartElement{Name: _gf.Name{Local: "\u0061\u0078\u003a\u006f\u0063\u0078\u0050\u0072"}}
		for _, _da := range _f.OcxPr {
			e.EncodeElement(_da, _e)
		}
	}
	e.EncodeToken(_gf.EndElement{Name: start.Name})
	return nil
}
func (_bce *CT_OcxPrChoice) UnmarshalXML(d *_gf.Decoder, start _gf.StartElement) error {
	_ffg := start
	switch start.Name {
	case _gf.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", Local: "\u0066\u006f\u006e\u0074"}:
		_bce.Font = NewCT_Font()
		if _ebc := d.DecodeElement(_bce.Font, &_ffg); _ebc != nil {
			return _ebc
		}
	case _gf.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", Local: "\u0070i\u0063\u0074\u0075\u0072\u0065"}:
		_bce.Picture = NewCT_Picture()
		if _fbc := d.DecodeElement(_bce.Picture, &_ffg); _fbc != nil {
			return _fbc
		}
	default:
		_a.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u0065\u006d\u0065\u006et\u0020\u006f\u006e\u0020\u0043\u0054\u005f\u004f\u0063\u0078\u0050\u0072\u0043\u0068o\u0069c\u0065\u0020\u0025\u0076", _ffg.Name)
		if _bfd := d.Skip(); _bfd != nil {
			return _bfd
		}
	}
	return nil
}

// ValidateWithPath validates the CT_Font and its children, prefixing error messages with path
func (_gag *CT_Font) ValidateWithPath(path string) error {
	if _fd := _gag.PersistenceAttr.ValidateWithPath(path + "\u002f\u0050e\u0072\u0073\u0069s\u0074\u0065\u006e\u0063\u0065\u0041\u0074\u0074\u0072"); _fd != nil {
		return _fd
	}
	for _fg, _gc := range _gag.OcxPr {
		if _bfe := _gc.ValidateWithPath(_gb.Sprintf("\u0025\u0073\u002fO\u0063\u0078\u0050\u0072\u005b\u0025\u0064\u005d", path, _fg)); _bfe != nil {
			return _bfe
		}
	}
	return nil
}
func (_ffga *Ocx) UnmarshalXML(d *_gf.Decoder, start _gf.StartElement) error {
	_ffga.CT_Ocx = *NewCT_Ocx()
	for _, _fgg := range start.Attr {
		if _fgg.Name.Space == "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068\u0065\u006da\u0073\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069c\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073h\u0069\u0070\u0073" && _fgg.Name.Local == "\u0069\u0064" || _fgg.Name.Space == "\u0068\u0074\u0074\u0070\u003a\u002f\u002fp\u0075\u0072\u006c.\u006f\u0063\u006cc\u002e\u006fr\u0067\u002f\u006f\u006f\u0078\u006dl\u002fof\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0072\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068\u0069\u0070\u0073" && _fgg.Name.Local == "\u0069\u0064" {
			_aef := _fgg.Value
			_ffga.IdAttr = &_aef
			continue
		}
		if _fgg.Name.Local == "\u0063l\u0061\u0073\u0073\u0069\u0064" {
			_gbe := _fgg.Value
			_ffga.ClassidAttr = _gbe
			continue
		}
		if _fgg.Name.Local == "\u006ci\u0063\u0065\u006e\u0073\u0065" {
			_gad := _fgg.Value
			_ffga.LicenseAttr = &_gad
			continue
		}
		if _fgg.Name.Local == "p\u0065\u0072\u0073\u0069\u0073\u0074\u0065\u006e\u0063\u0065" {
			_ffga.PersistenceAttr.UnmarshalXMLAttr(_fgg)
			continue
		}
	}
_ebg:
	for {
		_aaf, _aggb := d.Token()
		if _aggb != nil {
			return _aggb
		}
		switch _eggg := _aaf.(type) {
		case _gf.StartElement:
			switch _eggg.Name {
			case _gf.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", Local: "\u006f\u0063\u0078P\u0072"}:
				_cc := NewCT_OcxPr()
				if _cdg := d.DecodeElement(_cc, &_eggg); _cdg != nil {
					return _cdg
				}
				_ffga.OcxPr = append(_ffga.OcxPr, _cc)
			default:
				_a.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u0065m\u0065\u006e\u0074\u0020\u006fn\u0020\u004fc\u0078\u0020\u0025\u0076", _eggg.Name)
				if _baa := d.Skip(); _baa != nil {
					return _baa
				}
			}
		case _gf.EndElement:
			break _ebg
		case _gf.CharData:
		}
	}
	return nil
}
func (_bg *Ocx) MarshalXML(e *_gf.Encoder, start _gf.StartElement) error {
	start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058"})
	start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0078\u006d\u006c\u006e\u0073\u003a\u0061\u0078"}, Value: "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058"})
	start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0072"}, Value: "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068\u0065\u006da\u0073\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069c\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073h\u0069\u0070\u0073"})
	start.Attr = append(start.Attr, _gf.Attr{Name: _gf.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "\u0061\u0078\u003a\u006f\u0063\u0078"
	return _bg.CT_Ocx.MarshalXML(e, start)
}
func init() {
	_ab.RegisterConstructor("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", "\u0043\u0054\u005f\u004f\u0063\u0078", NewCT_Ocx)
	_ab.RegisterConstructor("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", "\u0043\u0054\u005f\u004f\u0063\u0078\u0050\u0072", NewCT_OcxPr)
	_ab.RegisterConstructor("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", "\u0043T\u005f\u0046\u006f\u006e\u0074", NewCT_Font)
	_ab.RegisterConstructor("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", "\u0043\u0054\u005f\u0050\u0069\u0063\u0074\u0075\u0072\u0065", NewCT_Picture)
	_ab.RegisterConstructor("\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073c\u0068\u0065\u006das\u002e\u006d\u0069\u0063\u0072\u006fs\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u002f2\u0030\u0030\u0036\u002f\u0061\u0063\u0074\u0069v\u0065\u0058", "\u006f\u0063\u0078", NewOcx)
}
