//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package cex

import (
	_c "encoding/xml"
	_g "fmt"
	_ab "time"
	_f "unioffice"
	_e "unioffice/common/logger"
	_cd "unioffice/schema/schemas.microsoft.com/office/word/2018/wordml"
	_ed "unioffice/schema/soo/ofc/sharedTypes"
)

// Validate validates the CT_CommentExtensible and its children
func (_ag *CT_CommentExtensible) Validate() error {
	return _ag.ValidateWithPath("C\u0054_\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0045x\u0074\u0065\u006e\u0073ib\u006c\u0065")
}
func (_ca *CT_CommentExtensible) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	for _, _ee := range start.Attr {
		if _ee.Name.Local == "\u0064a\u0074\u0065\u0055\u0074\u0063" {
			_fc, _d := ParseStdlibTime(_ee.Value)
			if _d != nil {
				return _d
			}
			_ca.DateUtcAttr = &_fc
			continue
		}
		if _ee.Name.Local == "\u0069\u006e\u0074\u0065ll\u0069\u0067\u0065\u006e\u0074\u0050\u006c\u0061\u0063\u0065\u0068\u006f\u006c\u0064e\u0072" {
			_db, _fcf := ParseUnionST_OnOff(_ee.Value)
			if _fcf != nil {
				return _fcf
			}
			_ca.IntelligentPlaceholderAttr = &_db
			continue
		}
	}
_ff:
	for {
		_gb, _b := d.Token()
		if _b != nil {
			return _b
		}
		switch _cc := _gb.(type) {
		case _c.StartElement:
			switch _cc.Name {
			case _c.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078", Local: "\u0065\u0078\u0074\u004c\u0073\u0074"}:
				_ca.ExtLst = _cd.NewCT_ExtensionList()
				if _ac := d.DecodeElement(_ca.ExtLst, &_cc); _ac != nil {
					return _ac
				}
			default:
				_e.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069\u006eg\u0020\u0075\u006es\u0075\u0070\u0070o\u0072\u0074e\u0064\u0020\u0065\u006c\u0065\u006de\u006et \u006f\u006e\u0020\u0043\u0054\u005f\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u0062\u006c\u0065\u0020\u0025\u0076", _cc.Name)
				if _gac := d.Skip(); _gac != nil {
					return _gac
				}
			}
		case _c.EndElement:
			break _ff
		case _c.CharData:
		}
	}
	return nil
}

type CT_CommentsExtensible struct {
	CommentExtensible []*CT_CommentExtensible
	ExtLst            *_cd.CT_ExtensionList
}

func (_bbf *CommentsExtensible) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006cn\u0073"}, Value: "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078\u006d\u006c\u006e\u0073\u003a\u0063\u0065"}, Value: "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0073"}, Value: "\u0068\u0074\u0074\u0070\u003a/\u002f\u0073\u0063\u0068\u0065m\u0061s\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067/\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002f\u0032\u0030\u0030\u0036\u002f\u0073\u0068\u0061\u0072e\u0064\u0054\u0079\u0070\u0065\u0073"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0077"}, Value: "ht\u0074\u0070:\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065s\u0073i\u006e\u0067\u006d\u006c\u002f\u0032\u0030\u00306\u002fm\u0061\u0069n"})
	start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0078m\u006c\u006e\u0073\u003a\u0078\u006dl"}, Value: "\u0068\u0074tp\u003a\u002f\u002fw\u0077\u0077\u002e\u00773.o\u0072g/\u0058\u004d\u004c\u002f\u0031\u0039\u00398/\u006e\u0061\u006d\u0065\u0073\u0070\u0061c\u0065"})
	start.Name.Local = "c\u0065\u003a\u0063\u006fmm\u0065n\u0074\u0073\u0045\u0078\u0074e\u006e\u0073\u0069\u0062\u006c\u0065"
	return _bbf.CT_CommentsExtensible.MarshalXML(e, start)
}

// Validate validates the CT_CommentsExtensible and its children
func (_ce *CT_CommentsExtensible) Validate() error {
	return _ce.ValidateWithPath("C\u0054\u005f\u0043\u006fmm\u0065n\u0074\u0073\u0045\u0078\u0074e\u006e\u0073\u0069\u0062\u006c\u0065")
}
func (_dd *CT_CommentsExtensible) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	e.EncodeToken(start)
	if _dd.CommentExtensible != nil {
		_ad := _c.StartElement{Name: _c.Name{Local: "c\u0065:\u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0045x\u0074\u0065\u006e\u0073ib\u006c\u0065"}}
		for _, _dc := range _dd.CommentExtensible {
			e.EncodeElement(_dc, _ad)
		}
	}
	if _dd.ExtLst != nil {
		_ec := _c.StartElement{Name: _c.Name{Local: "\u0063e\u003a\u0065\u0078\u0074\u004c\u0073t"}}
		e.EncodeElement(_dd.ExtLst, _ec)
	}
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}
func (_fe *CT_CommentExtensible) MarshalXML(e *_c.Encoder, start _c.StartElement) error {
	if _fe.DateUtcAttr != nil {
		start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0063\u0065\u003a\u0064\u0061\u0074\u0065\u0055\u0074\u0063"}, Value: _ed.FormatDateTime(*_fe.DateUtcAttr)})
	}
	if _fe.IntelligentPlaceholderAttr != nil {
		start.Attr = append(start.Attr, _c.Attr{Name: _c.Name{Local: "\u0063e\u003a\u0069\u006e\u0074e\u006c\u006c\u0069\u0067\u0065n\u0074P\u006ca\u0063\u0065\u0068\u006f\u006c\u0064\u0065r"}, Value: _g.Sprintf("\u0025\u0076", *_fe.IntelligentPlaceholderAttr)})
	}
	e.EncodeToken(start)
	if _fe.ExtLst != nil {
		_fd := _c.StartElement{Name: _c.Name{Local: "\u0063e\u003a\u0065\u0078\u0074\u004c\u0073t"}}
		e.EncodeElement(_fe.ExtLst, _fd)
	}
	e.EncodeToken(_c.EndElement{Name: start.Name})
	return nil
}
func NewCT_CommentsExtensible() *CT_CommentsExtensible {
	_bf := &CT_CommentsExtensible{}
	return _bf
}
func NewCT_CommentExtensible() *CT_CommentExtensible { _cb := &CT_CommentExtensible{}; return _cb }
func (_fec *CT_CommentsExtensible) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
_bb:
	for {
		_ef, _dg := d.Token()
		if _dg != nil {
			return _dg
		}
		switch _edg := _ef.(type) {
		case _c.StartElement:
			switch _edg.Name {
			case _c.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078", Local: "\u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0045\u0078\u0074\u0065\u006es\u0069\u0062\u006c\u0065"}:
				_df := NewCT_CommentExtensible()
				if _fa := d.DecodeElement(_df, &_edg); _fa != nil {
					return _fa
				}
				_fec.CommentExtensible = append(_fec.CommentExtensible, _df)
			case _c.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078", Local: "\u0065\u0078\u0074\u004c\u0073\u0074"}:
				_fec.ExtLst = _cd.NewCT_ExtensionList()
				if _ede := d.DecodeElement(_fec.ExtLst, &_edg); _ede != nil {
					return _ede
				}
			default:
				_e.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069n\u0067\u0020\u0075n\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0065\u006c\u0065\u006de\u006e\u0074\u0020\u006f\u006e C\u0054\u005f\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0045\u0078\u0074\u0065\u006e\u0073\u0069\u0062\u006c\u0065\u0020\u0025\u0076", _edg.Name)
				if _dff := d.Skip(); _dff != nil {
					return _dff
				}
			}
		case _c.EndElement:
			break _bb
		case _c.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CommentsExtensible and its children, prefixing error messages with path
func (_cdc *CommentsExtensible) ValidateWithPath(path string) error {
	if _dcd := _cdc.CT_CommentsExtensible.ValidateWithPath(path); _dcd != nil {
		return _dcd
	}
	return nil
}
func ParseUnionST_OnOff(s string) (_ed.ST_OnOff, error) { return _ed.ParseUnionST_OnOff(s) }
func (_bg *CommentsExtensible) UnmarshalXML(d *_c.Decoder, start _c.StartElement) error {
	_bg.CT_CommentsExtensible = *NewCT_CommentsExtensible()
_fde:
	for {
		_edeg, _ddc := d.Token()
		if _ddc != nil {
			return _ddc
		}
		switch _fb := _edeg.(type) {
		case _c.StartElement:
			switch _fb.Name {
			case _c.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078", Local: "\u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0045\u0078\u0074\u0065\u006es\u0069\u0062\u006c\u0065"}:
				_gf := NewCT_CommentExtensible()
				if _aa := d.DecodeElement(_gf, &_fb); _aa != nil {
					return _aa
				}
				_bg.CommentExtensible = append(_bg.CommentExtensible, _gf)
			case _c.Name{Space: "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078", Local: "\u0065\u0078\u0074\u004c\u0073\u0074"}:
				_bg.ExtLst = _cd.NewCT_ExtensionList()
				if _be := d.DecodeElement(_bg.ExtLst, &_fb); _be != nil {
					return _be
				}
			default:
				_e.Log.Debug("\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u0020\u0075\u006es\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0065l\u0065\u006d\u0065\u006e\u0074\u0020\u006f\u006e\u0020\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0045x\u0074\u0065\u006e\u0073\u0069\u0062\u006c\u0065\u0020\u0025\u0076", _fb.Name)
				if _dad := d.Skip(); _dad != nil {
					return _dad
				}
			}
		case _c.EndElement:
			break _fde
		case _c.CharData:
		}
	}
	return nil
}

// ValidateWithPath validates the CT_CommentsExtensible and its children, prefixing error messages with path
func (_gd *CT_CommentsExtensible) ValidateWithPath(path string) error {
	for _ba, _cdf := range _gd.CommentExtensible {
		if _agd := _cdf.ValidateWithPath(_g.Sprintf("\u0025s\u002f\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0045\u0078\u0074e\u006e\u0073\u0069\u0062\u006c\u0065\u005b\u0025\u0064\u005d", path, _ba)); _agd != nil {
			return _agd
		}
	}
	if _gd.ExtLst != nil {
		if _agg := _gd.ExtLst.ValidateWithPath(path + "\u002fE\u0078\u0074\u004c\u0073\u0074"); _agg != nil {
			return _agg
		}
	}
	return nil
}
func NewCommentsExtensible() *CommentsExtensible {
	_ebc := &CommentsExtensible{}
	_ebc.CT_CommentsExtensible = *NewCT_CommentsExtensible()
	return _ebc
}

// ValidateWithPath validates the CT_CommentExtensible and its children, prefixing error messages with path
func (_cf *CT_CommentExtensible) ValidateWithPath(path string) error {
	if _cf.IntelligentPlaceholderAttr != nil {
		if _edb := _cf.IntelligentPlaceholderAttr.ValidateWithPath(path + "/\u0049\u006e\u0074\u0065\u006c\u006ci\u0067\u0065\u006e\u0074\u0050\u006c\u0061\u0063\u0065h\u006f\u006c\u0064e\u0072A\u0074\u0074\u0072"); _edb != nil {
			return _edb
		}
	}
	if _cf.ExtLst != nil {
		if _da := _cf.ExtLst.ValidateWithPath(path + "\u002fE\u0078\u0074\u004c\u0073\u0074"); _da != nil {
			return _da
		}
	}
	return nil
}

type CT_CommentExtensible struct {
	DateUtcAttr                *_ab.Time
	IntelligentPlaceholderAttr *_ed.ST_OnOff
	ExtLst                     *_cd.CT_ExtensionList
}

func ParseStdlibTime(s string) (_ab.Time, error) { return _ed.ParseStdlibTime(s) }

type CommentsExtensible struct{ CT_CommentsExtensible }

// Validate validates the CommentsExtensible and its children
func (_gba *CommentsExtensible) Validate() error {
	return _gba.ValidateWithPath("\u0043o\u006dm\u0065\u006e\u0074\u0073\u0045x\u0074\u0065n\u0073\u0069\u0062\u006c\u0065")
}
func init() {
	_f.RegisterConstructor("\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078", "C\u0054\u005f\u0043\u006fmm\u0065n\u0074\u0073\u0045\u0078\u0074e\u006e\u0073\u0069\u0062\u006c\u0065", NewCT_CommentsExtensible)
	_f.RegisterConstructor("\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078", "C\u0054_\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0045x\u0074\u0065\u006e\u0073ib\u006c\u0065", NewCT_CommentExtensible)
	_f.RegisterConstructor("\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006d\u0069\u0063\u0072\u006f\u0073\u006f\u0066\u0074\u002ec\u006f\u006d\u002f\u006f\u0066fi\u0063\u0065\u002f\u0077\u006f\u0072\u0064\u002f\u0032\u0030\u0031\u0038\u002f\u0077\u006f\u0072\u0064\u006d\u006c\u002f\u0063\u0065\u0078", "\u0063o\u006dm\u0065\u006e\u0074\u0073\u0045x\u0074\u0065n\u0073\u0069\u0062\u006c\u0065", NewCommentsExtensible)
}
