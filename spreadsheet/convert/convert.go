//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

package convert

import (
	_d "github.com/unidoc/unipdf/v4/creator"
	_bg "github.com/unidoc/unipdf/v4/model"
	_ba "image"
	_e "math"
	_bf "sort"
	_g "strconv"
	_a "unioffice/common/logger"
	_gd "unioffice/common/tempstorage"
	_ec "unioffice/internal/convertutils"
	_bb "unioffice/measurement"
	_bfe "unioffice/schema/soo/dml"
	_df "unioffice/schema/soo/dml/chart"
	_gf "unioffice/schema/soo/ofc/sharedTypes"
	_c "unioffice/schema/soo/sml"
	_bc "unioffice/spreadsheet"
	_ga "unioffice/spreadsheet/formula"
	_bgg "unioffice/spreadsheet/reference"
)

func (_bgb *convertContext) makeRows() {
	_ebg := []*rowInfo{}
	_ddg := _bgb._fef.Rows()
	_gcfe := 0
	_gff := 0.0
	for _ggea, _eecd := range _ddg {
		if _ggea < _bgb._efe || (_ggea > _bgb._gffc && _bgb._gffc > 0) {
			continue
		}
		_gcfe++
		_ece := int(_eecd.RowNumber())
		if _ece > _gcfe {
			for _bce := _gcfe; _bce < _ece; _bce++ {
				_ebg = append(_ebg, &rowInfo{_fbdf: _ac / _gab})
				_gff += _ac / _gab
			}
			_gcfe = _ece
		}
		var _bga float64
		if _eecd.X().HtAttr == nil {
			_bga = _ac
		} else {
			_bga = *_eecd.X().HtAttr
		}
		_ebg = append(_ebg, &rowInfo{_fbdf: _bga / _gab, _bcbf: true, _gdd: _bgb.getStyle(_eecd.X().SAttr)})
		_gff += _bga / _gab
	}
	for _ddce := len(_ebg); _ddce < _bgb._dagbc; _ddce++ {
		_ebg = append(_ebg, &rowInfo{_fbdf: _ac / _gab})
		_gff += _ac / _gab
	}
	if _bgb._fdec || _gff >= _bgb._eefb {
		_bcc := _bgb._eecf
		if _bgb._eefb/_gff < _bgb._eecf {
			_bcc = _bgb._eefb / _gff
		}
		for _, _bbff := range _ebg {
			_bbff._fbdf *= _bcc
		}
	}
	_bgb._bcda = _ebg
}

const _f = 0.0

func (_beg *convertContext) getSymbolsFromR(_gag []*_c.CT_RElt, _gbaa *style) []*symbol {
	_cee := []*symbol{}
	for _, _cdfc := range _gag {
		_eead := _beg.combineCellStyleWithRPrElt(_gbaa, _cdfc.RPr)
		for _, _acee := range _cdfc.T {
			_cee = append(_cee, &symbol{_gbbg: string(_acee), _gfgf: _beg.makeTextStyleFromCellStyle(_eead)})
		}
	}
	return _cee
}
func (_fdd *convertContext) alignSymbolsHorizontally(_dbb *cell, _afbb _c.ST_HorizontalAlignment) {
	if _afbb == _c.ST_HorizontalAlignmentUnset {
		switch _dbb._aff {
		case _c.ST_CellTypeB:
			_afbb = _c.ST_HorizontalAlignmentCenter
		case _c.ST_CellTypeN:
			_afbb = _c.ST_HorizontalAlignmentRight
		default:
			_afbb = _c.ST_HorizontalAlignmentLeft
		}
	}
	var _fdgfb float64
	for _, _gef := range _dbb._ebd {
		switch _afbb {
		case _c.ST_HorizontalAlignmentLeft:
			_fdgfb = _fe
		case _c.ST_HorizontalAlignmentRight:
			_dgdc := _dbbe(_gef._abef)
			_fdgfb = _dbb._gdga - _fe - _dgdc
		case _c.ST_HorizontalAlignmentCenter:
			_eafe := _dbbe(_gef._abef)
			_fdgfb = (_dbb._gdga - _eafe) / 2
		}
		for _, _dcge := range _gef._abef {
			_dcge._edgd += _fdgfb
		}
	}
}

const _fe = 3

// FontStyle represents a kind of font styling. It can be FontStyle_Regular, FontStyle_Bold, FontStyle_Italic and FontStyle_BoldItalic.
type FontStyle = _ec.FontStyle

func _gcag(_fadd, _cdgf *style) {
	if _cdgf == nil {
		return
	}
	if _fadd == nil {
		_fadd = _cdgf
		return
	}
	if _fadd._bfbe == nil {
		_fadd._bfbe = _cdgf._bfbe
	}
	if _fadd._cda == nil {
		_fadd._cda = _cdgf._cda
	}
	if _fadd._geb == nil {
		_fadd._geb = _cdgf._geb
	}
	if _fadd._edbe == nil {
		_fadd._edbe = _cdgf._edbe
	}
	if _fadd._gcdc == nil {
		_fadd._gcdc = _cdgf._gcdc
	}
	if _fadd._gfb == nil {
		_fadd._gfb = _cdgf._gfb
	}
	if _fadd._fgdg == nil {
		_fadd._fgdg = _cdgf._fgdg
	}
	if _fadd._bdcd == nil {
		_fadd._bdcd = _cdgf._bdcd
	}
	if _fadd._gdg == nil {
		_fadd._gdg = _cdgf._gdg
	}
	if _fadd._deb == nil {
		_fadd._deb = _cdgf._deb
	}
	if _fadd._acg == nil {
		_fadd._acg = _cdgf._acg
	}
	if _fadd._dacg == nil {
		_fadd._dacg = _cdgf._dacg
	}
	if _fadd._caaf == nil {
		_fadd._caaf = _cdgf._caaf
	}
	if _fadd._abff == _c.ST_VerticalAlignmentUnset {
		_fadd._abff = _cdgf._abff
	}
	if _fadd._ebb == _c.ST_HorizontalAlignmentUnset {
		_fadd._ebb = _cdgf._ebb
	}
}
func (_ggc *convertContext) getSymbolsFromString(_bdcf string, _cba *style) []*symbol {
	_egdec := []*symbol{}
	_efa := _ggc.makeTextStyleFromCellStyle(_cba)
	for _, _babe := range _bdcf {
		_egdec = append(_egdec, &symbol{_gbbg: string(_babe), _gfgf: _efa})
	}
	return _egdec
}
func (_gfae *convertContext) imageFromAnchor(_ebgg *anchor, _cbad, _bac float64) _ba.Image {
	if _ebgg._gcbf != nil {
		return _ebgg._gcbf
	}
	if _ebgg._fbda != nil {
		_abec, _bae := _ec.MakeImageFromChartSpace(_ebgg._fbda, _cbad, _bac, _gfae._gdae, _gfae._agdf)
		if _bae != nil {
			_a.Log.Debug("C\u0061\u006e\u006e\u006f\u0074\u0020\u006d\u0061\u006b\u0065\u0020\u0061\u006e\u0020\u0069\u006d\u0061\u0067e\u0020\u0066\u0072\u006f\u006d\u0020\u0063\u0068\u0061\u0072tS\u0070\u0061\u0063e\u003a \u0025\u0073", _bae)
			return nil
		}
		return _abec
	}
	return nil
}
func _bca(_edfe []*symbol) float64 {
	_dade := 0.0
	for _, _aae := range _edfe {
		if _aae._feff > _dade {
			_dade = _aae._feff
		}
	}
	return _dade
}

type symbol struct {
	_gbbg string
	_edgd float64
	_feff float64
	_egb  float64
	_gfgf *_d.TextStyle
	_cfbc string
}

func (_agf *convertContext) makeRowspans() {
	var _bcd float64
	_bece := 0
	for _faf, _gfg := range _agf._bcda {
		_aedb := _gfg._fbdf + _gfg._dbbc
		if _bcd+_aedb <= _agf._eefb {
			_gfg._edbb = _bcd
			_bcd += _aedb
		} else {
			_agf._aeb = append(_agf._aeb, &rowspan{_eab: _bcd, _dcce: _bece, _accf: _faf})
			_bece = _faf
			_gfg._edbb = 0
			_bcd = _aedb
		}
	}
	_agf._aeb = append(_agf._aeb, &rowspan{_eab: _bcd, _dcce: _bece, _accf: len(_agf._bcda)})
}

const _fc = 1.5

// RegisterFont makes a PdfFont accessible for using in converting to PDF.
func RegisterFont(name string, style FontStyle, font *_bg.PdfFont) {
	_ec.RegisterFont(name, style, font)
}

const _gca = 64.0

func (_aca *convertContext) makeAnchors() {
	_ffg, _afe := _aca._fef.GetDrawing()
	if _ffg != nil {
		for _, _afa := range _ffg.EG_Anchor {
			_gge := &anchor{}
			if _ad := _afa.AnchorChoice.TwoCellAnchor; _ad != nil {
				_bfc, _ab := _ad.From, _ad.To
				if _bfc == nil || _ab == nil {
					return
				}
				_gge._eeff = int(_bfc.Row)
				_gge._fcgfd = _ec.FromSTCoordinate(_bfc.RowOff)
				_gge._dfcg = int(_bfc.Col)
				_gge._bggc = _ec.FromSTCoordinate(_bfc.ColOff)
				_gge._fba = int(_ab.Row)
				_gge._bgaf = _ec.FromSTCoordinate(_ab.RowOff)
				_gge._gedc = int(_ab.Col)
				_gge._ceg = _ec.FromSTCoordinate(_ab.ColOff)
				if _ce := _ad.ObjectChoicesChoice; _ce != nil {
					if _eec := _ce.Pic; _eec != nil {
						if _cb := _eec.BlipFill; _cb != nil {
							if _eg := _cb.Blip; _eg != nil {
								if _fed := _eg.EmbedAttr; _fed != nil {
									for _, _ggg := range _afe.X().Relationship {
										if _ggg.IdAttr == *_fed {
											for _, _fb := range _aca._agdf.Images {
												if _fb.Target() == _ggg.TargetAttr {
													_aeg, _fga := _gd.Open(_fb.Path())
													if _fga != nil {
														_a.Log.Debug("\u004fp\u0065\u006e\u0020\u0069m\u0061\u0067\u0065\u0020\u0066i\u006ce\u0020e\u0072\u0072\u006f\u0072\u003a\u0020\u0025s", _fga)
														continue
													}
													_cd, _, _fga := _ba.Decode(_aeg)
													if _fga != nil {
														_a.Log.Debug("\u0044\u0065\u0063\u006fde\u0020\u0069\u006d\u0061\u0067\u0065\u0020\u0065\u0072\u0072\u006f\u0072\u003a\u0020%\u0073", _fga)
														continue
													}
													_gge._gcbf = _cd
												}
											}
										}
									}
								}
							}
						}
					} else if _dee := _ce.GraphicFrame; _dee != nil {
						if _ea := _dee.Graphic; _ea != nil {
							if _egd := _ea.GraphicData; _egd != nil {
								for _, _bbe := range _egd.Any {
									if _fcc, _ecd := _bbe.(*_df.Chart); _ecd {
										for _, _egdf := range _afe.X().Relationship {
											if _egdf.IdAttr == _fcc.IdAttr {
												_fbf := _aca._agdf.GetChartByTargetId(_egdf.TargetAttr)
												if _fbf != nil {
													_gge._fbda = _fbf
												}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if _gge._gcbf != nil || _gge._fbda != nil {
				_aca._dggf = append(_aca._dggf, _gge)
			}
		}
	}
}
func (_gfgg *convertContext) distributeAnchors() {
	for _, _gbbe := range _gfgg._dggf {
		_ed, _dddg := _gbbe._eeff, _gbbe._fcgfd
		_fag, _edf := _gbbe._dfcg, _gbbe._bggc
		_ef, _afd := _gbbe._fba, _gbbe._bgaf
		_efd, _egg := _gbbe._gedc, _gbbe._ceg
		if _ed < _gfgg._efe || (_ef > _gfgg._gffc && _gfgg._gffc > 0) {
			continue
		}
		if _fag < _gfgg._fbfe || (_efd > _gfgg._cbe && _gfgg._cbe > 0) {
			continue
		}
		var _dac, _cbb, _fdac, _agbd *page
		for _, _bdd := range _gfgg._gcbg {
			for _, _gaa := range _bdd._cab {
				if _ed >= _gaa._bfgb._dcce && _ed < _gaa._bfgb._accf {
					if _fag >= _gaa._afce._gceg && _fag < _gaa._afce._ffba {
						_gaa._bdgf = true
						_dac = _gaa
					}
					if _efd >= _gaa._afce._gceg && _efd < _gaa._afce._ffba {
						_gaa._bdgf = true
						_cbb = _gaa
					}
				}
				if _ef >= _gaa._bfgb._dcce && _ef < _gaa._bfgb._accf {
					if _fag >= _gaa._afce._gceg && _fag < _gaa._afce._ffba {
						_gaa._bdgf = true
						_agbd = _gaa
					}
					if _efd >= _gaa._afce._gceg && _efd < _gaa._afce._ffba {
						_gaa._bdgf = true
						_fdac = _gaa
					}
				}
			}
		}
		_dgf := _dac != _cbb
		_gga := _dac != _agbd
		if _dgf && _gga {
			_acag := _gfgg._bgad[_fag]._ebba + _bb.FromEMU(_edf)
			_bgcg := _dac._afce._bbfa
			_dcg := _gfgg._bgad[_efd]._ebba + _bb.FromEMU(_egg)
			_efg := _gfgg._bcda[_ed]._edbb + _bb.FromEMU(_dddg)
			_age := float64(_dac._bfgb._eab)
			_bede := _gfgg._bcda[_ef]._edbb + _bb.FromEMU(_afd)
			_agec := _dcg + _bgcg - _acag
			_acc := _bede + _age - _efg
			_bba := _gfgg.imageFromAnchor(_gbbe, _agec, _acc)
			_dac._bfea = append(_dac._bfea, _gfgg.getImage(_bba, _acc, _agec, _acag, _efg, _bgcg-_acag, _age-_efg, _ec.ImgPart_lt))
			_cbb._bfea = append(_cbb._bfea, _gfgg.getImage(_bba, _acc, _agec, 0, _efg, _bgcg-_acag, _age-_efg, _ec.ImgPart_rt))
			_agbd._bfea = append(_agbd._bfea, _gfgg.getImage(_bba, _acc, _agec, _acag, 0, _bgcg-_acag, _age-_efg, _ec.ImgPart_lb))
			_fdac._bfea = append(_fdac._bfea, _gfgg.getImage(_bba, _acc, _agec, 0, 0, _bgcg-_acag, _age-_efg, _ec.ImgPart_rb))
		} else if _dgf {
			_ggef := _gfgg._bcda[_ed]._edbb + _bb.FromEMU(_dddg)
			_ffa := _gfgg._bcda[_ef]._edbb + _bb.FromEMU(_afd)
			_afgg := _gfgg._bgad[_fag]._ebba + _bb.FromEMU(_edf)
			_ged := _dac._afce._bbfa
			_aee := _gfgg._bgad[_efd]._ebba + _bb.FromEMU(_egg)
			_ace := _aee + _ged - _afgg
			_ddb := _ffa - _ggef
			_dfg := _gfgg.imageFromAnchor(_gbbe, _ace, _ddb)
			_dac._bfea = append(_dac._bfea, _gfgg.getImage(_dfg, _ddb, _ace, _afgg, _ggef, _ged-_afgg, 0, _ec.ImgPart_l))
			_cbb._bfea = append(_cbb._bfea, _gfgg.getImage(_dfg, _ddb, _ace, 0, _ggef, _ged-_afgg, 0, _ec.ImgPart_r))
		} else if _gga {
			_bbc := _gfgg._bgad[_fag]._ebba + _bb.FromEMU(_edf)
			_bbcg := _gfgg._bgad[_efd]._ebba + _bb.FromEMU(_egg)
			_cea := _gfgg._bcda[_ed]._edbb + _bb.FromEMU(_dddg)
			_bfa := float64(_dac._bfgb._eab)
			_add := _gfgg._bcda[_ef]._edbb + _bb.FromEMU(_afd)
			_bbd := _bbcg - _bbc
			_fafa := _add + _bfa - _cea
			_aafe := _gfgg.imageFromAnchor(_gbbe, _bbd, _fafa)
			_dac._bfea = append(_dac._bfea, _gfgg.getImage(_aafe, _fafa, _bbd, _bbc, _cea, 0, _bfa-_cea, _ec.ImgPart_t))
			_agbd._bfea = append(_agbd._bfea, _gfgg.getImage(_aafe, _fafa, _bbd, _bbc, 0, 0, _bfa-_cea, _ec.ImgPart_b))
		} else {
			_eag := _gfgg._bgad[_fag]._ebba + _bb.FromEMU(_edf)
			_gfd := _gfgg._bgad[_efd]._ebba + _bb.FromEMU(_egg)
			_gfa := _gfgg._bcda[_ed]._edbb + _bb.FromEMU(_dddg)
			_ffec := _gfgg._bcda[_ef]._edbb + _bb.FromEMU(_afd)
			_gbag := _gfd - _eag
			_def := _ffec - _gfa
			_dcgf := _gfgg.imageFromAnchor(_gbbe, _gbag, _def)
			_dac._bfea = append(_dac._bfea, _gfgg.getImage(_dcgf, _def, _gbag, _eag, _gfa, 0, 0, _ec.ImgPart_whole))
		}
	}
}
func _ffae(_dabd *symbol) {
	_fcbgg := _d.New()
	_dddb := _fcbgg.NewStyledParagraph()
	_dddb.SetMargins(0, 0, 0, 0)
	_cbfd := _dddb.Append(_dabd._gbbg)
	if _dabd._gfgf != nil {
		_cbfd.Style = *_dabd._gfgf
	}
	_dabd._feff = _dddb.Height()
	if _dabd._egb == 0 {
		_dabd._egb = _dddb.Width()
	}
}

var _gab = 3.025 / _fccg(1)

func (_dfef *convertContext) drawSheet() {
	for _ffbg, _bag := range _dfef._gcbg {
		_ccf := len(_bag._cab)
		if _ffbg == len(_dfef._gcbg)-1 {
			for _afdg := len(_bag._cab) - 1; _afdg >= 0; _afdg-- {
				if !_bag._cab[_afdg]._bdgf {
					_ccf = _afdg
				}
			}
		}
		_dag := _bag._cab[:_ccf]
		for _, _edge := range _dag {
			_dfef._gbgg.NewPage()
			_dfef.drawPage(_edge)
		}
	}
}

var _dgcd = []string{"\u0030\u0030\u0030\u0030\u0030\u0030", "\u0066\u0066\u0066\u0066\u0066\u0066", "\u0066\u0066\u0030\u0030\u0030\u0030", "\u0030\u0030\u0066\u0066\u0030\u0030", "\u0030\u0030\u0030\u0030\u0066\u0066", "\u0066\u0066\u0066\u0066\u0030\u0030", "\u0066\u0066\u0030\u0030\u0066\u0066", "\u0030\u0030\u0066\u0066\u0066\u0066", "\u0030\u0030\u0030\u0030\u0030\u0030", "\u0066\u0066\u0066\u0066\u0066\u0066", "\u0066\u0066\u0030\u0030\u0030\u0030", "\u0030\u0030\u0066\u0066\u0030\u0030", "\u0030\u0030\u0030\u0030\u0066\u0066", "\u0066\u0066\u0066\u0066\u0030\u0030", "\u0066\u0066\u0030\u0030\u0066\u0066", "\u0030\u0030\u0066\u0066\u0066\u0066", "\u0038\u0030\u0030\u0030\u0030\u0030", "\u0030\u0030\u0038\u0030\u0030\u0030", "\u0030\u0030\u0030\u0030\u0038\u0030", "\u0038\u0030\u0038\u0030\u0030\u0030", "\u0038\u0030\u0030\u0030\u0038\u0030", "\u0030\u0030\u0038\u0030\u0038\u0030", "\u0063\u0030\u0063\u0030\u0063\u0030", "\u0038\u0030\u0038\u0030\u0038\u0030", "\u0039\u0039\u0039\u0039\u0066\u0066", "\u0039\u0039\u0033\u0033\u0036\u0036", "\u0066\u0066\u0066\u0066\u0063\u0063", "\u0063\u0063\u0066\u0066\u0066\u0066", "\u0036\u0036\u0030\u0030\u0036\u0036", "\u0066\u0066\u0038\u0030\u0038\u0030", "\u0030\u0030\u0036\u0036\u0063\u0063", "\u0063\u0063\u0063\u0063\u0066\u0066", "\u0030\u0030\u0030\u0030\u0038\u0030", "\u0066\u0066\u0030\u0030\u0066\u0066", "\u0066\u0066\u0066\u0066\u0030\u0030", "\u0030\u0030\u0066\u0066\u0066\u0066", "\u0038\u0030\u0030\u0030\u0038\u0030", "\u0038\u0030\u0030\u0030\u0030\u0030", "\u0030\u0030\u0038\u0030\u0038\u0030", "\u0030\u0030\u0030\u0030\u0066\u0066", "\u0030\u0030\u0063\u0063\u0066\u0066", "\u0063\u0063\u0066\u0066\u0066\u0066", "\u0063\u0063\u0066\u0066\u0063\u0063", "\u0066\u0066\u0066\u0066\u0039\u0039", "\u0039\u0039\u0063\u0063\u0066\u0066", "\u0066\u0066\u0039\u0039\u0063\u0063", "\u0063\u0063\u0039\u0039\u0066\u0066", "\u0066\u0066\u0063\u0063\u0039\u0039", "\u0033\u0033\u0036\u0036\u0066\u0066", "\u0033\u0033\u0063\u0063\u0063\u0063", "\u0039\u0039\u0063\u0063\u0030\u0030", "\u0066\u0066\u0063\u0063\u0030\u0030", "\u0066\u0066\u0039\u0039\u0030\u0030", "\u0066\u0066\u0036\u0036\u0030\u0030", "\u0036\u0036\u0036\u0036\u0039\u0039", "\u0039\u0036\u0039\u0036\u0039\u0036", "\u0030\u0030\u0033\u0033\u0036\u0036", "\u0033\u0033\u0039\u0039\u0036\u0036", "\u0030\u0030\u0033\u0033\u0030\u0030", "\u0033\u0033\u0033\u0033\u0030\u0030", "\u0039\u0039\u0033\u0033\u0030\u0030", "\u0039\u0039\u0033\u0033\u0036\u0036", "\u0033\u0033\u0033\u0033\u0039\u0039", "\u0033\u0033\u0033\u0033\u0033\u0033"}

const _gc = 0.64

func (_aec *convertContext) makePagespans() {
	_aec._gcbg = []*pagespan{}
	_aaf := 0.0
	_aafg := 0
	for _cfb, _dad := range _aec._bgad {
		_faeg := _dad._bagf
		if _aaf+_faeg <= _aec._fbfde {
			_dad._ebba = _aaf
			_aaf += _faeg
		} else {
			_dad._ebba = 0
			_aec._gcbg = append(_aec._gcbg, &pagespan{_bbfa: _aaf, _gceg: _aafg, _ffba: _cfb})
			_aaf = _faeg
			_aafg = _cfb
		}
	}
	_aec._gcbg = append(_aec._gcbg, &pagespan{_bbfa: _aaf, _gceg: _aafg, _ffba: len(_aec._bgad)})
}
func (_abgd *convertContext) getImage(_cdde _ba.Image, _fac, _fgc, _gabe, _fdc, _ddfd, _fgdbb float64, _afga _ec.ImgPart) *_d.Image {
	_fdc += _abgd._bgdd
	_gabe += _abgd._cdca
	_adba, _cgag := _ec.GetImage(_abgd._gbgg, _cdde, _fac, _fgc, _gabe, _fdc, _ddfd, _fgdbb, _afga)
	if _cgag != nil {
		_a.Log.Debug("\u0043\u0061\u006eno\u0074\u0020\u0067\u0065\u0074\u0020\u0061\u006e\u0020\u0069\u006d\u0061\u0067\u0065\u003a\u0020\u0025\u0073", _cgag)
		return nil
	}
	return _adba
}
func (_ggdc *convertContext) getBorder(_baab *_c.CT_BorderPr) *border {
	_dadf := &border{}
	switch _baab.StyleAttr {
	case _c.ST_BorderStyleHair:
		_dadf._dbfd = _eef / 2
	case _c.ST_BorderStyleThin:
		_dadf._dbfd = _eef
	case _c.ST_BorderStyleMedium:
		_dadf._dbfd = _eef * 2
	case _c.ST_BorderStyleThick:
		_dadf._dbfd = _eef * 4
	}
	if _dadf._dbfd == 0.0 {
		return nil
	}
	if _fcbe := _baab.Color; _fcbe != nil {
		_fggf := _ggdc.getColorStringFromSmlColor(_fcbe)
		if _fggf != nil {
			_dadf._bddc = _d.ColorRGBFromHex(*_fggf)
		} else {
			_dadf._bddc = _d.ColorBlack
		}
	}
	return _dadf
}
func (_cbf *convertContext) makeCols() {
	_dab := _cbf._fef
	_bed := _dab.X()
	_dde := []*colInfo{}
	_fff := []colWidthRange{}
	if _aa := _bed.Cols; len(_aa) > 0 {
		for _, _bbf := range _aa[0].Col {
			_ege := _gca
			if _bda := _bbf.WidthAttr; _bda != nil {
				if *_bda > 0.83 {
					*_bda -= 0.83
				}
				if *_bda <= 1 {
					_ege = *_bda * 11
				} else {
					_ege = 5 + *_bda*6
				}
			}
			_ddeb := int(_bbf.MinAttr - 1)
			_db := int(_bbf.MaxAttr - 1)
			_fff = append(_fff, colWidthRange{_bfdd: _ddeb, _dbbb: _db, _gfff: _ege, _ffea: _cbf.getStyle(_bbf.StyleAttr)})
		}
	}
	_eaf := 0
	for _dfac := 0; _dfac <= _cbf._ffc; _dfac++ {
		if _dfac < _cbf._fbfe || (_dfac > _cbf._cbe && _cbf._cbe > 0) {
			continue
		}
		var _acd float64
		var _cca *style
		if len(_fff) == 0 {
			_acd = _gca
		} else if _eaf < len(_fff) {
			_ddc := _fff[_eaf]
			if _dfac >= _ddc._bfdd && _dfac <= _ddc._dbbb {
				_acd = _ddc._gfff
				_cca = _ddc._ffea
				if _dfac == _ddc._dbbb {
					_eaf++
				}
			} else {
				continue
			}
		}
		_dde = append(_dde, &colInfo{_bagf: _acd, _gdbe: _cca})
	}
	_cge := 0.0
	for _, _aag := range _dde {
		_cge += _aag._bagf
	}
	_cbf._eecf = 1.0
	if _cge > _cbf._fbfde {
		_cbf._eecf = _cbf._fbfde / _cge
		for _, _deeg := range _dde {
			_deeg._bagf *= _cbf._eecf
		}
	}
	_cbf._bgad = _dde
}
func (_fad *convertContext) fillPages() {
	for _cgd, _ccgd := range _fad._aeb {
		_adbg := _fad._bcda[_ccgd._dcce:_ccgd._accf]
		for _ebe, _ffgf := range _adbg {
			_afg := 0
			_ge := 0.0
			_bgc := []*cell{}
			if _ffgf._bcbf {
				for _, _cgf := range _ffgf._aagd {
					_aga := _fad._gcbg[_afg]
					_fad._ceae = _aga._cab[_cgd]
					_fad._ceae._bdgf = true
					_cfd := _cgf._ebda
					if _ge+_cfd > _aga._bbfa {
						_fad.addRowToPage(_bgc, _ebe)
						_bgc = []*cell{_cgf}
						_ge = _cfd
						_afg++
					} else {
						_cgf._dbeb = _ge
						_bgc = append(_bgc, _cgf)
						_ge += _cfd
					}
				}
				if len(_bgc) > 0 {
					_ebc := _fad._gcbg[_afg]
					_fad._ceae = _ebc._cab[_cgd]
					_fad._ceae._bdgf = true
					_fad.addRowToPage(_bgc, _ebe)
				}
			}
		}
	}
}

type pagespan struct {
	_bbfa float64
	_cab  []*page
	_gceg int
	_ffba int
}

// ConvertToPdfWithOptions convert a sheet to PDF with given options.
func ConvertToPdfWithOptions(s *_bc.Sheet, opts *Options) *_d.Creator {
	_gb := s.X()
	if _gb == nil {
		return nil
	}
	var _feg _d.PageSize
	_cf := true
	_de := false
	if _gb.SheetPr != nil && _gb.SheetPr.PageSetUpPr != nil && _gb.SheetPr.PageSetUpPr.FitToPageAttr != nil && *_gb.SheetPr.PageSetUpPr.FitToPageAttr {
		_de = true
	}
	if _gcb := _gb.PageSetup; _gcb != nil {
		_cf = _gcb.OrientationAttr == _c.ST_OrientationLandscape
		if _ae := _gcb.PaperSizeAttr; _ae != nil {
			_feg = _cdb[*_ae]
		}
	}
	if (_feg == _d.PageSize{}) {
		_feg = _ec.GetDefaultPageSize()
		if opts != nil && opts.DefaultPageSize != _ec.DefaultPageSize {
			_feg = _ec.GetPageDimensions(opts.DefaultPageSize)
		}
	}
	if _cf {
		_feg[0], _feg[1] = _feg[1], _feg[0]
	}
	_bfb := _d.New()
	_bfb.SetPageSize(_feg)
	var _bgf, _cfa, _bfef, _fcb float64
	if _cc := _gb.PageMargins; _cc != nil {
		_bfef = _cc.LeftAttr
		_fcb = _cc.RightAttr
		_bgf = _cc.TopAttr
		_cfa = _cc.BottomAttr
	}
	if _bfef < _ee {
		_bfef = _ee
	}
	if _fcb < _ee {
		_fcb = _ee
	}
	if _bgf < _f {
		_bgf = _f
	}
	if _cfa < _f {
		_cfa = _f
	}
	_bgf *= _bb.Inch
	_cfa *= _bb.Inch
	_bfef *= _bb.Inch
	_fcb *= _bb.Inch
	_bfb.SetPageMargins(_bfef, _fcb, _bgf, _cfa)
	_gg := s.Workbook()
	var _fg *_bfe.Theme
	if len(_gg.Themes()) > 0 {
		_fg = _gg.Themes()[0]
	}
	var _gcf, _ecc, _bd, _fa int
	for _, _gba := range _gg.DefinedNames() {
		if _gba.Name() == "\u005f\u0078l\u006e\u006d\u002eP\u0072\u0069\u006e\u0074\u005f\u0041\u0072\u0065\u0061" {
			_ag, _fca, _dfd, _gabf := _ec.ParseExcelRange(_gba.Content())
			if _gabf == nil && s.Name() == _ag {
				_gcf = int(_fca.ColumnIdx)
				_ecc = int(_dfd.ColumnIdx)
				_bd = int(_fca.RowIdx)
				_fa = int(_dfd.RowIdx)
			}
		}
	}
	_af := []_bc.Table{}
	if _gb.TableParts != nil && _gb.TableParts.TablePart != nil {
		_aed := 0
		_dd := s.Workbook().Tables()
		_bf.Slice(_dd[:], func(_bfd, _bcb int) bool { return _dd[_bfd].X().IdAttr < _dd[_bcb].X().IdAttr })
		for _, _ff := range s.Workbook().Sheets() {
			if _ff.Name() == s.Name() {
				break
			} else {
				if _ff.X().TableParts != nil && _ff.X().TableParts.TablePart != nil {
					_aed += len(_ff.X().TableParts.TablePart)
				}
			}
		}
		if len(_dd) >= _aed+len(_gb.TableParts.TablePart) {
			_af = append(_af, _dd[_aed:_aed+len(_gb.TableParts.TablePart)]...)
		}
	}
	_dg := &convertContext{_gbgg: _bfb, _fef: s, _agdf: s.Workbook(), _gdae: _fg, _ebeg: &s.Workbook().StyleSheet, _bgdd: _bgf, _cdca: _bfef, _eefb: _feg[1] - _cfa - _bgf, _fbfde: _feg[0] - _fcb - _bfef, _fbfe: _gcf, _cbe: _ecc, _efe: _bd, _gffc: _fa, _fdec: _de, _cbfg: _af}
	_dg.makeAnchors()
	_dg.determineMaxIndexes()
	if _dg._dagbc == 0 && _dg._ffc == 0 {
		_bfb.NewPage()
		return _bfb
	}
	_dg.makeCols()
	_dg.makeRows()
	_dg.makeMergedCells()
	_dg.makeCells()
	_dg.makePagespans()
	_dg.makeRowspans()
	_dg.makePages()
	_dg.fillPages()
	_dg.distributeAnchors()
	_dg.drawSheet()
	return _bfb
}
func (_gec *convertContext) addRowToPage(_dcc []*cell, _cdd int) {
	_ada := 0.0
	_deabd := _gec._fbfde
	for _, _fbfd := range _dcc {
		if len(_fbfd._ebd) != 0 {
			_fbfd._cag = _ada
			_ada = _fbfd._dbeb + _fbfd._gdga
		}
	}
	for _gcgf := len(_dcc) - 1; _gcgf >= 0; _gcgf-- {
		_gdb := _dcc[_gcgf]
		if len(_gdb._ebd) != 0 {
			_gdb._fbc = _deabd
			_deabd = _gdb._dbeb
		}
	}
	_gec._ceae._fgb = append(_gec._ceae._fgb, &pageRow{_dddd: _cdd, _gfaa: _dcc})
}

type anchor struct {
	_gcbf  _ba.Image
	_fbda  *_df.ChartSpace
	_eeff  int
	_fcgfd int64
	_dfcg  int
	_bggc  int64
	_fba   int
	_bgaf  int64
	_gedc  int
	_ceg   int64
}
type border struct {
	_dbfd float64
	_bddc _d.Color
}

var _cdb = map[uint32]_d.PageSize{1: _d.PageSize{8.5 * _bb.Inch, 11 * _bb.Inch}, 2: _d.PageSize{8.5 * _bb.Inch, 11 * _bb.Inch}, 3: _d.PageSize{11 * _bb.Inch, 17 * _bb.Inch}, 4: _d.PageSize{17 * _bb.Inch, 11 * _bb.Inch}, 5: _d.PageSize{8.5 * _bb.Inch, 14 * _bb.Inch}, 6: _d.PageSize{5.5 * _bb.Inch, 8.5 * _bb.Inch}, 7: _d.PageSize{7.5 * _bb.Inch, 10 * _bb.Inch}, 8: _d.PageSize{_fccg(297), _fccg(420)}, 9: _d.PageSize{_fccg(210), _fccg(297)}, 10: _d.PageSize{_fccg(210), _fccg(297)}, 11: _d.PageSize{_fccg(148), _fccg(210)}, 70: _d.PageSize{_fccg(105), _fccg(148)}, 12: _d.PageSize{_fccg(250), _fccg(354)}, 13: _d.PageSize{_fccg(182), _fccg(257)}, 14: _d.PageSize{8.5 * _bb.Inch, 13 * _bb.Inch}, 20: _d.PageSize{4.125 * _bb.Inch, 9.5 * _bb.Inch}, 27: _d.PageSize{_fccg(110), _fccg(220)}, 28: _d.PageSize{_fccg(162), _fccg(229)}, 34: _d.PageSize{_fccg(250), _fccg(176)}, 29: _d.PageSize{_fccg(324), _fccg(458)}, 30: _d.PageSize{_fccg(229), _fccg(324)}, 31: _d.PageSize{_fccg(114), _fccg(162)}, 37: _d.PageSize{3.88 * _bb.Inch, 7.5 * _bb.Inch}, 43: _d.PageSize{_fccg(100), _fccg(148)}, 69: _d.PageSize{_fccg(200), _fccg(148)}}

type rowInfo struct {
	_edbb float64
	_bcbf bool
	_fbdf float64
	_gdd  *style
	_aagd []*cell
	_dbbc float64
}
type line struct {
	_cgcd float64
	_abef []*symbol
	_fbfg float64
}
type style struct {
	_bfbe *string
	_geb  *string
	_edbe *float64
	_cda  *string
	_gcdc *bool
	_gfb  *bool
	_fgdg *bool
	_bdcd *bool
	_gdg  *bool
	_deb  *border
	_acg  *border
	_dacg *border
	_caaf *border
	_fcab bool
	_abff _c.ST_VerticalAlignment
	_ebb  _c.ST_HorizontalAlignment
	_agaa bool
}

func (_gaac *convertContext) getStyleFromRPrElt(_bceec *_c.CT_RPrElt) *style {
	if _bceec == nil || _bceec.RPrEltChoice == nil || len(_bceec.RPrEltChoice) == 0 {
		return nil
	}
	_acb := &style{}
	for _, _dba := range _bceec.RPrEltChoice {
		if _dba.RFont != nil {
			_acb._cda = &_dba.RFont.ValAttr
		}
		if _babcg := _dba.B; _babcg != nil {
			_fdeb := _babcg.ValAttr == nil || *_babcg.ValAttr
			_acb._gcdc = &_fdeb
		}
		if _bgbe := _dba.I; _bgbe != nil {
			_ead := _bgbe.ValAttr == nil || *_bgbe.ValAttr
			_acb._gfb = &_ead
		}
		if _bcag := _dba.U; _bcag != nil {
			_edbc := _bcag.ValAttr == _c.ST_UnderlineValuesSingle || _bcag.ValAttr == _c.ST_UnderlineValuesUnset
			_acb._fgdg = &_edbc
		}
		if _eed := _dba.VertAlign; _eed != nil {
			_afac := _eed.ValAttr == _gf.ST_VerticalAlignRunSuperscript
			_acb._bdcd = &_afac
			_cbbgb := _eed.ValAttr == _gf.ST_VerticalAlignRunSubscript
			_acb._gdg = &_cbbgb
		}
		if _bcegf := _dba.Sz; _bcegf != nil {
			_bcbee := _bcegf.ValAttr
			_acb._edbe = &_bcbee
		}
		if _fgea := _dba.Color; _fgea != nil {
			_acb._geb = _gaac.getColorStringFromSmlColor(_fgea)
		}
	}
	return _acb
}
func (_fccd *convertContext) getColorFromTheme(_beda uint32) string {
	_cbadg := _fccd._agdf.Themes()
	if len(_cbadg) != 0 {
		_eeb := _cbadg[0]
		if _dccef := _eeb.ThemeElements; _dccef != nil {
			if _cbeg := _dccef.ClrScheme; _cbeg != nil {
				switch _beda {
				case 0:
					return _ec.GetColorStringFromDmlColor(_cbeg.Lt1)
				case 1:
					return _ec.GetColorStringFromDmlColor(_cbeg.Dk1)
				case 2:
					return _ec.GetColorStringFromDmlColor(_cbeg.Lt2)
				case 3:
					return _ec.GetColorStringFromDmlColor(_cbeg.Dk2)
				case 4:
					return _ec.GetColorStringFromDmlColor(_cbeg.Accent1)
				case 5:
					return _ec.GetColorStringFromDmlColor(_cbeg.Accent2)
				case 6:
					return _ec.GetColorStringFromDmlColor(_cbeg.Accent3)
				case 7:
					return _ec.GetColorStringFromDmlColor(_cbeg.Accent4)
				case 8:
					return _ec.GetColorStringFromDmlColor(_cbeg.Accent5)
				case 9:
					return _ec.GetColorStringFromDmlColor(_cbeg.Accent6)
				}
			}
		}
	}
	return ""
}
func _fccg(_acef float64) float64 { return _acef * _bb.Millimeter }
func (_ffb *convertContext) makePages() {
	for _, _fedg := range _ffb._gcbg {
		for _, _bcg := range _ffb._aeb {
			_fedg._cab = append(_fedg._cab, &page{_fgb: []*pageRow{}, _afce: _fedg, _bfgb: _bcg})
		}
	}
}

type colWidthRange struct {
	_bfdd int
	_dbbb int
	_gfff float64
	_ffea *style
}

func _dbbe(_eeabe []*symbol) float64 {
	_edd := 0.0
	for _, _fcgf := range _eeabe {
		_edd += _fcgf._egb
	}
	return _edd
}
func _ffdg(_fgcg *bool) bool { return _fgcg != nil && *_fgcg }

const (
	FontStyle_Regular    FontStyle = 0
	FontStyle_Bold       FontStyle = 1
	FontStyle_Italic     FontStyle = 2
	FontStyle_BoldItalic FontStyle = 3
)

// ConvertToPdf converts a sheet to a PDF file. This package is beta, breaking changes can take place.
func ConvertToPdf(s *_bc.Sheet) *_d.Creator { return ConvertToPdfWithOptions(s, nil) }

type mergedCell struct {
	_cbbg  uint32
	_abdd  uint32
	_cgcaa uint32
	_feaa  uint32
	_bbca  float64
	_fggc  float64
}
type page struct {
	_fgb  []*pageRow
	_bdgf bool
	_bfea []*_d.Image
	_afce *pagespan
	_bfgb *rowspan
}

func (_afb *convertContext) makeMergedCells() {
	_fgd := []*mergedCell{}
	for _, _fd := range _afb._fef.MergedCells() {
		_cfg, _fde, _fda := _bgg.ParseRangeReference(_fd.Reference())
		if _fda != nil {
			_a.Log.Debug("\u0065\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c: \u0025\u0073", _fda)
			continue
		}
		_dfe := mergedCell{_cbbg: _cfg.RowIdx, _abdd: _cfg.ColumnIdx, _cgcaa: _fde.RowIdx, _feaa: _fde.ColumnIdx}
		for _dea := _dfe._abdd - 1; _dea < _dfe._feaa; _dea++ {
			_dfe._bbca += _afb._bgad[_dea]._bagf
		}
		for _fge := _dfe._cbbg - 1; _fge < _dfe._cgcaa; _fge++ {
			_dfe._fggc += _afb._bcda[_fge]._fbdf
		}
		_fgd = append(_fgd, &_dfe)
	}
	_afb._bfde = _fgd
}
func (_eaa *convertContext) determineMaxIndexes() {
	var _abd, _bgd int
	_abd = int(_eaa._fef.MaxColumnIdx())
	_gde := _eaa._fef.Rows()
	if len(_gde) > 0 {
		_bgd = int(_gde[len(_gde)-1].RowNumber())
	}
	for _, _be := range _eaa._dggf {
		if _be._fba >= _bgd {
			_bgd = _be._fba + 1
		}
		if _be._gedc >= _abd {
			_abd = _be._gedc + 1
		}
	}
	_eaa._dagbc = _bgd
	_eaa._ffc = _abd
}

type colInfo struct {
	_ebba float64
	_bagf float64
	_gdbe *style
}
type convertContext struct {
	_gbgg  *_d.Creator
	_agdf  *_bc.Workbook
	_gdae  *_bfe.Theme
	_fef   *_bc.Sheet
	_ebeg  *_bc.StyleSheet
	_dagbc int
	_ffc   int
	_gcbg  []*pagespan
	_ceae  *page
	_bgad  []*colInfo
	_bcda  []*rowInfo
	_aeb   []*rowspan
	_bgdd  float64
	_cdca  float64
	_eefb  float64
	_fbfde float64
	_bfde  []*mergedCell
	_dggf  []*anchor
	_eecf  float64
	_fbfe  int
	_cbe   int
	_efe   int
	_gffc  int
	_fdec  bool
	_cbfg  []_bc.Table
}

func (_egba *convertContext) makeTextStyleFromCellStyle(_bggb *style) *_d.TextStyle {
	_bea := _egba._gbgg.NewTextStyle()
	if _bggb == nil {
		_bea.FontSize = _ec.DefaultFontSize
		_bea.Font = _ec.AssignStdFontByName(_bea, _ec.StdFontsMap["\u0064e\u0066\u0061\u0075\u006c\u0074"][FontStyle_Regular])
		return &_bea
	}
	if _ffdg(_bggb._fgdg) {
		_bea.Underline = true
		_bea.UnderlineStyle = _d.TextDecorationLineStyle{Offset: 0.5, Thickness: _fccg(1 / 32)}
	}
	var _ffdc FontStyle
	if _ffdg(_bggb._gcdc) && _ffdg(_bggb._gfb) {
		_ffdc = FontStyle_BoldItalic
	} else if _ffdg(_bggb._gcdc) {
		_ffdc = FontStyle_Bold
	} else if _ffdg(_bggb._gfb) {
		_ffdc = FontStyle_Italic
	} else {
		_ffdc = FontStyle_Regular
	}
	_eccdc := "\u0064e\u0066\u0061\u0075\u006c\u0074"
	if _bggb._cda != nil {
		_eccdc = *_bggb._cda
	}
	if _gbbee, _efea := _ec.StdFontsMap[_eccdc]; _efea {
		_bea.Font = _ec.AssignStdFontByName(_bea, _gbbee[_ffdc])
	} else if _cdfce := _ec.GetRegisteredFont(_eccdc, _ffdc); _cdfce != nil {
		_bea.Font = _cdfce
	} else {
		_a.Log.Debug("\u0046\u006f\u006e\u0074\u0020\u0025\u0073\u0020\u0077\u0069\u0074h\u0020\u0073\u0074\u0079\u006c\u0065\u0020\u0025s\u0020i\u0073\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u002c\u0020\u0072\u0065\u0073\u0065\u0074 \u0074\u006f\u0020\u0064\u0065\u0066\u0061\u0075\u006c\u0074\u002e", _eccdc, _ffdc)
		_bea.Font = _ec.AssignStdFontByName(_bea, _ec.StdFontsMap["\u0064e\u0066\u0061\u0075\u006c\u0074"][_ffdc])
	}
	if _bggb._edbe != nil {
		_bea.FontSize = _e.Round(*_bggb._edbe * _egba._eecf)
	}
	if _bggb._geb != nil {
		_bea.Color = _d.ColorRGBFromHex(*_bggb._geb)
	}
	if _bggb._bdcd != nil && *_bggb._bdcd {
		_bea.FontSize *= _gc
	} else if _bggb._gdg != nil && *_bggb._gdg {
		_bea.FontSize *= _gc
	}
	return &_bea
}

type cell struct {
	_aff   _c.ST_CellType
	_gdaf  int
	_dbeb  float64
	_ebd   []*line
	_gdga  float64
	_ebda  float64
	_fbfdd float64
	_cag   float64
	_fbc   float64
	_aafef *_d.TextStyle
	_fea   *border
	_cae   *border
	_ggge  *border
	_gbd   *border
	_bcbe  bool
	_abc   bool
	_bcca  _d.Color
}
type rowspan struct {
	_eab  float64
	_dcce int
	_accf int
}

// RegisterFontsFromDirectory registers all fonts from the given directory automatically detecting font families and styles.
func RegisterFontsFromDirectory(dirName string) error { return _ec.RegisterFontsFromDirectory(dirName) }

const _da = 2

func (_fabf *convertContext) makeCells() {
	_ecb := _fabf._fef
	_ffd := _ecb.Rows()
	_acde := 0
	for _ddd, _aea := range _fabf._bcda {
		if _ddd < _fabf._efe || (_ddd > _fabf._gffc && _fabf._gffc > 0) {
			continue
		}
		_aea._aagd = []*cell{}
		_ffe := 0.0
		_gfc := _aea._gdd
		if _aea._bcbf {
			_dc := _ffd[_acde]
			_acde++
			_faba := _aea._fbdf
			for _, _abg := range _dc.Cells() {
				_bbeb, _bdg := _bgg.ParseCellReference(_abg.Reference())
				if _bdg != nil {
					_a.Log.Debug("\u0043\u0061\u006e\u006eo\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0061\u0020r\u0065f\u0065\u0072\u0065\u006e\u0063\u0065\u003a \u0025\u0073", _bdg)
					continue
				}
				if int(_bbeb.ColumnIdx) < _fabf._fbfe || (int(_bbeb.ColumnIdx) > _fabf._cbe && _fabf._cbe > 0) {
					continue
				}
				_gbf := _fabf._bgad[_bbeb.ColumnIdx]
				_afbg := _gbf._bagf
				_eee := _afbg
				_fae := _gbf._gdbe
				var _bcee, _bcec, _dgc, _eccd bool
				for _, _bec := range _fabf._bfde {
					if _bbeb.RowIdx >= _bec._cbbg && _bbeb.RowIdx <= _bec._cgcaa && _bbeb.ColumnIdx >= _bec._abdd && _bbeb.ColumnIdx <= _bec._feaa {
						if _bbeb.ColumnIdx == _bec._abdd && _bbeb.RowIdx == _bec._cbbg {
							_afbg = _bec._bbca
							_faba = _bec._fggc
						}
						_bcee = _bbeb.RowIdx != _bec._cbbg
						_bcec = _bbeb.RowIdx != _bec._cgcaa
						_dgc = _bbeb.ColumnIdx != _bec._abdd
						_eccd = _bbeb.ColumnIdx != _bec._feaa
					}
				}
				var _fbb *style
				for _, _abf := range _fabf._cbfg {
					_gce, _gcc, _dga := _bgg.ParseRangeReference(_abf.Reference())
					if _dga != nil || _gce.RowIdx > _bbeb.RowIdx || _gce.ColumnIdx > _bbeb.ColumnIdx || _gcc.RowIdx < _bbeb.RowIdx || _gcc.ColumnIdx < _bbeb.ColumnIdx || _fabf._agdf.StyleSheet.X().TableStyles == nil {
						continue
					}
					_dca := _bbeb.RowIdx == _gce.RowIdx
					for _, _gda := range _fabf._agdf.StyleSheet.X().TableStyles.TableStyle {
						if _abf.X().TableStyleInfo.NameAttr != nil && _gda.NameAttr == *_abf.X().TableStyleInfo.NameAttr {
							for _, _fee := range _gda.TableStyleElement {
								if !_dca && _fee.TypeAttr == _c.ST_TableStyleTypeWholeTable {
									_fbb = _fabf.getDxfStyle(_fee.DxfIdAttr)
								}
								if _dca && _fee.TypeAttr == _c.ST_TableStyleTypeHeaderRow {
									_fbb = _fabf.getDxfStyle(_fee.DxfIdAttr)
								}
							}
						}
					}
				}
				_fcg := _fabf.getStyleFromCell(_abg, _gfc, _fae, _fbb)
				var _agg, _gggg, _eea, _dff bool
				var _bge, _adb, _baa, _ccd *border
				var _aad _c.ST_VerticalAlignment
				var _bbb _c.ST_HorizontalAlignment
				if _fcg != nil {
					if !_bcee {
						_bge = _fcg._deb
					}
					if !_bcec {
						_adb = _fcg._acg
					}
					if !_dgc {
						_baa = _fcg._dacg
					}
					if !_eccd {
						_ccd = _fcg._caaf
					}
					if _adb != nil && _adb._dbfd > _ffe {
						_ffe = _adb._dbfd
					}
					_aad = _fcg._abff
					_bbb = _fcg._ebb
					if _fcg._bdcd != nil {
						_agg = *_fcg._bdcd
					}
					if _fcg._gdg != nil {
						_gggg = *_fcg._gdg
					}
					_eea = _fcg._fcab
					_dff = _fcg._agaa
				}
				var _bdf _d.Color
				if _fcg != nil && _fcg._bfbe != nil {
					_bdf = _d.ColorRGBFromHex(*_fcg._bfbe)
				}
				_deab, _fec := _fabf.getContentFromCell(_ecb, _abg, _fcg, _afbg, _eea, _dff)
				_gbb := &cell{_aff: _fec, _gdga: _afbg, _ebda: _eee, _fbfdd: _faba, _ebd: _deab, _fea: _bge, _cae: _adb, _ggge: _baa, _gbd: _ccd, _bcbe: _agg, _abc: _gggg, _bcca: _bdf}
				_fabf.alignSymbolsHorizontally(_gbb, _bbb)
				_fabf.alignSymbolsVertically(_gbb, _aad)
				_aea._aagd = append(_aea._aagd, _gbb)
			}
		}
		_aea._dbbc = _ffe
	}
}

const _ac = 15.0

type pageRow struct {
	_dddd int
	_gfaa []*cell
}

func (_afc *convertContext) drawPage(_agfd *page) {
	_eccc := _afc._bgdd
	_ega := _afc._cdca
	for _, _fbd := range _agfd._fgb {
		_dbf := _afc._bcda[_fbd._dddd]
		for _, _gcd := range _fbd._gfaa {
			var _feb float64
			if _fbd._dddd > 1 {
				_feb = _afc._bcda[_fbd._dddd-1]._dbbc
			}
			var _bcf, _caa float64
			if _daf := _gcd._fea; _daf != nil {
				_bcf = _daf._dbfd
			}
			if _dgca := _gcd._cae; _dgca != nil {
				_caa = _dgca._dbfd
			}
			_cgb := _eccc + _dbf._edbb - 0.5*(_feb-_bcf)
			_agc := _eccc + _dbf._edbb + _dbf._fbdf + 0.5*(_dbf._dbbc+_caa)
			_egde := _ega + _gcd._dbeb
			_ccaf := _egde + _gcd._ebda
			if _gcd._bcca != nil && _gcd._bcca != _d.ColorBlack {
				_ec.FillRectangle(_afc._gbgg, _egde, _cgb, _ccaf-_egde, _agc-_cgb, _gcd._bcca)
			}
		}
	}
	for _, _bfg := range _agfd._fgb {
		_gcg := _afc._bcda[_bfg._dddd]
		for _, _efdg := range _bfg._gfaa {
			_bbag := _efdg._cag < _efdg._dbeb
			_bab := _efdg._fbc > _efdg._dbeb+_efdg._gdga
			var _afdb, _dgd bool
			for _, _deeb := range _efdg._ebd {
				for _, _bagc := range _deeb._abef {
					if _bbag && !_afdb {
						_afdb = _bagc._edgd < 0
					}
					if _bab && !_dgd {
						_dgd = _efdg._gdga < _bagc._edgd+_bagc._egb
					}
					if _efdg._dbeb+_bagc._edgd >= _efdg._cag && _efdg._dbeb+_bagc._edgd+_bagc._egb <= _efdg._fbc {
						_ccc := _afc._gbgg.NewStyledParagraph()
						_bceg := _ega + _efdg._dbeb + _bagc._edgd
						_cgdg := _eccc + _gcg._edbb + _deeb._cgcd - _bagc._feff - _fccg(0.5)
						_ccc.SetPos(_bceg, _cgdg)
						var _afgd *_d.TextChunk
						if _bagc._cfbc != "" {
							_afgd = _ccc.AddExternalLink(_bagc._gbbg, _bagc._cfbc)
						} else {
							_afgd = _ccc.Append(_bagc._gbbg)
						}
						if _bagc._gfgf != nil {
							_afgd.Style = *_bagc._gfgf
						}
						_afc._gbgg.Draw(_ccc)
					}
				}
			}
			var _cgc, _gbbf, _eagg, _ecde, _cga, _edb float64
			var _fcbg, _babc, _cgda, _cef _d.Color
			if _gfdf := _efdg._fea; _gfdf != nil {
				_cgc = _gfdf._dbfd
				_fcbg = _gfdf._bddc
			}
			if _fged := _efdg._cae; _fged != nil {
				_gbbf = _fged._dbfd
				_babc = _fged._bddc
			}
			if _eeee := _efdg._ggge; _eeee != nil {
				_eagg = _eeee._dbfd
				_cga = _eagg / 2
				_cgda = _eeee._bddc
			}
			if _dagb := _efdg._gbd; _dagb != nil {
				_ecde = _dagb._dbfd
				_edb = _ecde / 2
				_cef = _dagb._bddc
			}
			var _eaag float64
			if _bfg._dddd > 1 {
				_eaag = _afc._bcda[_bfg._dddd-1]._dbbc
			}
			_dbe := _eccc + _gcg._edbb - 0.5*(_eaag-_cgc)
			_ecgg := _eccc + _gcg._edbb + _gcg._fbdf + 0.5*(_gcg._dbbc+_gbbf)
			_gee := _ega + _efdg._dbeb
			_dacb := _gee + _efdg._ebda
			_ec.DrawLine(_afc._gbgg, _gee, _dbe, _dacb, _dbe, _cgc, _fcbg)
			_ec.DrawLine(_afc._gbgg, _gee, _ecgg, _dacb, _ecgg, _gbbf, _babc)
			if !_afdb {
				_ec.DrawLine(_afc._gbgg, _gee-_cga, _dbe, _gee-_cga, _ecgg, _eagg, _cgda)
			}
			if !_dgd {
				_ec.DrawLine(_afc._gbgg, _dacb-_edb, _dbe, _dacb-_edb, _ecgg, _ecde, _cef)
			}
		}
	}
	for _, _abe := range _agfd._bfea {
		if _abe != nil {
			_afc._gbgg.Draw(_abe)
		}
	}
}

var _cg = _fccg(1)

func (_fadba *convertContext) combineCellStyleWithRPrElt(_ccdb *style, _beab *_c.CT_RPrElt) *style {
	_agfc := *_ccdb
	_fbe := _fadba.getStyleFromRPrElt(_beab)
	if _fbe == nil {
		return &_agfc
	}
	if _fbe._geb != nil {
		_agfc._geb = _fbe._geb
	}
	if _fbe._edbe != nil {
		_agfc._edbe = _fbe._edbe
	}
	if _fbe._cda != nil {
		_agfc._cda = _fbe._cda
	}
	if _fbe._gcdc != nil {
		_agfc._gcdc = _fbe._gcdc
	}
	if _fbe._gfb != nil {
		_agfc._gfb = _fbe._gfb
	}
	if _fbe._fgdg != nil {
		_agfc._fgdg = _fbe._fgdg
	}
	if _fbe._bdcd != nil {
		_agfc._bdcd = _fbe._bdcd
	}
	if _fbe._gdg != nil {
		_agfc._gdg = _fbe._gdg
	}
	return &_agfc
}
func (_gaea *convertContext) alignSymbolsVertically(_eeab *cell, _cfe _c.ST_VerticalAlignment) {
	var _cgff float64
	switch _cfe {
	case _c.ST_VerticalAlignmentTop:
		_cgff = _da
		if _eeab._bcbe {
			_cgff -= _fc
		} else if _eeab._abc {
			_cgff += 4 * _fc
		}
		for _, _ecbf := range _eeab._ebd {
			_cgff += _ecbf._fbfg
			_ecbf._cgcd = _cgff
			_cgff += _cg
		}
	case _c.ST_VerticalAlignmentCenter:
		_cgca := 0.0
		for _, _bcdg := range _eeab._ebd {
			_cgca += _bcdg._fbfg + _fccg(1)
		}
		_cgff = 0.5 * (_eeab._fbfdd - _cgca)
		if _eeab._bcbe {
			_cgff -= 2 * _fc
		} else if _eeab._abc {
			_cgff += 2 * _fc
		}
		for _, _eeada := range _eeab._ebd {
			_cgff += _eeada._fbfg + 0.5*_cg
			_eeada._cgcd = _cgff
			_cgff += 0.5 * _cg
		}
	default:
		_cgff = _eeab._fbfdd - _da
		if _eeab._bcbe {
			_cgff -= 4 * _fc
		} else if _eeab._abc {
			_cgff += _fc
		}
		for _dbea := len(_eeab._ebd) - 1; _dbea >= 0; _dbea-- {
			_eeab._ebd[_dbea]._cgcd = _cgff
			_cgff -= _eeab._ebd[_dbea]._fbfg
			_cgff -= _cg
		}
	}
}

var _eef = _fccg(0.0625)

func (_agecc *convertContext) getStyleFromCell(_becc _bc.Cell, _gfbc, _cdfd, _ccac *style) *style {
	if _ccac != nil {
		_gcag(_ccac, _gfbc)
		_gcag(_ccac, _cdfd)
		return _ccac
	}
	_fbg := _becc.X()
	_bggg := _agecc.getStyle(_fbg.SAttr)
	_gcag(_bggg, _gfbc)
	_gcag(_bggg, _cdfd)
	return _bggg
}
func (_gcad *convertContext) getColorStringFromSmlColor(_fgca *_c.CT_Color) *string {
	var _cgcf string
	if _fgca.RgbAttr != nil {
		_cgcf = *_fgca.RgbAttr
	} else if _fgca.IndexedAttr != nil && *_fgca.IndexedAttr < 64 {
		_cgcf = _dgcd[*_fgca.IndexedAttr]
	} else if _fgca.ThemeAttr != nil {
		_cgffb := *_fgca.ThemeAttr
		_cgcf = _gcad.getColorFromTheme(_cgffb)
	}
	if _cgcf == "" {
		return nil
	}
	if len(_cgcf) > 6 {
		_cgcf = _cgcf[(len(_cgcf) - 6):]
	}
	if _fgca.TintAttr != nil {
		_bff := *_fgca.TintAttr
		_cgcf = _ec.AdjustColorByTint(_cgcf, _bff)
	}
	_cgcf = "\u0023" + _cgcf
	return &_cgcf
}
func (_bdcde *convertContext) getDxfStyle(_gddg *uint32) *style {
	_bdae := &style{}
	_fdcf := false
	if _gddg != nil {
		var _aab *_c.CT_Dxf
		for _adf, _cgfb := range _bdcde._ebeg.X().Dxfs.Dxf {
			if uint32(_adf) == *_gddg {
				_aab = _cgfb
			}
		}
		if _aab == nil {
			return nil
		}
		if _aab.Fill != nil && _aab.Fill.FillChoice != nil && _aab.Fill.FillChoice.PatternFill != nil {
			if _aab.Fill.FillChoice.PatternFill.FgColor != nil {
				_bdae._bfbe = _bdcde.getColorStringFromSmlColor(_aab.Fill.FillChoice.PatternFill.FgColor)
			} else if _aab.Fill.FillChoice.PatternFill.BgColor != nil {
				_bdae._bfbe = _bdcde.getColorStringFromSmlColor(_aab.Fill.FillChoice.PatternFill.BgColor)
			}
		}
		_bddb := _aab.Font
		for _, _aafc := range _bddb.FontChoice {
			if _aafc.Name != nil {
				_bdae._cda = &_aafc.Name.ValAttr
				_fdcf = true
			} else if _aafc.B != nil {
				_bbfb := _aafc.B.ValAttr == nil || *_aafc.B.ValAttr
				_bdae._gcdc = &_bbfb
				_fdcf = true
			} else if _aafc.I != nil {
				_geed := _aafc.I.ValAttr == nil || *_aafc.I.ValAttr
				_bdae._gfb = &_geed
				_fdcf = true
			} else if _aafc.U != nil {
				_dbbd := _aafc.U.ValAttr == _c.ST_UnderlineValuesSingle || _aafc.U.ValAttr == _c.ST_UnderlineValuesUnset
				_bdae._fgdg = &_dbbd
				_fdcf = true
			} else if _aafc.Sz != nil {
				_afec := _aafc.Sz.ValAttr
				_bdae._edbe = &_afec
				_fdcf = true
			} else if _aafc.VertAlign != nil {
				_acgd := _aafc.VertAlign.ValAttr == _gf.ST_VerticalAlignRunSuperscript
				_bdae._bdcd = &_acgd
				_dbeg := _aafc.VertAlign.ValAttr == _gf.ST_VerticalAlignRunSubscript
				_bdae._gdg = &_dbeg
				_fdcf = true
			} else if _aafc.Color != nil {
				_bdae._geb = _bdcde.getColorStringFromSmlColor(_aafc.Color)
				_fdcf = true
			}
		}
		_fgeg := _aab.Border
		if _fgeg != nil {
			if _fgeg.Top != nil {
				_bdae._deb = _bdcde.getBorder(_fgeg.Top)
				_fdcf = true
			}
			if _fgeg.Bottom != nil {
				_bdae._acg = _bdcde.getBorder(_fgeg.Bottom)
				_fdcf = true
			}
			if _fgeg.Left != nil {
				_bdae._dacg = _bdcde.getBorder(_fgeg.Left)
				_fdcf = true
			}
			if _fgeg.Right != nil {
				_bdae._caaf = _bdcde.getBorder(_fgeg.Right)
				_fdcf = true
			}
		}
		if _aab.Alignment != nil {
			if _acgdf := _aab.Alignment.VerticalAttr; _acgdf != _c.ST_VerticalAlignmentUnset {
				_bdae._abff = _acgdf
				_fdcf = true
			}
			if _abdf := _aab.Alignment.HorizontalAttr; _abdf != _c.ST_HorizontalAlignmentUnset {
				_bdae._ebb = _abdf
				_fdcf = true
			}
		}
	}
	if _fdcf {
		return _bdae
	}
	return nil
}

// Options contains the options for convert process
type Options struct {

	// DefaultPageSize is applied when there is no page size explicitly set in the document.
	// A4 is the default option.
	DefaultPageSize _ec.PageSize
}

const _ee = 0.25

func (_bdad *convertContext) getStyle(_bfac *uint32) *style {
	_ebf := &style{}
	_bde := false
	if _bfac != nil {
		_eba := _bdad._ebeg.GetCellStyle(*_bfac)
		if _bdad._ebeg.GetNumberFormat(_eba.NumberFormat()).GetFormat() == "\u003b\u003b\u003b" {
			_ebf._agaa = true
		}
		_bfcg := _eba.GetFill()
		if _bfcg != nil && _bfcg.FillChoice != nil && _bfcg.FillChoice.PatternFill != nil {
			if _bfcg.FillChoice.PatternFill.FgColor != nil {
				_ebf._bfbe = _bdad.getColorStringFromSmlColor(_bfcg.FillChoice.PatternFill.FgColor)
			} else if _bfcg.FillChoice.PatternFill.BgColor != nil {
				_ebf._bfbe = _bdad.getColorStringFromSmlColor(_bfcg.FillChoice.PatternFill.BgColor)
			}
		}
		_gbad := _eba.GetFont()
		for _, _dbcg := range _gbad.FontChoice {
			if _dbcg.Name != nil {
				_ebf._cda = &_dbcg.Name.ValAttr
				_bde = true
			} else if _dbcg.B != nil {
				_cff := _dbcg.B.ValAttr == nil || *_dbcg.B.ValAttr
				_ebf._gcdc = &_cff
				_bde = true
			} else if _dbcg.I != nil {
				_efeag := _dbcg.I.ValAttr == nil || *_dbcg.I.ValAttr
				_ebf._gfb = &_efeag
				_bde = true
			} else if _dbcg.U != nil {
				_ecga := _dbcg.U.ValAttr == _c.ST_UnderlineValuesSingle || _dbcg.U.ValAttr == _c.ST_UnderlineValuesUnset
				_ebf._fgdg = &_ecga
				_bde = true
			} else if _dbcg.Sz != nil {
				_acgg := _dbcg.Sz.ValAttr
				_ebf._edbe = &_acgg
				_bde = true
			} else if _dbcg.VertAlign != nil {
				_aef := _dbcg.VertAlign.ValAttr == _gf.ST_VerticalAlignRunSuperscript
				_ebf._bdcd = &_aef
				_adg := _dbcg.VertAlign.ValAttr == _gf.ST_VerticalAlignRunSubscript
				_ebf._gdg = &_adg
				_bde = true
			} else if _dbcg.Color != nil {
				_ebf._geb = _bdad.getColorStringFromSmlColor(_dbcg.Color)
				_bde = true
			}
		}
		_gdda := _eba.GetBorder()
		if _gdda.Top != nil {
			_ebf._deb = _bdad.getBorder(_gdda.Top)
			_bde = true
		}
		if _gdda.Bottom != nil {
			_ebf._acg = _bdad.getBorder(_gdda.Bottom)
			_bde = true
		}
		if _gdda.Left != nil {
			_ebf._dacg = _bdad.getBorder(_gdda.Left)
			_bde = true
		}
		if _gdda.Right != nil {
			_ebf._caaf = _bdad.getBorder(_gdda.Right)
			_bde = true
		}
		if _eba.Wrapped() {
			_ebf._fcab = true
			_bde = true
		}
		if _gggd := _eba.GetVerticalAlignment(); _gggd != _c.ST_VerticalAlignmentUnset {
			_ebf._abff = _gggd
			_bde = true
		}
		if _bced := _eba.GetHorizontalAlignment(); _bced != _c.ST_HorizontalAlignmentUnset {
			_ebf._ebb = _bced
			_bde = true
		}
	}
	if _bde {
		return _ebf
	}
	return nil
}
func (_gea *convertContext) getContentFromCell(_cgea *_bc.Sheet, _ggf _bc.Cell, _ecdc *style, _ddfe float64, _bdge, _ced bool) ([]*line, _c.ST_CellType) {
	if _ced {
		return []*line{}, _c.ST_CellTypeS
	}
	_dbc := _ggf.X()
	var _fadb []*symbol
	switch _dbc.TAttr {
	case _c.ST_CellTypeS:
		_ecgf := _dbc.V
		if _ecgf != nil {
			_bdaf, _bbgc := _g.Atoi(*_ecgf)
			if _bbgc == nil {
				_fgdb := _gea._agdf.SharedStrings.X().Si[_bdaf]
				if _fgdb.T != nil {
					_fadb = _gea.getSymbolsFromString(*_fgdb.T, _ecdc)
				} else if _fgdb.R != nil {
					_fadb = _gea.getSymbolsFromR(_fgdb.R, _ecdc)
				}
			}
		}
	case _c.ST_CellTypeB:
		_agd := _dbc.V
		if _agd != nil {
			if *_agd == "\u0030" {
				_fadb = _gea.getSymbolsFromString("\u0046\u0041\u004cS\u0045", _ecdc)
			} else {
				_fadb = _gea.getSymbolsFromString("\u0054\u0052\u0055\u0045", _ecdc)
			}
		}
	case _c.ST_CellTypeStr:
		if _dbc.F != nil {
			_gcgd := _ga.NewEvaluator()
			_cdg := _cgea.FormulaContext().Cell(_ggf.Reference(), _gcgd)
			_fadb = _gea.getSymbolsFromString(_cdg.Value(), _ecdc)
		}
	default:
		_fadb = _gea.getSymbolsFromString(_ggf.GetFormattedValue(), _ecdc)
	}
	_fecg := 0.0
	_aegg := 0.0
	var _geg []*line
	var _fgg bool
	if _ecdc != nil {
		if _ecdc._bdcd != nil {
			if *_ecdc._bdcd {
				_fgg = true
			}
		}
		if _ecdc._gdg != nil {
			if *_ecdc._gdg {
				_fgg = true
			}
		}
	}
	if _bdge {
		_geg = []*line{}
		_bdc := _ddfe - 2*_fe
		_abb := []*symbol{}
		for _, _gae := range _fadb {
			_ffae(_gae)
			if _fecg+_gae._egb >= _bdc {
				_fege := _bca(_abb)
				if _fgg {
					_fege /= _gc
				}
				_geg = append(_geg, &line{_cgcd: _aegg, _abef: _abb, _fbfg: _fege})
				_abb = []*symbol{_gae}
				_fecg = _gae._egb
				_aegg += _fege
			} else {
				_gae._edgd = _fecg
				_fecg += _gae._egb
				_abb = append(_abb, _gae)
			}
		}
		_egc := _bca(_abb)
		if _fgg {
			_egc /= _gc
		}
		if len(_abb) > 0 {
			_geg = append(_geg, &line{_cgcd: _aegg, _abef: _abb, _fbfg: _egc})
		}
	} else {
		for _, _bfcf := range _fadb {
			_ffae(_bfcf)
			_bfcf._edgd = _fecg
			_fecg += _bfcf._egb
		}
		if len(_fadb) > 0 {
			_geg = []*line{&line{_abef: _fadb, _fbfg: _bca(_fadb)}}
		}
	}
	_dgdf := _dbc.TAttr
	if _dgdf == _c.ST_CellTypeUnset {
		_dgdf = _c.ST_CellTypeN
	}
	return _geg, _dgdf
}
