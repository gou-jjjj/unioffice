//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Package format provides support for parsing and evaluating
// spreadsheetml/Excel number formats.
//
// Internally spreadsheets store numbers and dates values as a text
// representation of a floating point number (e.g. 1.2345).  This number is then
// displayed in Excel or another spreadsheet viewer differently depending on the
// number fornat of the cell style applied to the cell.
//
// As an example, the same value of 1.2345 can be displayed as:
// - "1" with format "0"
// - "1.2" with format "0.0"
// - "1.23" with format "0.00"
// - "1.235" with format "0.000"
// - "123%" with format "0%"
// - "1 23/100" with fornat "0 0/100"
// - "1.23E+00" with format "0.00E+00"
// - "29:37:41s" with format `[h]:mm:ss"s"`
package format

import (
	_c "bytes"
	_b "fmt"
	_e "io"
	_gg "math"
	_eb "strconv"
	_g "strings"
	_ac "time"
	_ee "unioffice/common/logger"
)

// Number is used to format a number with a format string.  If the format
// string is empty, then General number formatting is used which attempts to mimic
// Excel's general formatting.
func Number(v float64, f string) string {
	if f == "" || f == "\u0047e\u006e\u0065\u0072\u0061\u006c" || f == "\u0040" {
		return NumberGeneric(v)
	}
	_ab := Parse(f)
	if len(_ab) == 1 {
		return _be(v, _ab[0], false)
	} else if len(_ab) > 1 && v < 0 {
		return _be(v, _ab[1], true)
	} else if len(_ab) > 2 && v == 0 {
		return _be(v, _ab[2], false)
	}
	return _be(v, _ab[0], false)
}
func _ebg(_dbc int64) int64 {
	if _dbc < 0 {
		return -_dbc
	}
	return _dbc
}
func IsNumber(data string) (_gdb bool) {
	_fdf, _ebf, _dda := 0, 0, len(data)
	_gcd := len(data)
	_eaf, _gcag, _aad := 0, 0, 0
	_ = _gcag
	_ = _aad
	_ = _eaf
	{
		_fdf = _afff
		_eaf = 0
		_gcag = 0
		_aad = 0
	}
	{
		if _ebf == _dda {
			goto _fgfd
		}
		switch _fdf {
		case 0:
			goto _cad
		case 1:
			goto _dfd
		case 2:
			goto _ebd
		case 3:
			goto _beeg
		case 4:
			goto _fcf
		case 5:
			goto _fcec
		case 6:
			goto _fbd
		case 7:
			goto _gbf
		}
		goto _ggf
	_ccf:
		_gcag = _ebf
		_ebf--
		{
			_gdb = false
		}
		goto _fbc
	_gbd:
		_gcag = _ebf
		_ebf--
		{
			_gdb = _gcag == len(data)
		}
		goto _fbc
	_fccd:
		_gcag = _ebf
		_ebf--
		{
			_gdb = _gcag == len(data)
		}
		goto _fbc
	_afce:
		switch _aad {
		case 2:
			{
				_ebf = (_gcag) - 1
				_gdb = _gcag == len(data)
			}
		case 3:
			{
				_ebf = (_gcag) - 1
				_gdb = false
			}
		}
		goto _fbc
	_fbc:
		_eaf = 0
		if _ebf++; _ebf == _dda {
			goto _ddc
		}
	_cad:
		_eaf = _ebf
		switch data[_ebf] {
		case 43:
			goto _fca
		case 45:
			goto _fca
		}
		if 48 <= data[_ebf] && data[_ebf] <= 57 {
			goto _acac
		}
		goto _efc
	_efc:
		if _ebf++; _ebf == _dda {
			goto _faf
		}
	_dfd:
		goto _efc
	_fca:
		if _ebf++; _ebf == _dda {
			goto _fed
		}
	_ebd:
		if 48 <= data[_ebf] && data[_ebf] <= 57 {
			goto _acac
		}
		goto _efc
	_acac:
		if _ebf++; _ebf == _dda {
			goto _aaaa
		}
	_beeg:
		if data[_ebf] == 46 {
			goto _bfc
		}
		if 48 <= data[_ebf] && data[_ebf] <= 57 {
			goto _acac
		}
		goto _efc
	_bfc:
		if _ebf++; _ebf == _dda {
			goto _ded
		}
	_fcf:
		if 48 <= data[_ebf] && data[_ebf] <= 57 {
			goto _bfe
		}
		goto _efc
	_bfe:
		if _ebf++; _ebf == _dda {
			goto _cab
		}
	_fcec:
		if data[_ebf] == 69 {
			goto _fac
		}
		if 48 <= data[_ebf] && data[_ebf] <= 57 {
			goto _bfe
		}
		goto _efc
	_fac:
		if _ebf++; _ebf == _dda {
			goto _eae
		}
	_fbd:
		switch data[_ebf] {
		case 43:
			goto _acab
		case 45:
			goto _acab
		}
		goto _efc
	_acab:
		_gcag = _ebf + 1
		_aad = 3
		goto _gccg
	_ceda:
		_gcag = _ebf + 1
		_aad = 2
		goto _gccg
	_gccg:
		if _ebf++; _ebf == _dda {
			goto _gcagc
		}
	_gbf:
		if 48 <= data[_ebf] && data[_ebf] <= 57 {
			goto _ceda
		}
		goto _efc
	_ggf:
	_ddc:
		_fdf = 0
		goto _fgfd
	_faf:
		_fdf = 1
		goto _fgfd
	_fed:
		_fdf = 2
		goto _fgfd
	_aaaa:
		_fdf = 3
		goto _fgfd
	_ded:
		_fdf = 4
		goto _fgfd
	_cab:
		_fdf = 5
		goto _fgfd
	_eae:
		_fdf = 6
		goto _fgfd
	_gcagc:
		_fdf = 7
		goto _fgfd
	_fgfd:
		{
		}
		if _ebf == _gcd {
			switch _fdf {
			case 1:
				goto _ccf
			case 2:
				goto _ccf
			case 3:
				goto _gbd
			case 4:
				goto _ccf
			case 5:
				goto _fccd
			case 6:
				goto _ccf
			case 7:
				goto _afce
			}
		}
	}
	if _fdf == _eee {
		return false
	}
	return
}

const _eee int = -1

// Token is a format token in the Excel format string.
type Token struct {
	Type     FmtType
	Literal  byte
	DateTime string
}

func Parse(s string) []Format {
	_fae := Lexer{}
	_fae.Lex(_g.NewReader(s))
	_fae._ecac = append(_fae._ecac, _fae._cce)
	return _fae._ecac
}

const _fc = 1e11

func _be(_ga float64, _cda Format, _dbf bool) string {
	if _cda._aa {
		return NumberGeneric(_ga)
	}
	_cfd := make([]byte, 0, 20)
	_cgf := _gg.Signbit(_ga)
	_gge := _gg.Abs(_ga)
	_ceb := int64(0)
	_fa := int64(0)
	if _cda.IsExponential {
		for _gge >= 10 {
			_fa++
			_gge /= 10
		}
		for _gge < 1 {
			_fa--
			_gge *= 10
		}
	} else if _cda._ec {
		_gge *= 100
	} else if _cda._fcc {
		if _cda._cc == 0 {
			_ggbe := _gg.Pow(10, float64(_cda._dg))
			_bg, _bga := 1.0, 1.0
			_ = _bg
			for _efe := 1.0; _efe < _ggbe; _efe++ {
				_, _cdd := _gg.Modf(_gge * float64(_efe))
				if _cdd < _bga {
					_bga = _cdd
					_bg = _efe
					if _cdd == 0 {
						break
					}
				}
			}
			_cda._cc = int64(_bg)
		}
		_ceb = int64(_gge*float64(_cda._cc) + 0.5)
		if len(_cda.Whole) > 0 && _ceb > _cda._cc {
			_ceb = int64(_gge*float64(_cda._cc)) % _cda._cc
			_gge -= float64(_ceb) / float64(_cda._cc)
		} else {
			_gge -= float64(_ceb) / float64(_cda._cc)
			if _gg.Abs(_gge) < 1 {
				_aeg := true
				for _, _aca := range _cda.Whole {
					if _aca.Type == FmtTypeDigitOpt {
						continue
					}
					if _aca.Type == FmtTypeLiteral && _aca.Literal == ' ' {
						continue
					}
					_aeg = false
				}
				if _aeg {
					_cda.Whole = nil
				}
			}
		}
	}
	_gad := 1
	for _, _acc := range _cda.Fractional {
		if _acc.Type == FmtTypeDigit || _acc.Type == FmtTypeDigitOpt {
			_gad++
		}
	}
	_gge += 5 * _gg.Pow10(-_gad)
	_bac, _ged := _gg.Modf(_gge)
	_cfd = append(_cfd, _fe(_bac, _ga, _cda)...)
	_cfd = append(_cfd, _ag(_ged, _ga, _cda)...)
	_cfd = append(_cfd, _fgg(_fa, _cda)...)
	if _cda._fcc {
		_cfd = _eb.AppendInt(_cfd, _ceb, 10)
		_cfd = append(_cfd, '/')
		_cfd = _eb.AppendInt(_cfd, _cda._cc, 10)
	}
	if !_dbf && _cgf {
		return "\u002d" + string(_cfd)
	}
	return string(_cfd)
}
func _ag(_feg, _age float64, _bed Format) []byte {
	if len(_bed.Fractional) == 0 {
		return nil
	}
	_accb := _eb.AppendFloat(nil, _feg, 'f', -1, 64)
	if len(_accb) > 2 {
		_accb = _accb[2:]
	} else {
		_accb = nil
	}
	_afe := make([]byte, 0, len(_accb))
	_afe = append(_afe, '.')
	_ede := 0
_dde:
	for _afc := 0; _afc < len(_bed.Fractional); _afc++ {
		_bc := _afc
		_fd := _bed.Fractional[_afc]
		switch _fd.Type {
		case FmtTypeDigit:
			if _bc < len(_accb) {
				_afe = append(_afe, _accb[_bc])
				_ede++
			} else {
				_afe = append(_afe, '0')
			}
		case FmtTypeDigitOpt:
			if _bc >= 0 {
				_afe = append(_afe, _accb[_bc])
				_ede++
			} else {
				break _dde
			}
		case FmtTypeLiteral:
			_afe = append(_afe, _fd.Literal)
		default:
			_ee.Log.Debug("\u0075\u006e\u0073\u0075\u0070\u0070o\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020f\u0072\u0061\u0063\u0074\u0069\u006f\u006ea\u006c\u0020\u0025\u0076", _fd)
		}
	}
	return _afe
}

const _cgc int = -1

// FmtType is the type of a format token.
//
//go:generate stringer -type=FmtType
type FmtType byte

func _ebed(_efee []byte) []byte {
	_faa := len(_efee)
	_gca := false
	_bgg := false
	for _bf := len(_efee) - 1; _bf >= 0; _bf-- {
		if _efee[_bf] == '0' && !_bgg && !_gca {
			_faa = _bf
		} else if _efee[_bf] == '.' {
			_gca = true
		} else {
			_bgg = true
		}
	}
	if _gca && _bgg {
		if _efee[_faa-1] == '.' {
			_faa--
		}
		return _efee[0:_faa]
	}
	return _efee
}

const (
	FmtTypeLiteral FmtType = iota
	FmtTypeDigit
	FmtTypeDigitOpt
	FmtTypeComma
	FmtTypeDecimal
	FmtTypePercent
	FmtTypeDollar
	FmtTypeDigitOptThousands
	FmtTypeUnderscore
	FmtTypeDate
	FmtTypeTime
	FmtTypeFraction
	FmtTypeText
)
const _dbe int = 0

// Format is a parsed number format.
type Format struct {
	Whole         []Token
	Fractional    []Token
	Exponent      []Token
	IsExponential bool
	_fcc          bool
	_ec           bool
	_aa           bool
	_fg           bool
	_aaa          bool
	_d            bool
	_cc           int64
	_dg           int
}

func _fgg(_eaa int64, _cag Format) []byte {
	if !_cag.IsExponential || len(_cag.Exponent) == 0 {
		return nil
	}
	_agg := _eb.AppendInt(nil, _ebg(_eaa), 10)
	_edg := make([]byte, 0, len(_agg)+2)
	_edg = append(_edg, 'E')
	if _eaa >= 0 {
		_edg = append(_edg, '+')
	} else {
		_edg = append(_edg, '-')
		_eaa *= -1
	}
	_ffd := 0
_gadg:
	for _afeb := len(_cag.Exponent) - 1; _afeb >= 0; _afeb-- {
		_afg := len(_agg) - 1 - _ffd
		_bdbb := _cag.Exponent[_afeb]
		switch _bdbb.Type {
		case FmtTypeDigit:
			if _afg >= 0 {
				_edg = append(_edg, _agg[_afg])
				_ffd++
			} else {
				_edg = append(_edg, '0')
			}
		case FmtTypeDigitOpt:
			if _afg >= 0 {
				_edg = append(_edg, _agg[_afg])
				_ffd++
			} else {
				for _cbd := _afeb; _cbd >= 0; _cbd-- {
					_ccaa := _cag.Exponent[_cbd]
					if _ccaa.Type == FmtTypeLiteral {
						_edg = append(_edg, _ccaa.Literal)
					}
				}
				break _gadg
			}
		case FmtTypeLiteral:
			_edg = append(_edg, _bdbb.Literal)
		default:
			_ee.Log.Debug("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0079\u0070\u0065\u0020\u0069\u006e\u0020\u0065\u0078p\u0020\u0025\u0076", _bdbb)
		}
	}
	if _ffd < len(_agg) {
		_edg = append(_edg, _agg[len(_agg)-_ffd-1:_ffd-1]...)
	}
	_gcc(_edg[2:])
	return _edg
}

type Lexer struct {
	_cce  Format
	_ecac []Format
}

func _gcc(_gcb []byte) []byte {
	for _cf := 0; _cf < len(_gcb)/2; _cf++ {
		_ef := len(_gcb) - 1 - _cf
		_gcb[_cf], _gcb[_ef] = _gcb[_ef], _gcb[_cf]
	}
	return _gcb
}

const _fegc int = 34

func _fb(_fde []byte) []byte {
	for _ad := len(_fde) - 1; _ad > 0; _ad-- {
		if _fde[_ad] == '9'+1 {
			_fde[_ad] = '0'
			if _fde[_ad-1] == '.' {
				_ad--
			}
			_fde[_ad-1]++
		}
	}
	if _fde[0] == '9'+1 {
		_fde[0] = '0'
		copy(_fde[1:], _fde[0:])
		_fde[0] = '1'
	}
	return _fde
}

// NumberGeneric formats the number with the generic format which attemps to
// mimic Excel's general formatting.
func NumberGeneric(v float64) string {
	if _gg.Abs(v) >= _fc || _gg.Abs(v) <= _bd && v != 0 {
		return _feb(v)
	}
	_edf := make([]byte, 0, 15)
	_edf = _eb.AppendFloat(_edf, v, 'f', -1, 64)
	if len(_edf) > 11 {
		_gee := _edf[11] - '0'
		if _gee >= 5 && _gee <= 9 {
			_edf[10]++
			_edf = _edf[0:11]
			_edf = _fb(_edf)
		}
		_edf = _edf[0:11]
	} else if len(_edf) == 11 {
		if _edf[len(_edf)-1] == '9' {
			_edf[len(_edf)-1]++
			_edf = _fb(_edf)
		}
	}
	_edf = _ebed(_edf)
	return string(_edf)
}
func _fe(_gd, _dae float64, _cfb Format) []byte {
	if len(_cfb.Whole) == 0 {
		return nil
	}
	_eg := _ac.Date(1899, 12, 30, 0, 0, 0, 0, _ac.UTC)
	_gb := _eg.Add(_ac.Duration(_dae * float64(24*_ac.Hour)))
	_gb = _gged(_gb)
	_ebe := _eb.AppendFloat(nil, _gd, 'f', -1, 64)
	_caf := make([]byte, 0, len(_ebe))
	_df := 0
	_afa := 1
_gdg:
	for _dfc := len(_cfb.Whole) - 1; _dfc >= 0; _dfc-- {
		_gba := len(_ebe) - 1 - _df
		_ced := _cfb.Whole[_dfc]
		switch _ced.Type {
		case FmtTypeDigit:
			if _gba >= 0 {
				_caf = append(_caf, _ebe[_gba])
				_df++
				_afa = _dfc
			} else {
				_caf = append(_caf, '0')
			}
		case FmtTypeDigitOpt:
			if _gba >= 0 {
				_caf = append(_caf, _ebe[_gba])
				_df++
				_afa = _dfc
			} else {
				for _ff := _dfc; _ff >= 0; _ff-- {
					_cb := _cfb.Whole[_ff]
					if _cb.Type == FmtTypeLiteral {
						_caf = append(_caf, _cb.Literal)
					}
				}
				break _gdg
			}
		case FmtTypeDollar:
			for _edb := _df; _edb < len(_ebe); _edb++ {
				_caf = append(_caf, _ebe[len(_ebe)-1-_edb])
				_df++
			}
			_caf = append(_caf, '$')
		case FmtTypeComma:
			if !_cfb._fg {
				_caf = append(_caf, ',')
			}
		case FmtTypeLiteral:
			_caf = append(_caf, _ced.Literal)
		case FmtTypeDate:
			_caf = append(_caf, _gcc(_ecf(_gb, _ced.DateTime))...)
		case FmtTypeTime:
			_caf = append(_caf, _gcc(_bcc(_gb, _dae, _ced.DateTime))...)
		default:
			_ee.Log.Debug("\u0075\u006e\u0073\u0075p\u0070\u006f\u0072\u0074\u0065\u0064\u0020\u0074\u0079\u0070e\u0020i\u006e\u0020\u0077\u0068\u006f\u006c\u0065 \u0025\u0076", _ced)
		}
	}
	_eag := _gcc(_caf)
	if _df < len(_ebe) && (_df != 0 || _cfb._d) {
		_ggeg := len(_ebe) - _df
		_bee := make([]byte, len(_eag)+_ggeg)
		copy(_bee, _eag[0:_afa])
		copy(_bee[_afa:], _ebe[0:])
		copy(_bee[_afa+_ggeg:], _eag[_afa:])
		_eag = _bee
	}
	if _cfb._fg {
		_aaf := _c.Buffer{}
		_cca := 0
		for _beg := len(_eag) - 1; _beg >= 0; _beg-- {
			if !(_eag[_beg] >= '0' && _eag[_beg] <= '9') {
				_cca++
			} else {
				break
			}
		}
		for _gbc := 0; _gbc < len(_eag); _gbc++ {
			_bdb := (len(_eag) - _gbc - _cca)
			if _bdb%3 == 0 && _bdb != 0 && _gbc != 0 {
				_aaf.WriteByte(',')
			}
			_aaf.WriteByte(_eag[_gbc])
		}
		_eag = _aaf.Bytes()
	}
	return _eag
}

var _f = [...]uint8{0, 14, 26, 41, 53, 67, 81, 94, 118, 135, 146, 157, 172, 183}

const _ba = "\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u004c\u0069\u0074\u0065\u0072a\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0069\u0067\u0069\u0074\u0046\u006d\u0074\u0054y\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0043o\u006d\u006d\u0061\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0044\u0065\u0063\u0069\u006da\u006c\u0046\u006d\u0074\u0054\u0079\u0070\u0065Pe\u0072\u0063e\u006e\u0074\u0046\u006d\u0074\u0054\u0079\u0070e\u0044\u006f\u006c\u006c\u0061\u0072\u0046\u006d\u0074Ty\u0070\u0065\u0044i\u0067\u0069\u0074\u004f\u0070\u0074\u0054\u0068\u006f\u0075\u0073\u0061n\u0064\u0073\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0055n\u0064\u0065\u0072\u0073c\u006f\u0072\u0065\u0046\u006d\u0074T\u0079\u0070\u0065\u0044\u0061\u0074\u0065\u0046\u006d\u0074\u0054y\u0070e\u0054\u0069\u006d\u0065\u0046\u006d\u0074\u0054\u0079\u0070\u0065\u0046\u0072\u0061\u0063t\u0069\u006f\u006e\u0046\u006dt\u0054\u0079\u0070\u0065\u0054e\u0078\u0074"

func (_abb *Lexer) Lex(r _e.Reader) {
	_dfe, _dad, _bfb := 0, 0, 0
	_facg := -1
	_cfbe, _bef, _cgcb := 0, 0, 0
	_ = _bef
	_ = _cgcb
	_bdbg := 1
	_ = _bdbg
	_daf := make([]byte, 4096)
	_cbdd := false
	for !_cbdd {
		_cdg := 0
		if _cfbe > 0 {
			_cdg = _dad - _cfbe
		}
		_dad = 0
		_gde, _fef := r.Read(_daf[_cdg:])
		if _gde == 0 || _fef != nil {
			_cbdd = true
		}
		_bfb = _gde + _cdg
		if _bfb < len(_daf) {
			_facg = _bfb
		}
		{
			_dfe = _afb
			_cfbe = 0
			_bef = 0
			_cgcb = 0
		}
		{
			if _dad == _bfb {
				goto _eccd
			}
			switch _dfe {
			case 34:
				goto _cfc
			case 35:
				goto _bgaf
			case 0:
				goto _ccc
			case 36:
				goto _bgge
			case 37:
				goto _bbb
			case 1:
				goto _dcd
			case 2:
				goto _eea
			case 38:
				goto _fgb
			case 3:
				goto _bafb
			case 4:
				goto _ebc
			case 39:
				goto _eebb
			case 5:
				goto _adec
			case 6:
				goto _cec
			case 7:
				goto _acbf
			case 8:
				goto _egg
			case 40:
				goto _fcad
			case 9:
				goto _aga
			case 41:
				goto _cgd
			case 10:
				goto _bafa
			case 42:
				goto _bccg
			case 11:
				goto _efb
			case 43:
				goto _fcfd
			case 44:
				goto _gfbg
			case 45:
				goto _aafa
			case 12:
				goto _efg
			case 46:
				goto _babc
			case 13:
				goto _cefd
			case 14:
				goto _fbg
			case 15:
				goto _cbf
			case 16:
				goto _gaea
			case 47:
				goto _ddeb
			case 17:
				goto _eeed
			case 48:
				goto _afbd
			case 18:
				goto _gaf
			case 19:
				goto _ffc
			case 20:
				goto _bggd
			case 49:
				goto _gec
			case 50:
				goto _eda
			case 21:
				goto _cage
			case 22:
				goto _beegf
			case 23:
				goto _dge
			case 24:
				goto _dec
			case 25:
				goto _cbba
			case 51:
				goto _fda
			case 26:
				goto _fbfd
			case 52:
				goto _gffc
			case 53:
				goto _acg
			case 54:
				goto _fcfa
			case 55:
				goto _cafg
			case 56:
				goto _fbfc
			case 57:
				goto _dcfb
			case 27:
				goto _gadd
			case 28:
				goto _dgeg
			case 29:
				goto _eafd
			case 30:
				goto _eafa
			case 31:
				goto _acfa
			case 58:
				goto _ege
			case 32:
				goto _bbc
			case 59:
				goto _fddd
			case 33:
				goto _cgcc
			case 60:
				goto _ffca
			case 61:
				goto _agb
			case 62:
				goto _aege
			}
			goto _febf
		_gac:
			switch _cgcb {
			case 2:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypeDigit, nil)
				}
			case 3:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypeDigitOpt, nil)
				}
			case 5:
				{
					_dad = (_bef) - 1
				}
			case 8:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypePercent, nil)
				}
			case 13:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypeFraction, _daf[_cfbe:_bef])
				}
			case 14:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypeDate, _daf[_cfbe:_bef])
				}
			case 15:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypeTime, _daf[_cfbe:_bef])
				}
			case 16:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypeTime, _daf[_cfbe:_bef])
				}
			case 18:
				{
					_dad = (_bef) - 1
				}
			case 20:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypeLiteral, _daf[_cfbe:_bef])
				}
			case 21:
				{
					_dad = (_bef) - 1
					_abb._cce.AddToken(FmtTypeLiteral, _daf[_cfbe+1:_bef-1])
				}
			}
			goto _cfgd
		_eeg:
			_dad = (_bef) - 1
			{
				_abb._cce.AddToken(FmtTypeFraction, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_gfb:
			_dad = (_bef) - 1
			{
				_abb._cce.AddToken(FmtTypeDigitOpt, nil)
			}
			goto _cfgd
		_cef:
			_bef = _dad + 1
			{
				_abb._cce.AddToken(FmtTypeDigitOptThousands, nil)
			}
			goto _cfgd
		_ece:
			_dad = (_bef) - 1
			{
				_abb._cce.AddToken(FmtTypePercent, nil)
			}
			goto _cfgd
		_aed:
			_dad = (_bef) - 1
			{
				_abb._cce.AddToken(FmtTypeDate, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_geed:
			_dad = (_bef) - 1
			{
				_abb._cce.AddToken(FmtTypeDigit, nil)
			}
			goto _cfgd
		_bae:
			_dad = (_bef) - 1
			{
				_abb._cce.AddToken(FmtTypeTime, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_ecc:
			_dad = (_bef) - 1
			{
				_abb._cce.AddToken(FmtTypeLiteral, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_acb:
			_bef = _dad + 1
			{
				_abb._cce._aa = true
			}
			goto _cfgd
		_ccfg:
			_bef = _dad + 1
			{
				_abb._cce.AddToken(FmtTypeLiteral, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_eba:
			_bef = _dad + 1
			{
				_abb._cce.AddToken(FmtTypeDollar, nil)
			}
			goto _cfgd
		_gcca:
			_bef = _dad + 1
			{
				_abb._cce.AddToken(FmtTypeComma, nil)
			}
			goto _cfgd
		_fdfe:
			_bef = _dad + 1
			{
				_abb._cce.AddToken(FmtTypeDecimal, nil)
			}
			goto _cfgd
		_egd:
			_bef = _dad + 1
			{
				_abb.nextFmt()
			}
			goto _cfgd
		_adb:
			_bef = _dad + 1
			{
				_abb._cce.AddToken(FmtTypeText, nil)
			}
			goto _cfgd
		_dadf:
			_bef = _dad + 1
			{
				_abb._cce.AddToken(FmtTypeUnderscore, nil)
			}
			goto _cfgd
		_abbb:
			_bef = _dad
			_dad--
			{
				_abb._cce.AddToken(FmtTypeLiteral, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_cfg:
			_bef = _dad
			_dad--
			{
				_abb._cce.AddToken(FmtTypeLiteral, _daf[_cfbe+1:_bef-1])
			}
			goto _cfgd
		_bbe:
			_bef = _dad
			_dad--
			{
				_abb._cce.AddToken(FmtTypeDigitOpt, nil)
			}
			goto _cfgd
		_fbde:
			_bef = _dad
			_dad--
			{
				_abb._cce.AddToken(FmtTypeFraction, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_ffg:
			_bef = _dad
			_dad--
			{
				_abb._cce.AddToken(FmtTypePercent, nil)
			}
			goto _cfgd
		_eeb:
			_bef = _dad
			_dad--
			{
				_abb._cce.AddToken(FmtTypeDate, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_aggd:
			_bef = _dad
			_dad--
			{
				_abb._cce.AddToken(FmtTypeDigit, nil)
			}
			goto _cfgd
		_baf:
			_bef = _dad
			_dad--
			{
				_abb._cce.AddToken(FmtTypeTime, _daf[_cfbe:_bef])
			}
			goto _cfgd
		_cdgf:
			_bef = _dad
			_dad--
			{
			}
			goto _cfgd
		_beb:
			_bef = _dad + 1
			{
				_abb._cce.IsExponential = true
			}
			goto _cfgd
		_bacc:
			_bef = _dad + 1
			{
				_abb._cce.AddToken(FmtTypeLiteral, _daf[_cfbe+1:_bef])
			}
			goto _cfgd
		_cfgd:
			_cfbe = 0
			if _dad++; _dad == _bfb {
				goto _dfdg
			}
		_cfc:
			_cfbe = _dad
			switch _daf[_dad] {
			case 34:
				goto _gdgg
			case 35:
				goto _agf
			case 36:
				goto _eba
			case 37:
				goto _efce
			case 44:
				goto _gcca
			case 46:
				goto _fdfe
			case 47:
				goto _aegf
			case 48:
				goto _geb
			case 58:
				goto _fcca
			case 59:
				goto _egd
			case 63:
				goto _feffg
			case 64:
				goto _adb
			case 65:
				goto _febd
			case 69:
				goto _edd
			case 71:
				goto _acf
			case 91:
				goto _ecca
			case 92:
				goto _dgaa
			case 95:
				goto _dadf
			case 100:
				goto _aegf
			case 104:
				goto _fcca
			case 109:
				goto _fdg
			case 115:
				goto _gfa
			case 121:
				goto _aac
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _efcb
			}
			goto _ccfg
		_gdgg:
			_bef = _dad + 1
			_cgcb = 20
			goto _ccbd
		_ccbd:
			if _dad++; _dad == _bfb {
				goto _bgb
			}
		_bgaf:
			if _daf[_dad] == 34 {
				goto _cfcb
			}
			goto _edc
		_edc:
			if _dad++; _dad == _bfb {
				goto _geec
			}
		_ccc:
			if _daf[_dad] == 34 {
				goto _cfcb
			}
			goto _edc
		_cfcb:
			_bef = _dad + 1
			_cgcb = 21
			goto _feff
		_feff:
			if _dad++; _dad == _bfb {
				goto _dfbd
			}
		_bgge:
			if _daf[_dad] == 34 {
				goto _edc
			}
			goto _cfg
		_agf:
			_bef = _dad + 1
			_cgcb = 3
			goto _bgf
		_bgf:
			if _dad++; _dad == _bfb {
				goto _ageg
			}
		_bbb:
			switch _daf[_dad] {
			case 35:
				goto _bab
			case 37:
				goto _bab
			case 44:
				goto _def
			case 47:
				goto _fff
			case 48:
				goto _bab
			case 63:
				goto _bab
			}
			goto _bbe
		_bab:
			if _dad++; _dad == _bfb {
				goto _bfa
			}
		_dcd:
			switch _daf[_dad] {
			case 35:
				goto _bab
			case 37:
				goto _bab
			case 47:
				goto _fff
			case 48:
				goto _bab
			case 63:
				goto _bab
			}
			goto _gac
		_fff:
			if _dad++; _dad == _bfb {
				goto _cfe
			}
		_eea:
			switch _daf[_dad] {
			case 35:
				goto _fee
			case 37:
				goto _bgfc
			case 48:
				goto _agc
			case 63:
				goto _fee
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _eed
			}
			goto _gac
		_fee:
			_bef = _dad + 1
			goto _gdgd
		_gdgd:
			if _dad++; _dad == _bfb {
				goto _gcef
			}
		_fgb:
			switch _daf[_dad] {
			case 35:
				goto _fee
			case 37:
				goto _fee
			case 44:
				goto _fee
			case 46:
				goto _fee
			case 48:
				goto _fee
			case 63:
				goto _fee
			case 65:
				goto _dadd
			}
			goto _fbde
		_dadd:
			if _dad++; _dad == _bfb {
				goto _gadc
			}
		_bafb:
			switch _daf[_dad] {
			case 47:
				goto _ebfe
			case 77:
				goto _ecff
			}
			goto _eeg
		_ebfe:
			if _dad++; _dad == _bfb {
				goto _fdaf
			}
		_ebc:
			if _daf[_dad] == 80 {
				goto _gae
			}
			goto _eeg
		_gae:
			_bef = _dad + 1
			goto _dcc
		_dcc:
			if _dad++; _dad == _bfb {
				goto _adga
			}
		_eebb:
			if _daf[_dad] == 65 {
				goto _dadd
			}
			goto _fbde
		_ecff:
			if _dad++; _dad == _bfb {
				goto _edfbd
			}
		_adec:
			if _daf[_dad] == 47 {
				goto _aag
			}
			goto _eeg
		_aag:
			if _dad++; _dad == _bfb {
				goto _dbac
			}
		_cec:
			if _daf[_dad] == 80 {
				goto _fbf
			}
			goto _eeg
		_fbf:
			if _dad++; _dad == _bfb {
				goto _cbgf
			}
		_acbf:
			if _daf[_dad] == 77 {
				goto _gae
			}
			goto _eeg
		_bgfc:
			if _dad++; _dad == _bfb {
				goto _egc
			}
		_egg:
			switch _daf[_dad] {
			case 35:
				goto _dcb
			case 37:
				goto _feab
			case 63:
				goto _dcb
			}
			if 48 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _gcbg
			}
			goto _gac
		_dcb:
			_bef = _dad + 1
			goto _bcb
		_bcb:
			if _dad++; _dad == _bfb {
				goto _gdee
			}
		_fcad:
			switch _daf[_dad] {
			case 35:
				goto _fee
			case 37:
				goto _ccbde
			case 44:
				goto _fee
			case 46:
				goto _fee
			case 48:
				goto _fee
			case 63:
				goto _fee
			case 65:
				goto _dadd
			}
			goto _fbde
		_ccbde:
			if _dad++; _dad == _bfb {
				goto _gedf
			}
		_aga:
			switch _daf[_dad] {
			case 35:
				goto _fga
			case 44:
				goto _fga
			case 46:
				goto _fga
			case 48:
				goto _fga
			case 63:
				goto _fga
			}
			goto _eeg
		_fga:
			_bef = _dad + 1
			goto _gfec
		_gfec:
			if _dad++; _dad == _bfb {
				goto _bgff
			}
		_cgd:
			switch _daf[_dad] {
			case 35:
				goto _fga
			case 44:
				goto _fga
			case 46:
				goto _fga
			case 48:
				goto _fga
			case 63:
				goto _fga
			case 65:
				goto _dadd
			}
			goto _fbde
		_feab:
			if _dad++; _dad == _bfb {
				goto _ffde
			}
		_bafa:
			if _daf[_dad] == 37 {
				goto _feab
			}
			if 48 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _gcbg
			}
			goto _gac
		_gcbg:
			_bef = _dad + 1
			_cgcb = 13
			goto _acca
		_acca:
			if _dad++; _dad == _bfb {
				goto _cecg
			}
		_bccg:
			switch _daf[_dad] {
			case 35:
				goto _fee
			case 37:
				goto _fcef
			case 44:
				goto _fee
			case 46:
				goto _fee
			case 48:
				goto _adg
			case 63:
				goto _fee
			case 65:
				goto _dadd
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _gcbg
			}
			goto _fbde
		_fcef:
			if _dad++; _dad == _bfb {
				goto _ebef
			}
		_efb:
			switch _daf[_dad] {
			case 35:
				goto _fga
			case 37:
				goto _feab
			case 44:
				goto _fga
			case 46:
				goto _fga
			case 63:
				goto _fga
			}
			if 48 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _gcbg
			}
			goto _eeg
		_adg:
			_bef = _dad + 1
			goto _fdd
		_fdd:
			if _dad++; _dad == _bfb {
				goto _cfde
			}
		_fcfd:
			switch _daf[_dad] {
			case 35:
				goto _fee
			case 37:
				goto _adg
			case 44:
				goto _fee
			case 46:
				goto _fee
			case 48:
				goto _adg
			case 63:
				goto _fee
			case 65:
				goto _dadd
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _gcbg
			}
			goto _fbde
		_agc:
			_bef = _dad + 1
			goto _gab
		_gab:
			if _dad++; _dad == _bfb {
				goto _ccbf
			}
		_gfbg:
			switch _daf[_dad] {
			case 35:
				goto _fee
			case 37:
				goto _adg
			case 44:
				goto _fee
			case 46:
				goto _fee
			case 48:
				goto _agc
			case 63:
				goto _fee
			case 65:
				goto _dadd
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _eed
			}
			goto _fbde
		_eed:
			_bef = _dad + 1
			goto _dba
		_dba:
			if _dad++; _dad == _bfb {
				goto _geca
			}
		_aafa:
			switch _daf[_dad] {
			case 35:
				goto _fee
			case 37:
				goto _gcbg
			case 44:
				goto _fee
			case 46:
				goto _fee
			case 48:
				goto _agc
			case 63:
				goto _fee
			case 65:
				goto _dadd
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _eed
			}
			goto _fbde
		_def:
			if _dad++; _dad == _bfb {
				goto _bffc
			}
		_efg:
			if _daf[_dad] == 35 {
				goto _cef
			}
			goto _gfb
		_efce:
			_bef = _dad + 1
			_cgcb = 8
			goto _bbg
		_bbg:
			if _dad++; _dad == _bfb {
				goto _aaef
			}
		_babc:
			switch _daf[_dad] {
			case 35:
				goto _ebfb
			case 37:
				goto _gbe
			case 48:
				goto _cabg
			case 63:
				goto _ebfb
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _defa
			}
			goto _ffg
		_ebfb:
			if _dad++; _dad == _bfb {
				goto _efeb
			}
		_cefd:
			switch _daf[_dad] {
			case 35:
				goto _ebfb
			case 47:
				goto _fff
			case 48:
				goto _ebfb
			case 63:
				goto _ebfb
			}
			goto _ece
		_gbe:
			if _dad++; _dad == _bfb {
				goto _afgc
			}
		_fbg:
			if _daf[_dad] == 37 {
				goto _gbe
			}
			if 48 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _defa
			}
			goto _gac
		_defa:
			if _dad++; _dad == _bfb {
				goto _cdaf
			}
		_cbf:
			switch _daf[_dad] {
			case 37:
				goto _gbe
			case 47:
				goto _fff
			}
			if 48 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _defa
			}
			goto _gac
		_cabg:
			if _dad++; _dad == _bfb {
				goto _cbdf
			}
		_gaea:
			switch _daf[_dad] {
			case 35:
				goto _ebfb
			case 37:
				goto _gbe
			case 47:
				goto _fff
			case 48:
				goto _cabg
			case 63:
				goto _ebfb
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _defa
			}
			goto _ece
		_aegf:
			_bef = _dad + 1
			goto _aab
		_aab:
			if _dad++; _dad == _bfb {
				goto _dcbc
			}
		_ddeb:
			switch _daf[_dad] {
			case 47:
				goto _aegf
			case 100:
				goto _aegf
			case 109:
				goto _aegf
			case 121:
				goto _bec
			}
			goto _eeb
		_bec:
			if _dad++; _dad == _bfb {
				goto _ecb
			}
		_eeed:
			if _daf[_dad] == 121 {
				goto _aegf
			}
			goto _aed
		_geb:
			_bef = _dad + 1
			_cgcb = 2
			goto _aee
		_aee:
			if _dad++; _dad == _bfb {
				goto _ada
			}
		_afbd:
			switch _daf[_dad] {
			case 35:
				goto _bab
			case 37:
				goto _bff
			case 47:
				goto _fff
			case 48:
				goto _gdd
			case 63:
				goto _bab
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _cbb
			}
			goto _aggd
		_bff:
			if _dad++; _dad == _bfb {
				goto _bebc
			}
		_gaf:
			switch _daf[_dad] {
			case 35:
				goto _bab
			case 37:
				goto _bff
			case 47:
				goto _fff
			case 48:
				goto _bff
			case 63:
				goto _bab
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _defa
			}
			goto _geed
		_gdd:
			if _dad++; _dad == _bfb {
				goto _abbe
			}
		_ffc:
			switch _daf[_dad] {
			case 35:
				goto _bab
			case 37:
				goto _bff
			case 47:
				goto _fff
			case 48:
				goto _gdd
			case 63:
				goto _bab
			}
			if 49 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _cbb
			}
			goto _geed
		_cbb:
			if _dad++; _dad == _bfb {
				goto _ddcc
			}
		_bggd:
			switch _daf[_dad] {
			case 37:
				goto _defa
			case 47:
				goto _fff
			}
			if 48 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _cbb
			}
			goto _gac
		_efcb:
			_bef = _dad + 1
			_cgcb = 20
			goto _cdde
		_cdde:
			if _dad++; _dad == _bfb {
				goto _eggf
			}
		_gec:
			switch _daf[_dad] {
			case 37:
				goto _defa
			case 47:
				goto _fff
			}
			if 48 <= _daf[_dad] && _daf[_dad] <= 57 {
				goto _cbb
			}
			goto _abbb
		_fcca:
			_bef = _dad + 1
			_cgcb = 15
			goto _gfd
		_gfd:
			if _dad++; _dad == _bfb {
				goto _fag
			}
		_eda:
			switch _daf[_dad] {
			case 58:
				goto _fcca
			case 65:
				goto _gcdf
			case 104:
				goto _fcca
			case 109:
				goto _fcca
			case 115:
				goto _gfa
			}
			goto _baf
		_gcdf:
			if _dad++; _dad == _bfb {
				goto _bccb
			}
		_cage:
			switch _daf[_dad] {
			case 47:
				goto _aabd
			case 77:
				goto _gfg
			}
			goto _gac
		_aabd:
			if _dad++; _dad == _bfb {
				goto _gfff
			}
		_beegf:
			if _daf[_dad] == 80 {
				goto _fcca
			}
			goto _gac
		_gfg:
			if _dad++; _dad == _bfb {
				goto _cccd
			}
		_dge:
			if _daf[_dad] == 47 {
				goto _ffge
			}
			goto _gac
		_ffge:
			if _dad++; _dad == _bfb {
				goto _ffe
			}
		_dec:
			if _daf[_dad] == 80 {
				goto _eegf
			}
			goto _gac
		_eegf:
			if _dad++; _dad == _bfb {
				goto _gbdc
			}
		_cbba:
			if _daf[_dad] == 77 {
				goto _fcca
			}
			goto _gac
		_gfa:
			_bef = _dad + 1
			_cgcb = 15
			goto _dcg
		_dcg:
			if _dad++; _dad == _bfb {
				goto _dca
			}
		_fda:
			switch _daf[_dad] {
			case 46:
				goto _ddcf
			case 58:
				goto _fcca
			case 65:
				goto _gcdf
			case 104:
				goto _fcca
			case 109:
				goto _fcca
			case 115:
				goto _gfa
			}
			goto _baf
		_ddcf:
			if _dad++; _dad == _bfb {
				goto _daae
			}
		_fbfd:
			if _daf[_dad] == 48 {
				goto _fcadg
			}
			goto _bae
		_fcadg:
			_bef = _dad + 1
			_cgcb = 15
			goto _ddd
		_ddd:
			if _dad++; _dad == _bfb {
				goto _bebb
			}
		_gffc:
			switch _daf[_dad] {
			case 48:
				goto _ggg
			case 58:
				goto _fcca
			case 65:
				goto _gcdf
			case 104:
				goto _fcca
			case 109:
				goto _fcca
			case 115:
				goto _gfa
			}
			goto _baf
		_ggg:
			_bef = _dad + 1
			_cgcb = 15
			goto _edfb
		_edfb:
			if _dad++; _dad == _bfb {
				goto _dddg
			}
		_acg:
			switch _daf[_dad] {
			case 48:
				goto _fcca
			case 58:
				goto _fcca
			case 65:
				goto _gcdf
			case 104:
				goto _fcca
			case 109:
				goto _fcca
			case 115:
				goto _gfa
			}
			goto _baf
		_feffg:
			_bef = _dad + 1
			_cgcb = 5
			goto _fbfe
		_fbfe:
			if _dad++; _dad == _bfb {
				goto _dbfa
			}
		_fcfa:
			switch _daf[_dad] {
			case 35:
				goto _bab
			case 37:
				goto _bab
			case 47:
				goto _fff
			case 48:
				goto _bab
			case 63:
				goto _bab
			}
			goto _cdgf
		_febd:
			_bef = _dad + 1
			_cgcb = 20
			goto _cegg
		_cegg:
			if _dad++; _dad == _bfb {
				goto _gfgb
			}
		_cafg:
			switch _daf[_dad] {
			case 47:
				goto _aabd
			case 77:
				goto _gfg
			}
			goto _abbb
		_edd:
			if _dad++; _dad == _bfb {
				goto _dbae
			}
		_fbfc:
			switch _daf[_dad] {
			case 43:
				goto _beb
			case 45:
				goto _beb
			}
			goto _abbb
		_acf:
			_bef = _dad + 1
			goto _dcf
		_dcf:
			if _dad++; _dad == _bfb {
				goto _eeag
			}
		_dcfb:
			if _daf[_dad] == 101 {
				goto _fad
			}
			goto _abbb
		_fad:
			if _dad++; _dad == _bfb {
				goto _cea
			}
		_gadd:
			if _daf[_dad] == 110 {
				goto _bce
			}
			goto _ecc
		_bce:
			if _dad++; _dad == _bfb {
				goto _daff
			}
		_dgeg:
			if _daf[_dad] == 101 {
				goto _cafe
			}
			goto _ecc
		_cafe:
			if _dad++; _dad == _bfb {
				goto _bbaf
			}
		_eafd:
			if _daf[_dad] == 114 {
				goto _dgea
			}
			goto _ecc
		_dgea:
			if _dad++; _dad == _bfb {
				goto _daag
			}
		_eafa:
			if _daf[_dad] == 97 {
				goto _gce
			}
			goto _ecc
		_gce:
			if _dad++; _dad == _bfb {
				goto _agege
			}
		_acfa:
			if _daf[_dad] == 108 {
				goto _acb
			}
			goto _ecc
		_ecca:
			_bef = _dad + 1
			_cgcb = 20
			goto _gaddc
		_gaddc:
			if _dad++; _dad == _bfb {
				goto _daffc
			}
		_ege:
			switch _daf[_dad] {
			case 104:
				goto _cbg
			case 109:
				goto _cbg
			case 115:
				goto _cbg
			}
			goto _dce
		_dce:
			if _dad++; _dad == _bfb {
				goto _eebg
			}
		_bbc:
			if _daf[_dad] == 93 {
				goto _ebde
			}
			goto _dce
		_ebde:
			_bef = _dad + 1
			_cgcb = 18
			goto _egec
		_fge:
			_bef = _dad + 1
			_cgcb = 16
			goto _egec
		_egec:
			if _dad++; _dad == _bfb {
				goto _ggbf
			}
		_fddd:
			if _daf[_dad] == 93 {
				goto _ebde
			}
			goto _dce
		_cbg:
			if _dad++; _dad == _bfb {
				goto _efd
			}
		_cgcc:
			if _daf[_dad] == 93 {
				goto _fge
			}
			goto _dce
		_dgaa:
			if _dad++; _dad == _bfb {
				goto _edaa
			}
		_ffca:
			goto _bacc
		_fdg:
			_bef = _dad + 1
			_cgcb = 14
			goto _befd
		_befd:
			if _dad++; _dad == _bfb {
				goto _gea
			}
		_agb:
			switch _daf[_dad] {
			case 47:
				goto _aegf
			case 58:
				goto _fcca
			case 65:
				goto _gcdf
			case 100:
				goto _aegf
			case 104:
				goto _fcca
			case 109:
				goto _fdg
			case 115:
				goto _gfa
			case 121:
				goto _bec
			}
			goto _eeb
		_aac:
			if _dad++; _dad == _bfb {
				goto _dcdf
			}
		_aege:
			if _daf[_dad] == 121 {
				goto _aegf
			}
			goto _abbb
		_febf:
		_dfdg:
			_dfe = 34
			goto _eccd
		_bgb:
			_dfe = 35
			goto _eccd
		_geec:
			_dfe = 0
			goto _eccd
		_dfbd:
			_dfe = 36
			goto _eccd
		_ageg:
			_dfe = 37
			goto _eccd
		_bfa:
			_dfe = 1
			goto _eccd
		_cfe:
			_dfe = 2
			goto _eccd
		_gcef:
			_dfe = 38
			goto _eccd
		_gadc:
			_dfe = 3
			goto _eccd
		_fdaf:
			_dfe = 4
			goto _eccd
		_adga:
			_dfe = 39
			goto _eccd
		_edfbd:
			_dfe = 5
			goto _eccd
		_dbac:
			_dfe = 6
			goto _eccd
		_cbgf:
			_dfe = 7
			goto _eccd
		_egc:
			_dfe = 8
			goto _eccd
		_gdee:
			_dfe = 40
			goto _eccd
		_gedf:
			_dfe = 9
			goto _eccd
		_bgff:
			_dfe = 41
			goto _eccd
		_ffde:
			_dfe = 10
			goto _eccd
		_cecg:
			_dfe = 42
			goto _eccd
		_ebef:
			_dfe = 11
			goto _eccd
		_cfde:
			_dfe = 43
			goto _eccd
		_ccbf:
			_dfe = 44
			goto _eccd
		_geca:
			_dfe = 45
			goto _eccd
		_bffc:
			_dfe = 12
			goto _eccd
		_aaef:
			_dfe = 46
			goto _eccd
		_efeb:
			_dfe = 13
			goto _eccd
		_afgc:
			_dfe = 14
			goto _eccd
		_cdaf:
			_dfe = 15
			goto _eccd
		_cbdf:
			_dfe = 16
			goto _eccd
		_dcbc:
			_dfe = 47
			goto _eccd
		_ecb:
			_dfe = 17
			goto _eccd
		_ada:
			_dfe = 48
			goto _eccd
		_bebc:
			_dfe = 18
			goto _eccd
		_abbe:
			_dfe = 19
			goto _eccd
		_ddcc:
			_dfe = 20
			goto _eccd
		_eggf:
			_dfe = 49
			goto _eccd
		_fag:
			_dfe = 50
			goto _eccd
		_bccb:
			_dfe = 21
			goto _eccd
		_gfff:
			_dfe = 22
			goto _eccd
		_cccd:
			_dfe = 23
			goto _eccd
		_ffe:
			_dfe = 24
			goto _eccd
		_gbdc:
			_dfe = 25
			goto _eccd
		_dca:
			_dfe = 51
			goto _eccd
		_daae:
			_dfe = 26
			goto _eccd
		_bebb:
			_dfe = 52
			goto _eccd
		_dddg:
			_dfe = 53
			goto _eccd
		_dbfa:
			_dfe = 54
			goto _eccd
		_gfgb:
			_dfe = 55
			goto _eccd
		_dbae:
			_dfe = 56
			goto _eccd
		_eeag:
			_dfe = 57
			goto _eccd
		_cea:
			_dfe = 27
			goto _eccd
		_daff:
			_dfe = 28
			goto _eccd
		_bbaf:
			_dfe = 29
			goto _eccd
		_daag:
			_dfe = 30
			goto _eccd
		_agege:
			_dfe = 31
			goto _eccd
		_daffc:
			_dfe = 58
			goto _eccd
		_eebg:
			_dfe = 32
			goto _eccd
		_ggbf:
			_dfe = 59
			goto _eccd
		_efd:
			_dfe = 33
			goto _eccd
		_edaa:
			_dfe = 60
			goto _eccd
		_gea:
			_dfe = 61
			goto _eccd
		_dcdf:
			_dfe = 62
			goto _eccd
		_eccd:
			{
			}
			if _dad == _facg {
				switch _dfe {
				case 35:
					goto _abbb
				case 0:
					goto _gac
				case 36:
					goto _cfg
				case 37:
					goto _bbe
				case 1:
					goto _gac
				case 2:
					goto _gac
				case 38:
					goto _fbde
				case 3:
					goto _eeg
				case 4:
					goto _eeg
				case 39:
					goto _fbde
				case 5:
					goto _eeg
				case 6:
					goto _eeg
				case 7:
					goto _eeg
				case 8:
					goto _gac
				case 40:
					goto _fbde
				case 9:
					goto _eeg
				case 41:
					goto _fbde
				case 10:
					goto _gac
				case 42:
					goto _fbde
				case 11:
					goto _eeg
				case 43:
					goto _fbde
				case 44:
					goto _fbde
				case 45:
					goto _fbde
				case 12:
					goto _gfb
				case 46:
					goto _ffg
				case 13:
					goto _ece
				case 14:
					goto _gac
				case 15:
					goto _gac
				case 16:
					goto _ece
				case 47:
					goto _eeb
				case 17:
					goto _aed
				case 48:
					goto _aggd
				case 18:
					goto _geed
				case 19:
					goto _geed
				case 20:
					goto _gac
				case 49:
					goto _abbb
				case 50:
					goto _baf
				case 21:
					goto _gac
				case 22:
					goto _gac
				case 23:
					goto _gac
				case 24:
					goto _gac
				case 25:
					goto _gac
				case 51:
					goto _baf
				case 26:
					goto _bae
				case 52:
					goto _baf
				case 53:
					goto _baf
				case 54:
					goto _cdgf
				case 55:
					goto _abbb
				case 56:
					goto _abbb
				case 57:
					goto _abbb
				case 27:
					goto _ecc
				case 28:
					goto _ecc
				case 29:
					goto _ecc
				case 30:
					goto _ecc
				case 31:
					goto _ecc
				case 58:
					goto _abbb
				case 32:
					goto _gac
				case 59:
					goto _gac
				case 33:
					goto _ecc
				case 60:
					goto _abbb
				case 61:
					goto _eeb
				case 62:
					goto _abbb
				}
			}
		}
		if _cfbe > 0 {
			copy(_daf[0:], _daf[_cfbe:])
		}
	}
	_ = _facg
	if _dfe == _eee {
		_ee.Log.Debug("\u0066o\u0072m\u0061\u0074\u0020\u0070\u0061r\u0073\u0065 \u0065\u0072\u0072\u006f\u0072")
	}
}
func _feb(_de float64) string {
	_aff := _eb.FormatFloat(_de, 'E', -1, 64)
	_feba := _eb.FormatFloat(_de, 'E', 5, 64)
	if len(_aff) < len(_feba) {
		return _eb.FormatFloat(_de, 'E', 2, 64)
	}
	return _feba
}

// Value formats a value as a number or string depending on  if it appears to be
// a number or string.
func Value(v string, f string) string {
	if IsNumber(v) {
		_cg, _ := _eb.ParseFloat(v, 64)
		return Number(_cg, f)
	}
	return String(v, f)
}

// String returns the string formatted according to the type.  In format strings
// this is the fourth item, where '@' is used as a placeholder for text.
func String(v string, f string) string {
	_eef := Parse(f)
	var _da Format
	if len(_eef) == 1 {
		_da = _eef[0]
	} else if len(_eef) == 4 {
		_da = _eef[3]
	}
	_fgc := false
	for _, _gcg := range _da.Whole {
		if _gcg.Type == FmtTypeText {
			_fgc = true
		}
	}
	if !_fgc {
		return v
	}
	_gf := _c.Buffer{}
	for _, _ge := range _da.Whole {
		switch _ge.Type {
		case FmtTypeLiteral:
			_gf.WriteByte(_ge.Literal)
		case FmtTypeText:
			_gf.WriteString(v)
		}
	}
	return _gf.String()
}
func _ecf(_dc _ac.Time, _bcf string) []byte {
	_eff := []byte{}
	_dea := 0
	for _ggba := 0; _ggba < len(_bcf); _ggba++ {
		var _fcb string
		if _bcf[_ggba] == '/' {
			_fcb = string(_bcf[_dea:_ggba])
			_dea = _ggba + 1
		} else if _ggba == len(_bcf)-1 {
			_fcb = string(_bcf[_dea : _ggba+1])
		} else {
			continue
		}
		switch _fcb {
		case "\u0079\u0079":
			_eff = _dc.AppendFormat(_eff, "\u0030\u0036")
		case "\u0079\u0079\u0079\u0079":
			_eff = _dc.AppendFormat(_eff, "\u0032\u0030\u0030\u0036")
		case "\u006d":
			_eff = _dc.AppendFormat(_eff, "\u0031")
		case "\u006d\u006d":
			_eff = _dc.AppendFormat(_eff, "\u0030\u0031")
		case "\u006d\u006d\u006d":
			_eff = _dc.AppendFormat(_eff, "\u004a\u0061\u006e")
		case "\u006d\u006d\u006d\u006d":
			_eff = _dc.AppendFormat(_eff, "\u004aa\u006e\u0075\u0061\u0072\u0079")
		case "\u006d\u006d\u006dm\u006d":
			switch _dc.Month() {
			case _ac.January, _ac.July, _ac.June:
				_eff = append(_eff, 'J')
			case _ac.February:
				_eff = append(_eff, 'M')
			case _ac.March, _ac.May:
				_eff = append(_eff, 'M')
			case _ac.April, _ac.August:
				_eff = append(_eff, 'A')
			case _ac.September:
				_eff = append(_eff, 'S')
			case _ac.October:
				_eff = append(_eff, 'O')
			case _ac.November:
				_eff = append(_eff, 'N')
			case _ac.December:
				_eff = append(_eff, 'D')
			}
		case "\u0064":
			_eff = _dc.AppendFormat(_eff, "\u0032")
		case "\u0064\u0064":
			_eff = _dc.AppendFormat(_eff, "\u0030\u0032")
		case "\u0064\u0064\u0064":
			_eff = _dc.AppendFormat(_eff, "\u004d\u006f\u006e")
		case "\u0064\u0064\u0064\u0064":
			_eff = _dc.AppendFormat(_eff, "\u004d\u006f\u006e\u0064\u0061\u0079")
		default:
			_ee.Log.Debug("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0064\u0061\u0074\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073", _fcb)
		}
		if _bcf[_ggba] == '/' {
			_eff = append(_eff, '/')
		}
	}
	return _eff
}

const _afb int = 34
const _gff int = 0

// AddToken adds a format token to the format.
func (_cd *Format) AddToken(t FmtType, l []byte) {
	if _cd._aaa {
		_cd._aaa = false
		return
	}
	switch t {
	case FmtTypeDecimal:
		_cd._d = true
	case FmtTypeUnderscore:
		_cd._aaa = true
	case FmtTypeText:
		_cd.Whole = append(_cd.Whole, Token{Type: t})
	case FmtTypeDate, FmtTypeTime:
		_cd.Whole = append(_cd.Whole, Token{Type: t, DateTime: string(l)})
	case FmtTypePercent:
		_cd._ec = true
		t = FmtTypeLiteral
		l = []byte{'%'}
		fallthrough
	case FmtTypeDigitOpt:
		fallthrough
	case FmtTypeLiteral, FmtTypeDigit, FmtTypeDollar, FmtTypeComma:
		if l == nil {
			l = []byte{0}
		}
		for _, _ca := range l {
			if _cd.IsExponential {
				_cd.Exponent = append(_cd.Exponent, Token{Type: t, Literal: _ca})
			} else if !_cd._d {
				_cd.Whole = append(_cd.Whole, Token{Type: t, Literal: _ca})
			} else {
				_cd.Fractional = append(_cd.Fractional, Token{Type: t, Literal: _ca})
			}
		}
	case FmtTypeDigitOptThousands:
		_cd._fg = true
	case FmtTypeFraction:
		_gc := _g.Split(string(l), "\u002f")
		if len(_gc) == 2 {
			_cd._fcc = true
			_cd._cc, _ = _eb.ParseInt(_gc[1], 10, 64)
			for _, _ea := range _gc[1] {
				if _ea == '?' || _ea == '0' {
					_cd._dg++
				}
			}
		}
	default:
		_ee.Log.Debug("\u0075\u006e\u0073u\u0070\u0070\u006f\u0072t\u0065\u0064\u0020\u0070\u0068\u0020\u0074y\u0070\u0065\u0020\u0069\u006e\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0076", t)
	}
}
func (_ce FmtType) String() string {
	if _ce >= FmtType(len(_f)-1) {
		return _b.Sprintf("F\u006d\u0074\u0054\u0079\u0070\u0065\u0028\u0025\u0064\u0029", _ce)
	}
	return _ba[_f[_ce]:_f[_ce+1]]
}

const _aae int = 34

func _bcc(_bea _ac.Time, _daa float64, _cdf string) []byte {
	_fea := []byte{}
	_eca := 0
	for _ccb := 0; _ccb < len(_cdf); _ccb++ {
		var _bba string
		if _cdf[_ccb] == ':' {
			_bba = string(_cdf[_eca:_ccb])
			_eca = _ccb + 1
		} else if _ccb == len(_cdf)-1 {
			_bba = string(_cdf[_eca : _ccb+1])
		} else {
			continue
		}
		switch _bba {
		case "\u0064":
			_fea = _bea.AppendFormat(_fea, "\u0032")
		case "\u0068":
			_fea = _bea.AppendFormat(_fea, "\u0033")
		case "\u0068\u0068":
			_fea = _bea.AppendFormat(_fea, "\u0031\u0035")
		case "\u006d":
			_fea = _bea.AppendFormat(_fea, "\u0034")
		case "\u006d\u006d":
			_fea = _bea.AppendFormat(_fea, "\u0030\u0034")
		case "\u0073":
			_fea = _bea.Round(_ac.Second).AppendFormat(_fea, "\u0035")
		case "\u0073\u002e\u0030":
			_fea = _bea.Round(_ac.Second/10).AppendFormat(_fea, "\u0035\u002e\u0030")
		case "\u0073\u002e\u0030\u0030":
			_fea = _bea.Round(_ac.Second/100).AppendFormat(_fea, "\u0035\u002e\u0030\u0030")
		case "\u0073\u002e\u00300\u0030":
			_fea = _bea.Round(_ac.Second/1000).AppendFormat(_fea, "\u0035\u002e\u00300\u0030")
		case "\u0073\u0073":
			_fea = _bea.Round(_ac.Second).AppendFormat(_fea, "\u0030\u0035")
		case "\u0073\u0073\u002e\u0030":
			_fea = _bea.Round(_ac.Second/10).AppendFormat(_fea, "\u0030\u0035\u002e\u0030")
		case "\u0073\u0073\u002e0\u0030":
			_fea = _bea.Round(_ac.Second/100).AppendFormat(_fea, "\u0030\u0035\u002e0\u0030")
		case "\u0073\u0073\u002e\u0030\u0030\u0030":
			_fea = _bea.Round(_ac.Second/1000).AppendFormat(_fea, "\u0030\u0035\u002e\u0030\u0030\u0030")
		case "\u0041\u004d\u002fP\u004d":
			_fea = _bea.AppendFormat(_fea, "\u0050\u004d")
		case "\u005b\u0068\u005d":
			_fea = _eb.AppendInt(_fea, int64(_daa*24), 10)
		case "\u005b\u006d\u005d":
			_fea = _eb.AppendInt(_fea, int64(_daa*24*60), 10)
		case "\u005b\u0073\u005d":
			_fea = _eb.AppendInt(_fea, int64(_daa*24*60*60), 10)
		case "":
		default:
			_ee.Log.Debug("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064 \u0074\u0069\u006d\u0065\u0020\u0066\u006f\u0072\u006d\u0061t\u0020\u0025\u0073", _bba)
		}
		if _cdf[_ccb] == ':' {
			_fea = append(_fea, ':')
		}
	}
	return _fea
}
func _gged(_agef _ac.Time) _ac.Time {
	_agef = _agef.UTC()
	return _ac.Date(_agef.Year(), _agef.Month(), _agef.Day(), _agef.Hour(), _agef.Minute(), _agef.Second(), _agef.Nanosecond(), _ac.Local)
}
func (_ceg *Lexer) nextFmt() { _ceg._ecac = append(_ceg._ecac, _ceg._cce); _ceg._cce = Format{} }

const _afff int = 0
const _bd = 1e-10
