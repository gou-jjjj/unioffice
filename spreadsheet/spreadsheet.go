//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

// Copyright 2017 FoxyUtils ehf. All rights reserved.
//
// Use of this software package and source code is governed by the terms of the
// UniDoc End User License Agreement (EULA) that is available at:
// https://unidoc.io/eula/
// A trial license code for evaluation can be obtained at https://unidoc.io.
package spreadsheet

import (
	_ag "archive/zip"
	_fc "bytes"
	_fb "errors"
	_c "fmt"
	_b "image"
	_ab "image/jpeg"
	_ad "io"
	_gdf "math"
	_ba "math/big"
	_abd "os"
	_ff "path"
	_g "path/filepath"
	_bb "reflect"
	_df "regexp"
	_aa "sort"
	_fg "strconv"
	_d "strings"
	_gd "time"
	_f "unioffice"
	_bg "unioffice/chart"
	_cea "unioffice/color"
	_fa "unioffice/common"
	_cf "unioffice/common/logger"
	_ce "unioffice/common/tempstorage"
	_db "unioffice/internal/formatutils"
	_e "unioffice/internal/license"
	_ae "unioffice/measurement"
	_cg "unioffice/schema/soo/dml"
	_dc "unioffice/schema/soo/dml/chart"
	_fgf "unioffice/schema/soo/dml/spreadsheetDrawing"
	_ge "unioffice/schema/soo/pkg/relationships"
	_fge "unioffice/schema/soo/sml"
	_fff "unioffice/spreadsheet/format"
	_bac "unioffice/spreadsheet/formula"
	_gb "unioffice/spreadsheet/reference"
	_be "unioffice/spreadsheet/update"
	_ea "unioffice/vmldrawing"
	_dg "unioffice/zippkg"
)

// AddHyperlink adds a hyperlink to a sheet. Adding the hyperlink to the sheet
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_ggaf *Sheet) AddHyperlink(url string) _fa.Hyperlink {
	for _ecea, _bcac := range _ggaf._fgca._egabd {
		if _bcac == _ggaf._defb {
			return _ggaf._fgca._bbea[_ecea].AddHyperlink(url)
		}
	}
	return _fa.Hyperlink{}
}
func (_afdec Fill) Index() uint32 {
	if _afdec._eeg == nil {
		return 0
	}
	for _fab, _cgcg := range _afdec._eeg.Fill {
		if _afdec._afcd == _cgcg {
			return uint32(_fab)
		}
	}
	return 0
}

// GetValueAsNumber retrieves the cell's value as a number
func (_dbf Cell) GetValueAsNumber() (float64, error) {
	if _dbf._dced.V == nil && _dbf._dced.Is == nil {
		return 0, nil
	}
	if _dbf._dced.TAttr == _fge.ST_CellTypeS || !_fff.IsNumber(*_dbf._dced.V) {
		return _gdf.NaN(), _fb.New("\u0063\u0065\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074 \u006f\u0066\u0020\u006e\u0075\u006d\u0062\u0065\u0072\u0020t\u0079\u0070\u0065")
	}
	return _fg.ParseFloat(*_dbf._dced.V, 64)
}

// SetHidden marks the defined name as hidden.
func (_bgd DefinedName) SetHidden(b bool) { _bgd._cgaa.HiddenAttr = _f.Bool(b) }

// X returns the inner wrapped XML type.
func (_cdbfc SheetProtection) X() *_fge.CT_SheetProtection { return _cdbfc._bbaf }

// SetWidth sets the width of the anchored object.
func (_gba AbsoluteAnchor) SetWidth(w _ae.Distance) { _gba._fcc.Ext.CxAttr = int64(w / _ae.EMU) }
func (_aac Cell) getFormat() string {
	if _aac._dced.SAttr == nil {
		return "\u0047e\u006e\u0065\u0072\u0061\u006c"
	}
	_cgd := *_aac._dced.SAttr
	_bc := _aac._ef.StyleSheet.GetCellStyle(_cgd)
	_adgf := _aac._ef.StyleSheet.GetNumberFormat(_bc.NumberFormat())
	return _adgf.GetFormat()
}

// PasswordHash returns the hash of the workbook password.
func (_abae WorkbookProtection) PasswordHash() string {
	if _abae._edcb.WorkbookPasswordAttr == nil {
		return ""
	}
	return *_abae._edcb.WorkbookPasswordAttr
}

// X returns the inner wrapped XML type.
func (_ffc Border) X() *_fge.CT_Border { return _ffc._ed }

// IsNumber returns true if the cell is a number type cell.
func (_fe Cell) IsNumber() bool {
	switch _fe._dced.TAttr {
	case _fge.ST_CellTypeN:
		return true
	case _fge.ST_CellTypeS, _fge.ST_CellTypeB:
		return false
	}
	return _fe._dced.V != nil && _fff.IsNumber(*_fe._dced.V)
}

// ID returns the number format ID.  This is not an index as there are some
// predefined number formats which can be used in cell styles and don't need a
// corresponding NumberFormat.
func (_dceg NumberFormat) ID() uint32 { return _dceg._gage.NumFmtIdAttr }

// RemoveSheetByName removes the sheet with the given name from the workbook.
func (_beda *Workbook) RemoveSheetByName(name string) error {
	_ebef := -1
	for _afcb, _cfbaf := range _beda.Sheets() {
		if name == _cfbaf.Name() {
			_ebef = _afcb
			break
		}
	}
	if _ebef == -1 {
		return ErrorNotFound
	}
	return _beda.RemoveSheet(_ebef)
}
func _gbcd(_ffef string, _efbf uint32, _fdedc bool) string {
	_acba, _abdfc, _cggf := _gb.ParseRangeReference(_ffef)
	if _cggf == nil {
		_aacc, _cddc := _acba.ColumnIdx, _abdfc.ColumnIdx
		if _efbf >= _aacc && _efbf <= _cddc {
			if _aacc == _cddc {
				if _fdedc {
					return ""
				} else {
					return _ffef
				}
			} else {
				_gceg := _abdfc.Update(_be.UpdateActionRemoveColumn)
				return _c.Sprintf("\u0025\u0073\u003a%\u0073", _acba.String(), _gceg.String())
			}
		} else if _efbf < _aacc {
			_cfff := _acba.Update(_be.UpdateActionRemoveColumn)
			_ffaa := _abdfc.Update(_be.UpdateActionRemoveColumn)
			return _c.Sprintf("\u0025\u0073\u003a%\u0073", _cfff.String(), _ffaa.String())
		}
	} else {
		_eaff, _dbeb, _fabfe := _gb.ParseColumnRangeReference(_ffef)
		if _fabfe != nil {
			return ""
		}
		_abff, _dfadb := _eaff.ColumnIdx, _dbeb.ColumnIdx
		if _efbf >= _abff && _efbf <= _dfadb {
			if _abff == _dfadb {
				if _fdedc {
					return ""
				} else {
					return _ffef
				}
			} else {
				_eged := _dbeb.Update(_be.UpdateActionRemoveColumn)
				return _c.Sprintf("\u0025\u0073\u003a%\u0073", _eaff.String(), _eged.String())
			}
		} else if _efbf < _abff {
			_ecgg := _eaff.Update(_be.UpdateActionRemoveColumn)
			_edcgd := _dbeb.Update(_be.UpdateActionRemoveColumn)
			return _c.Sprintf("\u0025\u0073\u003a%\u0073", _ecgg.String(), _edcgd.String())
		}
	}
	return ""
}

// LessCells returns true if the lhs value is less than the rhs value. If the
// cells contain numeric values, their value interpreted as a floating point is
// compared. Otherwise their string contents are compared.
func (_afe Comparer) LessCells(lhs, rhs Cell) bool {
	if _afe.Order == SortOrderDescending {
		lhs, rhs = rhs, lhs
	}
	if lhs.X() == nil {
		if rhs.X() == nil {
			return false
		}
		return true
	}
	if rhs.X() == nil {
		return false
	}
	_dffc, _cbb := lhs.getRawSortValue()
	_ecdf, _affc := rhs.getRawSortValue()
	switch {
	case _cbb && _affc:
		_efcd, _ := _fg.ParseFloat(_dffc, 64)
		_ggf, _ := _fg.ParseFloat(_ecdf, 64)
		return _efcd < _ggf
	case _cbb:
		return true
	case _affc:
		return false
	}
	_dffc = lhs.GetFormattedValue()
	_ecdf = rhs.GetFormattedValue()
	return _dffc < _ecdf
}

// SetActiveSheet sets the active sheet which will be the tab displayed when the
// spreadsheet is initially opened.
func (_cdegg *Workbook) SetActiveSheet(s Sheet) {
	for _ebad, _cegfe := range _cdegg._egabd {
		if s._defb == _cegfe {
			_cdegg.SetActiveSheetIndex(uint32(_ebad))
		}
	}
}

// GetValueAsBool retrieves the cell's value as a boolean
func (_edc Cell) GetValueAsBool() (bool, error) {
	if _edc._dced.TAttr != _fge.ST_CellTypeB {
		return false, _fb.New("\u0063e\u006c\u006c\u0020\u0069\u0073\u0020\u006e\u006f\u0074\u0020\u006ff\u0020\u0062\u006f\u006f\u006c\u0020\u0074\u0079\u0070\u0065")
	}
	if _edc._dced.V == nil {
		return false, _fb.New("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065")
	}
	return _fg.ParseBool(*_edc._dced.V)
}

// SheetCount returns the number of sheets in the workbook.
func (_feag Workbook) SheetCount() int { return len(_feag._egabd) }

// SetFormulaArray sets the cell type to formula array, and the raw formula to
// the given string. This is equivlent to entering a formula and pressing
// Ctrl+Shift+Enter in Excel.
func (_eed Cell) SetFormulaArray(s string) {
	_dcc := _bac.ParseString(s)
	if _dcc == nil {
		return
	}
	_eed.clearValue()
	_eed._dced.TAttr = _fge.ST_CellTypeStr
	_eed._dced.F = _fge.NewCT_CellFormula()
	_eed._dced.F.TAttr = _fge.ST_CellFormulaTypeArray
	_eed._dced.F.Content = s
}

// X returns the inner wrapped XML type.
func (_fbgfc NumberFormat) X() *_fge.CT_NumFmt { return _fbgfc._gage }

// IsEmpty returns true if the cell is empty.
func (_adc Cell) IsEmpty() bool {
	return _adc._dced.TAttr == _fge.ST_CellTypeUnset && _adc._dced.V == nil && _adc._dced.F == nil
}

// X returns the inner wrapped XML type.
func (_faaa Comments) X() *_fge.Comments { return _faaa._dfef }

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported, if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_cdgd *Workbook) RecalculateFormulas() {
	for _, _cabfbc := range _cdgd.Sheets() {
		_cabfbc.RecalculateFormulas()
	}
}

// GetWidth returns a worksheet's column width.
func (_cdbd *evalContext) GetWidth(colIdx int) float64 {
	colIdx++
	for _, _efd := range _cdbd._dgf.X().Cols[0].Col {
		if int(_efd.MinAttr) <= colIdx && colIdx <= int(_efd.MaxAttr) {
			return float64(int(*_efd.WidthAttr))
		}
	}
	return 0
}

// Content returns the content of the defined range (the range in most cases)/
func (_egec DefinedName) Content() string { return _egec._cgaa.Content }

// Protection controls the protection on an individual sheet.
func (_becd *Sheet) Protection() SheetProtection {
	if _becd._defb.SheetProtection == nil {
		_becd._defb.SheetProtection = _fge.NewCT_SheetProtection()
	}
	return SheetProtection{_becd._defb.SheetProtection}
}

// GetString returns the string in a cell if it's an inline or string table
// string. Otherwise it returns an empty string.
func (_fba Cell) GetString() string {
	switch _fba._dced.TAttr {
	case _fge.ST_CellTypeInlineStr:
		if _fba._dced.Is != nil && _fba._dced.Is.T != nil {
			return *_fba._dced.Is.T
		}
		if _fba._dced.V != nil {
			return *_fba._dced.V
		}
	case _fge.ST_CellTypeS:
		if _fba._dced.V == nil {
			return ""
		}
		_ecc, _cgf := _fg.Atoi(*_fba._dced.V)
		if _cgf != nil {
			return ""
		}
		_dcg, _cgf := _fba._ef.SharedStrings.GetString(_ecc)
		if _cgf != nil {
			return ""
		}
		return _dcg
	}
	if _fba._dced.V == nil {
		return ""
	}
	return *_fba._dced.V
}

// SetConditionValue sets the condition value to be used for style applicaton.
func (_gbfe ConditionalFormattingRule) SetConditionValue(v string) { _gbfe._gcgc.Formula = []string{v} }

// DVCompareOp is a comparison operator for a data validation rule.
type DVCompareOp byte

// SetRichTextString sets the cell to rich string mode and returns a struct that
// can be used to add formatted text to the cell.
func (_bbd Cell) SetRichTextString() RichText {
	_bbd.clearValue()
	_bbd._dced.Is = _fge.NewCT_Rst()
	_bbd._dced.TAttr = _fge.ST_CellTypeInlineStr
	return RichText{_bbd._dced.Is}
}

type Table struct{ _ecgbf *_fge.Table }

// AddFormatValue adds a format value to be used to determine the cell background.
func (_ggc ColorScale) AddFormatValue(t _fge.ST_CfvoType, val string) {
	_cced := _fge.NewCT_Cfvo()
	_cced.TypeAttr = t
	_cced.ValAttr = _f.String(val)
	_ggc._ceea.Cfvo = append(_ggc._ceea.Cfvo, _cced)
}

// SetRowOffset sets the row offset of the top-left anchor.
func (_ebgd OneCellAnchor) SetRowOffset(m _ae.Distance) { _ebgd.TopLeft().SetRowOffset(m) }

// AddChart adds an chart to a drawing, returning the chart and an anchor that
// can be used to position the chart within the sheet.
func (_gcb Drawing) AddChart(at AnchorType) (_bg.Chart, Anchor) {
	_effd := _dc.NewChartSpace()
	_gcb._dfbc._cdbc = append(_gcb._dfbc._cdbc, _effd)
	_dfbg := _f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.ChartContentType, len(_gcb._dfbc._cdbc))
	_gcb._dfbc.ContentTypes.AddOverride(_dfbg, _f.ChartContentType)
	var _dcf string
	for _eaad, _bfcg := range _gcb._dfbc._beed {
		if _bfcg == _gcb._caeb {
			_bfac := _f.RelativeFilename(_f.DocTypeSpreadsheet, _f.DrawingType, _f.ChartType, len(_gcb._dfbc._cdbc))
			_ffb := _gcb._dfbc._gfgab[_eaad].AddRelationship(_bfac, _f.ChartType)
			_dcf = _ffb.ID()
			break
		}
	}
	var _beaf Anchor
	var _fccd *_fgf.CT_GraphicalObjectFrame
	switch at {
	case AnchorTypeAbsolute:
		_bcge := _egeb()
		_gcb._caeb.EG_Anchor = append(_gcb._caeb.EG_Anchor, &_fgf.EG_Anchor{AnchorChoice: &_fgf.EG_AnchorChoice{AbsoluteAnchor: _bcge}})
		_bcge.ObjectChoicesChoice = &_fgf.EG_ObjectChoicesChoice{}
		_bcge.ObjectChoicesChoice.GraphicFrame = _fgf.NewCT_GraphicalObjectFrame()
		_fccd = _bcge.ObjectChoicesChoice.GraphicFrame
		_beaf = AbsoluteAnchor{_bcge}
	case AnchorTypeOneCell:
		_fgfa := _gdd()
		_gcb._caeb.EG_Anchor = append(_gcb._caeb.EG_Anchor, &_fgf.EG_Anchor{AnchorChoice: &_fgf.EG_AnchorChoice{OneCellAnchor: _fgfa}})
		_fgfa.ObjectChoicesChoice = &_fgf.EG_ObjectChoicesChoice{}
		_fgfa.ObjectChoicesChoice.GraphicFrame = _fgf.NewCT_GraphicalObjectFrame()
		_fccd = _fgfa.ObjectChoicesChoice.GraphicFrame
		_beaf = OneCellAnchor{_fgfa}
	case AnchorTypeTwoCell:
		_bbee := _def()
		_gcb._caeb.EG_Anchor = append(_gcb._caeb.EG_Anchor, &_fgf.EG_Anchor{AnchorChoice: &_fgf.EG_AnchorChoice{TwoCellAnchor: _bbee}})
		_bbee.ObjectChoicesChoice = &_fgf.EG_ObjectChoicesChoice{}
		_bbee.ObjectChoicesChoice.GraphicFrame = _fgf.NewCT_GraphicalObjectFrame()
		_fccd = _bbee.ObjectChoicesChoice.GraphicFrame
		_beaf = TwoCellAnchor{_bbee}
	}
	_fccd.NvGraphicFramePr = _fgf.NewCT_GraphicalObjectFrameNonVisual()
	_fccd.NvGraphicFramePr.CNvPr.IdAttr = uint32(len(_gcb._caeb.EG_Anchor))
	_fccd.NvGraphicFramePr.CNvPr.NameAttr = "\u0043\u0068\u0061r\u0074"
	_fccd.Graphic = _cg.NewGraphic()
	_fccd.Graphic.GraphicData.UriAttr = "\u0068\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002eo\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073.\u006f\u0072\u0067\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006dl/\u0032\u0030\u0030\u0036\u002f\u0063\u0068\u0061\u0072\u0074"
	_aeg := _dc.NewChart()
	_aeg.IdAttr = _dcf
	_fccd.Graphic.GraphicData.Any = []_f.Any{_aeg}
	_caaf := _bg.MakeChart(_effd)
	_caaf.Properties().SetSolidFill(_cea.White)
	_caaf.SetDisplayBlanksAs(_dc.ST_DispBlanksAsGap)
	return _caaf, _beaf
}
func (_dddb *Sheet) removeColumnFromNamedRanges(_baca uint32) error {
	for _, _ebba := range _dddb._fgca.DefinedNames() {
		_abde := _ebba.Name()
		_gcec := _ebba.Content()
		_fgaa := _d.Split(_gcec, "\u0021")
		if len(_fgaa) != 2 {
			return _fb.New("\u0049\u006e\u0063\u006frr\u0065\u0063\u0074\u0020\u006e\u0061\u006d\u0065\u0064\u0020\u0072\u0061\u006e\u0067e\u003a" + _gcec)
		}
		_gfefg := _fgaa[0]
		if _dddb.Name() == _gfefg {
			_gacd := _dddb._fgca.RemoveDefinedName(_ebba)
			if _gacd != nil {
				return _gacd
			}
			_dbca := _gbcd(_fgaa[1], _baca, true)
			if _dbca != "" {
				_bgea := _gfefg + "\u0021" + _dbca
				_dddb._fgca.AddDefinedName(_abde, _bgea)
			}
		}
	}
	_afeg := 0
	if _dddb._defb.TableParts != nil && _dddb._defb.TableParts.TablePart != nil {
		_afeg = len(_dddb._defb.TableParts.TablePart)
	}
	if _afeg != 0 {
		_bgfbc := 0
		for _, _eecb := range _dddb._fgca.Sheets() {
			if _eecb.Name() == _dddb.Name() {
				break
			} else {
				if _eecb._defb.TableParts != nil && _eecb._defb.TableParts.TablePart != nil {
					_bgfbc += len(_eecb._defb.TableParts.TablePart)
				}
			}
		}
		_cfga := _dddb._fgca._eafaa[_bgfbc : _bgfbc+_afeg]
		for _fgff, _eade := range _cfga {
			_deafa := _eade
			_deafa.RefAttr = _gbcd(_deafa.RefAttr, _baca, false)
			_dddb._fgca._eafaa[_bgfbc+_fgff] = _deafa
		}
	}
	return nil
}

const (
	AnchorTypeAbsolute AnchorType = iota
	AnchorTypeOneCell
	AnchorTypeTwoCell
)

// SetHeight sets the height of the anchored object.
func (_agag OneCellAnchor) SetHeight(h _ae.Distance) { _agag._gfgaf.Ext.CyAttr = int64(h / _ae.EMU) }
func _gee(_bcfcd bool) int {
	if _bcfcd {
		return 1
	}
	return 0
}

// SetAllowBlank controls if blank values are accepted.
func (_gdgb DataValidation) SetAllowBlank(b bool) {
	if !b {
		_gdgb._ebga.AllowBlankAttr = nil
	} else {
		_gdgb._ebga.AllowBlankAttr = _f.Bool(true)
	}
}

// SetIcons configures the rule as an icon scale, removing existing
// configuration.
func (_fgef ConditionalFormattingRule) SetIcons() IconScale {
	_fgef.clear()
	_fgef.SetType(_fge.ST_CfTypeIconSet)
	_fgef._gcgc.IconSet = _fge.NewCT_IconSet()
	_egc := IconScale{_fgef._gcgc.IconSet}
	_egc.SetIcons(_fge.ST_IconSetType3TrafficLights1)
	return _egc
}
func (_ecdd *evalContext) Cell(ref string, ev _bac.Evaluator) _bac.Result {
	if !_dffg(ref) {
		return _bac.MakeErrorResultType(_bac.ErrorTypeName, "")
	}
	_abdc := _ecdd._dgf.Name() + "\u0021" + ref
	if _bbad, _egg := ev.GetFromCache(_abdc); _egg {
		return _bbad
	}
	_bff, _edcf := _gb.ParseCellReference(ref)
	if _edcf != nil {
		return _bac.MakeErrorResult(_c.Sprintf("e\u0072r\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", ref, _edcf))
	}
	if _ecdd._gca != 0 && !_bff.AbsoluteColumn {
		_bff.ColumnIdx += _ecdd._gca
		_bff.Column = _gb.IndexToColumn(_bff.ColumnIdx)
	}
	if _ecdd._cdd != 0 && !_bff.AbsoluteRow {
		_bff.RowIdx += _ecdd._cdd
	}
	_cdc := _ecdd._dgf.Cell(_bff.String())
	if _cdc.HasFormula() {
		if _, _fac := _ecdd._gdgf[ref]; _fac {
			return _bac.MakeErrorResult("r\u0065\u0063\u0075\u0072\u0073\u0069\u006f\u006e\u0020\u0064\u0065\u0074\u0065\u0063\u0074\u0065\u0064\u0020d\u0075\u0072\u0069\u006e\u0067\u0020\u0065\u0076\u0061\u006cua\u0074\u0069\u006fn\u0020o\u0066\u0020" + ref)
		}
		_ecdd._gdgf[ref] = struct{}{}
		_ebc := ev.Eval(_ecdd, _cdc.GetFormula())
		delete(_ecdd._gdgf, ref)
		ev.SetCache(_abdc, _ebc)
		return _ebc
	}
	if _cdc.IsEmpty() {
		_cbd := _bac.MakeEmptyResult()
		ev.SetCache(_abdc, _cbd)
		return _cbd
	} else if _cdc.IsNumber() {
		_dde, _ := _cdc.GetValueAsNumber()
		_cgdc := _bac.MakeNumberResult(_dde)
		ev.SetCache(_abdc, _cgdc)
		return _cgdc
	} else if _cdc.IsBool() {
		_caac, _ := _cdc.GetValueAsBool()
		_acae := _bac.MakeBoolResult(_caac)
		ev.SetCache(_abdc, _acae)
		return _acae
	}
	_cdbf, _ := _cdc.GetRawValue()
	if _cdc.IsError() {
		_acbf := _bac.MakeErrorResult("")
		_acbf.ValueString = _cdbf
		ev.SetCache(_abdc, _acbf)
		return _acbf
	}
	_fdab := _bac.MakeStringResult(_cdbf)
	ev.SetCache(_abdc, _fdab)
	return _fdab
}
func (_beb Cell) GetRawValue() (string, error) {
	switch _beb._dced.TAttr {
	case _fge.ST_CellTypeInlineStr:
		if _beb._dced.Is == nil || _beb._dced.Is.T == nil {
			return "", nil
		}
		return *_beb._dced.Is.T, nil
	case _fge.ST_CellTypeS:
		if _beb._dced.V == nil {
			return "", nil
		}
		_ccee, _adgg := _fg.Atoi(*_beb._dced.V)
		if _adgg != nil {
			return "", _adgg
		}
		return _beb._ef.SharedStrings.GetString(_ccee)
	case _fge.ST_CellTypeStr:
		if _beb._dced.F != nil {
			return _beb._dced.F.Content, nil
		}
	}
	if _beb._dced.V == nil {
		return "", nil
	}
	return *_beb._dced.V, nil
}

// SetStyle applies a style to a cell avoiding redundancy. The function checks if the given style
// already exists in the saved styles. If found, the existing style is reused; otherwise,
// the new style is added to the saved styles collection. The style is then applied to the cell.
// This style is referenced in the generated XML via CellStyle.Index().
func (_bda Cell) SetStyle(cs CellStyle) {
	_dcedg := cs._add.Xf
	for _, _ebe := range _dcedg {
		if _bb.DeepEqual(_ebe, cs._dece) {
			cs._dece = _ebe
			_bda.SetStyleIndex(cs.Index())
			return
		}
	}
	cs._add.Xf = append(cs._add.Xf, cs._dece)
	cs._add.CountAttr = _f.Uint32(uint32(len(cs._add.Xf)))
	_bda.SetStyleIndex(cs.Index())
}

// SharedStrings is a shared strings table, where string data can be placed
// outside of the sheet contents and referenced from a sheet.
type SharedStrings struct {
	_ebge *_fge.Sst
	_cbdf map[string]int
}

// X returns the inner wrapped XML type.
func (_baee SheetView) X() *_fge.CT_SheetView { return _baee._gfdfg }

// Fills returns a Fills object that can be used to add/create/edit fills.
func (_febg StyleSheet) Fills() Fills { return Fills{_febg._ccde.Fills} }

// Anchor is the interface implemented by anchors. It's modeled after the most
// common anchor (Two cell variant with a from/to position), but will also be
// used for one-cell anchors.  In that case the only non-noop methods are
// TopLeft/MoveTo/SetColOffset/SetRowOffset.
type Anchor interface {

	// BottomRight returns the CellMaker for the bottom right corner of the
	// anchor.
	BottomRight() CellMarker

	// TopLeft returns the CellMaker for the top left corner of the anchor.
	TopLeft() CellMarker

	// MoveTo repositions the anchor without changing the objects size.
	MoveTo(_aad, _bd int32)

	// SetWidth sets the width of the anchored object. It is not compatible with
	// SetWidthCells.
	SetWidth(_adg _ae.Distance)

	// SetWidthCells sets the height the anchored object by moving the right
	// hand side. It is not compatible with SetWidth.
	SetWidthCells(_faf int32)

	// SetHeight sets the height of the anchored object. It is not compatible
	// with SetHeightCells.
	SetHeight(_bdf _ae.Distance)

	// SetHeightCells sets the height the anchored object by moving the bottom.
	// It is not compatible with SetHeight.
	SetHeightCells(_eb int32)

	// SetColOffset sets the column offset of the top-left anchor.
	SetColOffset(_eagb _ae.Distance)

	// SetRowOffset sets the row offset of the top-left anchor.
	SetRowOffset(_ca _ae.Distance)

	// Type returns the type of anchor
	Type() AnchorType
}

// Comment is a single comment within a sheet.
type Comment struct {
	_bcbf *Workbook
	_gade *_fge.CT_Comment
	_bad  *_fge.Comments
}

// GetVerticalAlignment sets the vertical alignment of a cell style.
func (_cge CellStyle) GetVerticalAlignment() _fge.ST_VerticalAlignment {
	if _cge._dece.Alignment == nil {
		return _fge.ST_VerticalAlignmentUnset
	}
	return _cge._dece.Alignment.VerticalAttr
}
func (_fecf StyleSheet) GetCellStyle(id uint32) CellStyle {
	for _ggba, _defe := range _fecf._ccde.CellXfs.Xf {
		if uint32(_ggba) == id {
			return CellStyle{_fecf._eafa, _defe, _fecf._ccde.CellXfs}
		}
	}
	return CellStyle{}
}

// GetFilename returns the name of file from which workbook was opened with full path to it
func (_fbgfe *Workbook) GetFilename() string { return _fbgfe._deff }
func (_dbg Cell) getLabelPrefix() string {
	if _dbg._dced.SAttr == nil {
		return ""
	}
	_bae := *_dbg._dced.SAttr
	_acb := _dbg._ef.StyleSheet.GetCellStyle(_bae)
	switch _acb._dece.Alignment.HorizontalAttr {
	case _fge.ST_HorizontalAlignmentLeft:
		return "\u0027"
	case _fge.ST_HorizontalAlignmentRight:
		return "\u0022"
	case _fge.ST_HorizontalAlignmentCenter:
		return "\u005e"
	case _fge.ST_HorizontalAlignmentFill:
		return "\u005c"
	default:
		return ""
	}
}

// AddGradientStop adds a color gradient stop.
func (_dbaa ColorScale) AddGradientStop(color _cea.Color) {
	_beg := _fge.NewCT_Color()
	_beg.RgbAttr = color.AsRGBAString()
	_dbaa._ceea.Color = append(_dbaa._ceea.Color, _beg)
}
func (_cged *evalContext) Sheet(name string) _bac.Context {
	for _, _fafa := range _cged._dgf._fgca.Sheets() {
		if _fafa.Name() == name {
			return _fafa.FormulaContext()
		}
	}
	return _bac.InvalidReferenceContext
}

const _dce = "\u00320\u0030\u0036\u002d\u00301\u002d\u0030\u0032\u0054\u00315\u003a0\u0034:\u0030\u0035\u005a\u0030\u0037\u003a\u00300"

// SetProtectedAndHidden sets protected and hidden for given cellStyle
func (_baea CellStyle) SetProtection(protected bool, hidden bool) {
	_baea._dece.Protection = &_fge.CT_CellProtection{LockedAttr: &protected, HiddenAttr: &hidden}
}

// SetRowOffset sets a column offset in absolute distance.
func (_dabd CellMarker) SetRowOffset(m _ae.Distance) {
	_dabd._fdd.RowOff.ST_CoordinateUnqualified = _f.Int64(int64(m / _ae.EMU))
}

// LastColumn returns the name of last column which contains data in range of context sheet's given rows.
func (_gced *evalContext) LastColumn(rowFrom, rowTo int) string {
	_fafc := _gced._dgf
	_agdg := 1
	for _dbd := rowFrom; _dbd <= rowTo; _dbd++ {
		_dag := len(_fafc.Row(uint32(_dbd)).Cells())
		if _dag > _agdg {
			_agdg = _dag
		}
	}
	return _gb.IndexToColumn(uint32(_agdg - 1))
}

// SetColor sets teh color of the databar.
func (_adcb DataBarScale) SetColor(c _cea.Color) {
	_adcb._dcec.Color = _fge.NewCT_Color()
	_adcb._dcec.Color.RgbAttr = c.AsRGBAString()
}

// SetHeightAuto sets the row height to be automatically determined.
func (_gac Row) SetHeightAuto() { _gac._feg.HtAttr = nil; _gac._feg.CustomHeightAttr = nil }
func (_cgag Sheet) validateRowCellNumbers() error {
	_bag := map[uint32]struct{}{}
	for _, _cfddg := range _cgag._defb.SheetData.Row {
		if _cfddg.RAttr != nil {
			if _, _dafc := _bag[*_cfddg.RAttr]; _dafc {
				return _c.Errorf("\u0027%\u0073'\u0020\u0072\u0065\u0075\u0073e\u0064\u0020r\u006f\u0077\u0020\u0025\u0064", _cgag.Name(), *_cfddg.RAttr)
			}
			_bag[*_cfddg.RAttr] = struct{}{}
		}
		_eagd := map[string]struct{}{}
		for _, _gcc := range _cfddg.C {
			if _gcc.RAttr == nil {
				continue
			}
			if _, _gccf := _eagd[*_gcc.RAttr]; _gccf {
				return _c.Errorf("\u0027\u0025\u0073\u0027 r\u0065\u0075\u0073\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0025\u0073", _cgag.Name(), *_gcc.RAttr)
			}
			_eagd[*_gcc.RAttr] = struct{}{}
		}
	}
	return nil
}

// SetPasswordHash sets the password hash to the input.
func (_beeb SheetProtection) SetPasswordHash(pwHash string) {
	_beeb._bbaf.PasswordAttr = _f.String(pwHash)
}

// GetLocked returns true if the cell is locked.
func (_bgfde *evalContext) GetLocked(cellRef string) bool {
	return _bgfde._dgf.Cell(cellRef).getLocked()
}

// X returns the inner wrapped XML type.
func (_dbff CellMarker) X() *_fgf.CT_Marker { return _dbff._fdd }

// ColOffset returns the offset from the row cell.
func (_afd CellMarker) ColOffset() _ae.Distance {
	if _afd._fdd.RowOff.ST_CoordinateUnqualified == nil {
		return 0
	}
	return _ae.Distance(float64(*_afd._fdd.ColOff.ST_CoordinateUnqualified) * _ae.EMU)
}

// GetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_gfg CellStyle) GetHorizontalAlignment() _fge.ST_HorizontalAlignment {
	if _gfg._dece.Alignment == nil {
		return _fge.ST_HorizontalAlignmentUnset
	}
	return _gfg._dece.Alignment.HorizontalAttr
}

// GetCachedFormulaResult returns the cached formula result if it exists. If the
// cell type is not a formula cell, the result will be the cell value if it's a
// string/number/bool cell.
func (_fda Cell) GetCachedFormulaResult() string {
	if _fda._dced.V != nil {
		return *_fda._dced.V
	}
	return ""
}

// Tables returns a slice of all defined tables in the workbook.
func (_fcae *Workbook) Tables() []Table {
	if _fcae._eafaa == nil {
		return nil
	}
	_gcbf := []Table{}
	for _, _ggfa := range _fcae._eafaa {
		_gcbf = append(_gcbf, Table{_ggfa})
	}
	return _gcbf
}

// IsDBCS returns if a workbook's default language is among DBCS.
func (_cddf *evalContext) IsDBCS() bool {
	_cccc := _cddf._dgf._fgca.CoreProperties.X().Language
	if _cccc == nil {
		return false
	}
	_degf := string(_cccc.Data)
	for _, _cada := range _ecfb {
		if _degf == _cada {
			return true
		}
	}
	return false
}

// AddCommentWithStyle adds a new comment styled in a default way
func (_acf Comments) AddCommentWithStyle(cellRef string, author string, comment string) error {
	_aef := _acf.AddComment(cellRef, author)
	_fcf := _aef.AddRun()
	_fcf.SetBold(true)
	_fcf.SetSize(10)
	_fcf.SetColor(_cea.Black)
	_fcf.SetFont("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_fcf.SetText(author + "\u003a")
	_fcf = _aef.AddRun()
	_fcf.SetSize(10)
	_fcf.SetFont("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_fcf.SetColor(_cea.Black)
	_fcf.SetText("\u000d\u000a" + comment + "\u000d\u000a")
	_eff, _cfaf := _gb.ParseCellReference(cellRef)
	if _cfaf != nil {
		return _cfaf
	}
	_acf._faff._deea[0].Shape = append(_acf._faff._deea[0].Shape, _ea.NewCommentShape(int64(_eff.ColumnIdx), int64(_eff.RowIdx-1)))
	return nil
}

const (
	StandardFormatGeneral     StandardFormat = 0
	StandardFormat0           StandardFormat = 0
	StandardFormatWholeNumber StandardFormat = 1
	StandardFormat1           StandardFormat = 1
	StandardFormat2           StandardFormat = 2
	StandardFormat3           StandardFormat = 3
	StandardFormat4           StandardFormat = 4
	StandardFormatPercent     StandardFormat = 9
	StandardFormat9           StandardFormat = 9
	StandardFormat10          StandardFormat = 10
	StandardFormat11          StandardFormat = 11
	StandardFormat12          StandardFormat = 12
	StandardFormat13          StandardFormat = 13
	StandardFormatDate        StandardFormat = 14
	StandardFormat14          StandardFormat = 14
	StandardFormat15          StandardFormat = 15
	StandardFormat16          StandardFormat = 16
	StandardFormat17          StandardFormat = 17
	StandardFormat18          StandardFormat = 18
	StandardFormatTime        StandardFormat = 19
	StandardFormat19          StandardFormat = 19
	StandardFormat20          StandardFormat = 20
	StandardFormat21          StandardFormat = 21
	StandardFormatDateTime    StandardFormat = 22
	StandardFormat22          StandardFormat = 22
	StandardFormat37          StandardFormat = 37
	StandardFormat38          StandardFormat = 38
	StandardFormat39          StandardFormat = 39
	StandardFormat40          StandardFormat = 40
	StandardFormat45          StandardFormat = 45
	StandardFormat46          StandardFormat = 46
	StandardFormat47          StandardFormat = 47
	StandardFormat48          StandardFormat = 48
	StandardFormat49          StandardFormat = 49
)

// ClearFont clears any font configuration from the cell style.
func (_ffd CellStyle) ClearFont() { _ffd._dece.FontIdAttr = nil; _ffd._dece.ApplyFontAttr = nil }
func (_fd Cell) clearValue() {
	_fd._dced.F = nil
	_fd._dced.Is = nil
	_fd._dced.V = nil
	_fd._dced.TAttr = _fge.ST_CellTypeUnset
}
func (_cdde *Sheet) getAllCellsInFormulaArrays(_bfe bool) (map[string]bool, error) {
	_aegg := _bac.NewEvaluator()
	_fgfbe := _cdde.FormulaContext()
	_eeef := map[string]bool{}
	for _, _dggca := range _cdde.Rows() {
		for _, _ddbcf := range _dggca.Cells() {
			if _ddbcf.X().F != nil {
				_dgfdb := _ddbcf.X().F.Content
				if _ddbcf.X().F.TAttr == _fge.ST_CellFormulaTypeArray {
					_gab := _aegg.Eval(_fgfbe, _dgfdb).AsString()
					if _gab.Type == _bac.ResultTypeError {
						_cf.Log.Debug("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073", _dgfdb, _gab.ErrorMessage)
						_ddbcf.X().V = nil
					}
					if _gab.Type == _bac.ResultTypeArray {
						_eba, _edcfe := _gb.ParseCellReference(_ddbcf.Reference())
						if _edcfe != nil {
							return map[string]bool{}, _edcfe
						}
						if (_bfe && len(_gab.ValueArray) == 1) || (!_bfe && len(_gab.ValueArray[0]) == 1) {
							continue
						}
						for _efea, _agda := range _gab.ValueArray {
							_bfafd := _eba.RowIdx + uint32(_efea)
							for _ffg := range _agda {
								_aedda := _gb.IndexToColumn(_eba.ColumnIdx + uint32(_ffg))
								_eeef[_c.Sprintf("\u0025\u0073\u0025\u0064", _aedda, _bfafd)] = true
							}
						}
					} else if _gab.Type == _bac.ResultTypeList {
						_eege, _ccab := _gb.ParseCellReference(_ddbcf.Reference())
						if _ccab != nil {
							return map[string]bool{}, _ccab
						}
						if _bfe || len(_gab.ValueList) == 1 {
							continue
						}
						_bdfg := _eege.RowIdx
						for _ggafb := range _gab.ValueList {
							_gafd := _gb.IndexToColumn(_eege.ColumnIdx + uint32(_ggafb))
							_eeef[_c.Sprintf("\u0025\u0073\u0025\u0064", _gafd, _bdfg)] = true
						}
					}
				}
			}
		}
	}
	return _eeef, nil
}

// GetValueAsTime retrieves the cell's value as a time.  There is no difference
// in SpreadsheetML between a time/date cell other than formatting, and that
// typically a date cell won't have a fractional component. GetValueAsTime will
// work for date cells as well.
func (_bcba Cell) GetValueAsTime() (_gd.Time, error) {
	if _bcba._dced.TAttr != _fge.ST_CellTypeUnset {
		return _gd.Time{}, _fb.New("\u0063e\u006c\u006c\u0020\u0074y\u0070\u0065\u0020\u0073\u0068o\u0075l\u0064 \u0062\u0065\u0020\u0075\u006e\u0073\u0065t")
	}
	if _bcba._dced.V == nil {
		return _gd.Time{}, _fb.New("\u0063\u0065\u006c\u006c\u0020\u0068\u0061\u0073\u0020\u006e\u006f\u0020v\u0061\u006c\u0075\u0065")
	}
	_aggg, _, _bcbd := _ba.ParseFloat(*_bcba._dced.V, 10, 128, _ba.ToNearestEven)
	if _bcbd != nil {
		return _gd.Time{}, _bcbd
	}
	_bgae := new(_ba.Float)
	_bgae.SetUint64(uint64(24 * _gd.Hour))
	_aggg.Mul(_aggg, _bgae)
	_efg, _ := _aggg.Uint64()
	_bcff := _bcba._ef.Epoch().Add(_gd.Duration(_efg))
	return _edd(_bcff), nil
}
func (_caf CellStyle) Index() uint32 {
	for _geec, _gfc := range _caf._add.Xf {
		if _caf._dece == _gfc {
			return uint32(_geec)
		}
	}
	return 0
}

type Fill struct {
	_afcd *_fge.CT_Fill
	_eeg  *_fge.CT_Fills
}

func (_ecgd PatternFill) SetBgColor(c _cea.Color) {
	_ecgd._acgb.BgColor = _fge.NewCT_Color()
	_ecgd._acgb.BgColor.RgbAttr = c.AsRGBAString()
}

// Save writes the workbook out to a writer in the zipped xlsx format.
func (_fgadg *Workbook) Save(w _ad.Writer) error {
	const _fdbf = "\u0073\u0070\u0072\u0065ad\u0073\u0068\u0065\u0065\u0074\u003a\u0077\u0062\u002e\u0053\u0061\u0076\u0065"
	if !_e.GetLicenseKey().IsLicensed() && !_cfbf {
		_c.Println("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065")
		_c.Println("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
		return _fb.New("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064")
	}
	_bffad := "\u0075n\u006b\u006e\u006f\u0077\u006e"
	if _gdec, _bbaa := w.(*_abd.File); _bbaa {
		_bffad = _gdec.Name()
	}
	if len(_fgadg._fead) == 0 {
		_gfab, _gdda := _e.GenRefId("\u0073\u0077")
		if _gdda != nil {
			_cf.Log.Error("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gdda)
			return _gdda
		}
		_fgadg._fead = _gfab
	}
	if _ffeg := _e.Track(_fgadg._fead, _fdbf, _bffad); _ffeg != nil {
		_cf.Log.Error("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _ffeg)
		return _ffeg
	}
	_cace := _ag.NewWriter(w)
	defer _cace.Close()
	_fbfa := _f.DocTypeSpreadsheet
	if _dbfb := _dg.MarshalXML(_cace, _f.BaseRelsFilename, _fgadg.Rels.X()); _dbfb != nil {
		return _dbfb
	}
	if _gdgbgg := _dg.MarshalXMLByType(_cace, _fbfa, _f.ExtendedPropertiesType, _fgadg.AppProperties.X()); _gdgbgg != nil {
		return _gdgbgg
	}
	if _bcdc := _dg.MarshalXMLByType(_cace, _fbfa, _f.CorePropertiesType, _fgadg.CoreProperties.X()); _bcdc != nil {
		return _bcdc
	}
	_fdfg := _f.AbsoluteFilename(_fbfa, _f.OfficeDocumentType, 0)
	if _ddca := _dg.MarshalXML(_cace, _fdfg, _fgadg._fefd); _ddca != nil {
		return _ddca
	}
	if _bdgc := _dg.MarshalXML(_cace, _dg.RelationsPathFor(_fdfg), _fgadg._cbag.X()); _bdgc != nil {
		return _bdgc
	}
	if _ddfec := _dg.MarshalXMLByType(_cace, _fbfa, _f.StylesType, _fgadg.StyleSheet.X()); _ddfec != nil {
		return _ddfec
	}
	for _ffeb, _fege := range _fgadg._edgb {
		if _fdcc := _dg.MarshalXMLByTypeIndex(_cace, _fbfa, _f.ThemeType, _ffeb+1, _fege); _fdcc != nil {
			return _fdcc
		}
	}
	for _dabdf, _dafd := range _fgadg._egabd {
		_dafd.Dimension.RefAttr = Sheet{_fgadg, nil, _dafd}.Extents()
		_gcbb := _f.AbsoluteFilename(_fbfa, _f.WorksheetType, _dabdf+1)
		_dg.MarshalXML(_cace, _gcbb, _dafd)
		_dg.MarshalXML(_cace, _dg.RelationsPathFor(_gcbb), _fgadg._bbea[_dabdf].X())
	}
	if _dacc := _dg.MarshalXMLByType(_cace, _fbfa, _f.SharedStringsType, _fgadg.SharedStrings.X()); _dacc != nil {
		return _dacc
	}
	if _fgadg.CustomProperties.X() != nil {
		if _ebab := _dg.MarshalXMLByType(_cace, _fbfa, _f.CustomPropertiesType, _fgadg.CustomProperties.X()); _ebab != nil {
			return _ebab
		}
	}
	if _fgadg.Thumbnail != nil {
		_cbfd := _f.AbsoluteFilename(_fbfa, _f.ThumbnailType, 0)
		_afdef, _bfafe := _cace.Create(_cbfd)
		if _bfafe != nil {
			return _bfafe
		}
		if _bcab := _ab.Encode(_afdef, _fgadg.Thumbnail, nil); _bcab != nil {
			return _bcab
		}
	}
	for _ffgf, _afg := range _fgadg._cdbc {
		_dfeee := _f.AbsoluteFilename(_fbfa, _f.ChartType, _ffgf+1)
		_dg.MarshalXML(_cace, _dfeee, _afg)
	}
	for _edgd, _fedb := range _fgadg._eafaa {
		_aba := _f.AbsoluteFilename(_fbfa, _f.TableType, _edgd+1)
		_dg.MarshalXML(_cace, _aba, _fedb)
	}
	for _acfc, _adefc := range _fgadg._beed {
		_fafeb := _f.AbsoluteFilename(_fbfa, _f.DrawingType, _acfc+1)
		_dg.MarshalXML(_cace, _fafeb, _adefc)
		if !_fgadg._gfgab[_acfc].IsEmpty() {
			_dg.MarshalXML(_cace, _dg.RelationsPathFor(_fafeb), _fgadg._gfgab[_acfc].X())
		}
	}
	for _bgbgb, _abef := range _fgadg._deea {
		_dg.MarshalXML(_cace, _f.AbsoluteFilename(_fbfa, _f.VMLDrawingType, _bgbgb+1), _abef)
	}
	for _gfeeb, _gdcgf := range _fgadg.Images {
		if _egecd := _fa.AddImageToZip(_cace, _gdcgf, _gfeeb+1, _f.DocTypeSpreadsheet); _egecd != nil {
			return _egecd
		}
	}
	if _aaeb := _dg.MarshalXML(_cace, _f.ContentTypesFilename, _fgadg.ContentTypes.X()); _aaeb != nil {
		return _aaeb
	}
	for _dfac, _efab := range _fgadg._aacf {
		if _efab == nil {
			continue
		}
		_dg.MarshalXML(_cace, _f.AbsoluteFilename(_fbfa, _f.CommentsType, _dfac+1), _efab)
	}
	if _egac := _fgadg.WriteExtraFiles(_cace); _egac != nil {
		return _egac
	}
	return _cace.Close()
}

// SetCachedFormulaResult sets the cached result of a formula. This is normally
// not needed but is used internally when expanding an array formula.
func (_cdb Cell) SetCachedFormulaResult(s string) { _cdb._dced.V = &s }
func (_bdfa DataValidation) SetComparison(t DVCompareType, op DVCompareOp) DataValidationCompare {
	_bdfa.clear()
	_bdfa._ebga.TypeAttr = _fge.ST_DataValidationType(t)
	_bdfa._ebga.OperatorAttr = _fge.ST_DataValidationOperator(op)
	return DataValidationCompare{_bdfa._ebga}
}

type WorkbookProtection struct{ _edcb *_fge.CT_WorkbookProtection }

// AddNamedCell adds a new named cell to a row and returns it. You should
// normally prefer Cell() as it will return the existing cell if the cell
// already exists, while AddNamedCell will duplicate the cell creating an
// invaild spreadsheet.
func (_ebfd Row) AddNamedCell(col string) Cell {
	_dfad := _fge.NewCT_Cell()
	_dfad.RAttr = _f.Stringf("\u0025\u0073\u0025\u0064", col, _ebfd.RowNumber())
	_gec := -1
	_afa := _gb.ColumnToIndex(col)
	for _dada, _bfg := range _ebfd._feg.C {
		_bbga, _dgfd := _gb.ParseCellReference(*_bfg.RAttr)
		if _dgfd != nil {
			return Cell{}
		}
		if _afa < _bbga.ColumnIdx {
			_gec = _dada
			break
		}
	}
	if _gec == -1 {
		_ebfd._feg.C = append(_ebfd._feg.C, _dfad)
	} else {
		_ebfd._feg.C = append(_ebfd._feg.C[:_gec], append([]*_fge.CT_Cell{_dfad}, _ebfd._feg.C[_gec:]...)...)
	}
	return Cell{_ebfd._dbe, _ebfd._gfac, _ebfd._feg, _dfad}
}

type evalContext struct {
	_dgf       *Sheet
	_gca, _cdd uint32
	_gdgf      map[string]struct{}
}

// SetBool sets the cell type to boolean and the value to the given boolean
// value.
func (_dga Cell) SetBool(v bool) {
	_dga.clearValue()
	_dga._dced.V = _f.String(_fg.Itoa(_gee(v)))
	_dga._dced.TAttr = _fge.ST_CellTypeB
}

// Column represents a column within a sheet. It's only used for formatting
// purposes, so it's possible to construct a sheet without configuring columns.
type Column struct{ _bgba *_fge.CT_Col }

// ClearNumberFormat removes any number formatting from the style.
func (_bdc CellStyle) ClearNumberFormat() {
	_bdc._dece.NumFmtIdAttr = nil
	_bdc._dece.ApplyNumberFormatAttr = nil
}

// ClearProtection removes any protections applied to teh sheet.
func (_egcf *Sheet) ClearProtection() { _egcf._defb.SheetProtection = nil }

// SetFill applies a fill to a cell style avoiding redundancy. The function checks if the given fill
// already exists in the saved fills. If found, the existing fill is reused; otherwise,
// the new fill is added to the saved fills collection. The fill is then applied to the cell style,
// affecting all styles that reference it by index.
func (_gdbc CellStyle) SetFill(f Fill) {
	_bfa := f._eeg.Fill
	for _, _fgc := range _bfa {
		if _bb.DeepEqual(_fgc, f._afcd) {
			f._afcd = _fgc
			_gdbc._dece.FillIdAttr = _f.Uint32(f.Index())
			_gdbc._dece.ApplyFillAttr = _f.Bool(true)
			return
		}
	}
	f._eeg.Fill = append(f._eeg.Fill, f._afcd)
	f._eeg.CountAttr = _f.Uint32(uint32(len(f._eeg.Fill)))
	_gdbc._dece.FillIdAttr = _f.Uint32(f.Index())
	_gdbc._dece.ApplyFillAttr = _f.Bool(true)
}

// Row is a row within a spreadsheet.
type Row struct {
	_dbe  *Workbook
	_gfac *Sheet
	_feg  *_fge.CT_Row
}

// Workbook is the top level container item for a set of spreadsheets.
type Workbook struct {
	_fa.DocBase
	_fefd         *_fge.Workbook
	StyleSheet    StyleSheet
	SharedStrings SharedStrings
	_aacf         []*_fge.Comments
	_egabd        []*_fge.Worksheet
	_bbea         []_fa.Relationships
	_cbag         _fa.Relationships
	_edgb         []*_cg.Theme
	_beed         []*_fgf.WsDr
	_gfgab        []_fa.Relationships
	_deea         []*_ea.Container
	_cdbc         []*_dc.ChartSpace
	_eafaa        []*_fge.Table
	_deff         string
	_caafe        map[string]string
	_gcae         map[string]*_dc.ChartSpace
	_fead         string
}

func (_bec Font) SetItalic(b bool) {
	_dddca := false
	for _gdff, _fgad := range _bec._caed.FontChoice {
		if _fgad.I != nil {
			if b {
				_bec._caed.FontChoice[_gdff].I = &_fge.CT_BooleanProperty{}
			} else {
				_bec._caed.FontChoice[_gdff].I = nil
			}
			_dddca = true
		}
	}
	if !_dddca {
		_bec._caed.FontChoice = append(_bec._caed.FontChoice, &_fge.CT_FontChoice{I: &_fge.CT_BooleanProperty{}})
	}
}

// ClearSheetViews clears the list of sheet views.  This will clear the results
// of AddView() or SetFrozen.
func (_cgbgd *Sheet) ClearSheetViews() { _cgbgd._defb.SheetViews = nil }
func (_gadc *Sheet) slideCellsLeft(_eca []*_fge.CT_Cell) []*_fge.CT_Cell {
	for _, _becdc := range _eca {
		_cagc, _fgadf := _gb.ParseCellReference(*_becdc.RAttr)
		if _fgadf != nil {
			return _eca
		}
		_fggg := _cagc.ColumnIdx - 1
		_gbdaf := _gb.IndexToColumn(_fggg) + _c.Sprintf("\u0025\u0064", _cagc.RowIdx)
		_becdc.RAttr = &_gbdaf
	}
	return _eca
}

type DifferentialStyle struct {
	_ceag  *_fge.CT_Dxf
	_adgec *Workbook
	_eefe  *_fge.CT_Dxfs
}

// Name returns the name of the defined name.
func (_dcca DefinedName) Name() string { return _dcca._cgaa.NameAttr }

// DefinedNames returns a slice of all defined names in the workbook.
func (_fgcb *Workbook) DefinedNames() []DefinedName {
	if _fgcb._fefd.DefinedNames == nil {
		return nil
	}
	_gefeb := []DefinedName{}
	for _, _ggdd := range _fgcb._fefd.DefinedNames.DefinedName {
		_gefeb = append(_gefeb, DefinedName{_ggdd})
	}
	return _gefeb
}

// Cell is a single cell within a sheet.
type Cell struct {
	_ef   *Workbook
	_eg   *Sheet
	_ega  *_fge.CT_Row
	_dced *_fge.CT_Cell
}

// StyleSheet is a document style sheet.
type StyleSheet struct {
	_eafa *Workbook
	_ccde *_fge.StyleSheet
}

// SetDate sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel). The cell is not styled via this method, so it will
// display as a number. SetDateWithStyle should normally be used instead.
func (_fbe Cell) SetDate(d _gd.Time) {
	_fbe.clearValue()
	d = _gdg(d)
	_ddg := _fbe._ef.Epoch()
	if d.Before(_ddg) {
		_cf.Log.Debug("d\u0061\u0074\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064")
		return
	}
	_faa := d.Sub(_ddg)
	_gg := new(_ba.Float)
	_gaef := new(_ba.Float)
	_gaef.SetPrec(128)
	_gaef.SetUint64(uint64(_faa))
	_gag := new(_ba.Float)
	_gag.SetUint64(24 * 60 * 60 * 1e9)
	_gg.Quo(_gaef, _gag)
	_bcfa, _ := _gg.Uint64()
	_fbe._dced.V = _f.Stringf("\u0025\u0064", _bcfa)
}
func (_ee Border) SetTop(style _fge.ST_BorderStyle, c _cea.Color) {
	if _ee._ed.Top == nil {
		_ee._ed.Top = _fge.NewCT_BorderPr()
	}
	_ee._ed.Top.Color = _fge.NewCT_Color()
	_ee._ed.Top.Color.RgbAttr = c.AsRGBAString()
	_ee._ed.Top.StyleAttr = style
}

// Drawing is a drawing overlay on a sheet.  Only a single drawing is allowed
// per sheet, so to display multiple charts and images on a single sheet, they
// must be added to the same drawing.
type Drawing struct {
	_dfbc *Workbook
	_caeb *_fgf.WsDr
}

// AddFormatValue adds a format value to be used in determining which icons to display.
func (_acag IconScale) AddFormatValue(t _fge.ST_CfvoType, val string) {
	_aeca := _fge.NewCT_Cfvo()
	_aeca.TypeAttr = t
	_aeca.ValAttr = _f.String(val)
	_acag._gbffb.Cfvo = append(_acag._gbffb.Cfvo, _aeca)
}

// SheetText is an array of extracted text items which has some methods for representing extracted text from a sheet.
type SheetText struct{ Cells []CellText }

// TopLeft returns the top-left corner of the anchored object.
func (_deaa OneCellAnchor) TopLeft() CellMarker { return CellMarker{_deaa._gfgaf.From} }

// CellStyles returns the list of defined cell styles
func (_egbd StyleSheet) CellStyles() []CellStyle {
	_aedbf := []CellStyle{}
	for _, _dcfg := range _egbd._ccde.CellXfs.Xf {
		_aedbf = append(_aedbf, CellStyle{_egbd._eafa, _dcfg, _egbd._ccde.CellXfs})
	}
	return _aedbf
}
func (_ebb Row) renumberAs(_gfcc uint32) {
	_ebb._feg.RAttr = _f.Uint32(_gfcc)
	for _, _bgbg := range _ebb.Cells() {
		_cadc, _gbb := _gb.ParseCellReference(_bgbg.Reference())
		if _gbb == nil {
			_feb := _c.Sprintf("\u0025\u0073\u0025\u0064", _cadc.Column, _gfcc)
			_bgbg._dced.RAttr = _f.String(_feb)
		}
	}
}
func (_fef DataValidation) clear() {
	_fef._ebga.Formula1 = _f.String("\u0030")
	_fef._ebga.Formula2 = _f.String("\u0030")
}

// SheetViews returns the sheet views defined.  This is where splits and frozen
// rows/cols are configured.  Multiple sheet views are allowed, but I'm not
// aware of there being a use for more than a single sheet view.
func (_aeea *Sheet) SheetViews() []SheetView {
	if _aeea._defb.SheetViews == nil {
		return nil
	}
	_dege := []SheetView{}
	for _, _bbeeg := range _aeea._defb.SheetViews.SheetView {
		_dege = append(_dege, SheetView{_bbeeg})
	}
	return _dege
}

// GetChartByTargetId returns the array of workbook crt.ChartSpace.
func (_adefd *Workbook) GetChartByTargetId(targetAttr string) *_dc.ChartSpace {
	return _adefd._gcae[targetAttr]
}

// SetState sets the sheet view state (frozen/split/frozen-split)
func (_ggda SheetView) SetState(st _fge.ST_PaneState) {
	_ggda.ensurePane()
	_ggda._gfdfg.Pane.StateAttr = st
}

// HasNumberFormat returns true if the cell style has a number format applied.
func (_daa CellStyle) HasNumberFormat() bool {
	return _daa._dece.NumFmtIdAttr != nil && _daa._dece.ApplyNumberFormatAttr != nil && *_daa._dece.ApplyNumberFormatAttr
}

// SetColOffset sets the column offset of the top-left of the image in fixed units.
func (_cc AbsoluteAnchor) SetColOffset(m _ae.Distance) {
	_cc._fcc.Pos.XAttr.ST_CoordinateUnqualified = _f.Int64(int64(m / _ae.EMU))
}

// SetHidden marks the defined name as hidden.
func (_fgee DefinedName) SetLocalSheetID(id uint32) { _fgee._cgaa.LocalSheetIdAttr = _f.Uint32(id) }

// SetLocked sets cell locked or not.
func (_ecf *evalContext) SetLocked(cellRef string, locked bool) {
	_ecf._dgf.Cell(cellRef).setLocked(locked)
}
func (_aee Border) SetLeft(style _fge.ST_BorderStyle, c _cea.Color) {
	if _aee._ed.Left == nil {
		_aee._ed.Left = _fge.NewCT_BorderPr()
	}
	_aee._ed.Left.Color = _fge.NewCT_Color()
	_aee._ed.Left.Color.RgbAttr = c.AsRGBAString()
	_aee._ed.Left.StyleAttr = style
}

// Author returns the author of the comment
func (_gge Comment) Author() string {
	if _gge._gade.AuthorIdAttr < uint32(len(_gge._bad.Authors.Author)) {
		return _gge._bad.Authors.Author[_gge._gade.AuthorIdAttr]
	}
	return ""
}

// MaxColumnIdx returns the max used column of the sheet.
func (_bced Sheet) MaxColumnIdx() uint32 {
	_aedb := uint32(0)
	for _, _fbab := range _bced.Rows() {
		_bdee := _fbab._feg.C
		if len(_bdee) > 0 {
			_ebcf := _bdee[len(_bdee)-1]
			_fcec, _ := _gb.ParseCellReference(*_ebcf.RAttr)
			if _aedb < _fcec.ColumnIdx {
				_aedb = _fcec.ColumnIdx
			}
		}
	}
	return _aedb
}
func (_ceacd Font) SetName(name string) {
	_cgdg := false
	for _ead, _cgec := range _ceacd._caed.FontChoice {
		if _cgec.Name != nil {
			_ceacd._caed.FontChoice[_ead].Name = &_fge.CT_FontName{ValAttr: name}
			_cgdg = true
		}
	}
	if !_cgdg {
		_ceacd._caed.FontChoice = append(_ceacd._caed.FontChoice, &_fge.CT_FontChoice{Name: &_fge.CT_FontName{ValAttr: name}})
	}
}

var ErrorNotFound = _fb.New("\u006eo\u0074\u0020\u0066\u006f\u0075\u006ed")

// GetString retrieves a string from the shared strings table by index.
func (_fgec SharedStrings) GetString(id int) (string, error) {
	if id < 0 {
		return "", _c.Errorf("\u0069\u006eva\u006c\u0069\u0064 \u0073\u0074\u0072\u0069ng \u0069nd\u0065\u0078\u0020\u0025\u0064\u002c\u0020mu\u0073\u0074\u0020\u0062\u0065\u0020\u003e \u0030", id)
	}
	if id > len(_fgec._ebge.Si)-1 {
		return "", _c.Errorf("\u0069\u006e\u0076\u0061\u006c\u0069d\u0020\u0073\u0074\u0072\u0069\u006e\u0067\u0020\u0069\u006e\u0064\u0065\u0078\u0020\u0025\u0064\u002c\u0020\u0074\u0061b\u006c\u0065\u0020\u006f\u006e\u006c\u0079\u0020\u0068\u0061\u0073\u0020\u0025\u0064 \u0076a\u006c\u0075\u0065\u0073", id, len(_fgec._ebge.Si))
	}
	_cde := _fgec._ebge.Si[id]
	if _cde.T != nil {
		return *_cde.T, nil
	}
	_gfde := ""
	for _, _befe := range _cde.R {
		if _befe.T != "" {
			_gfde += _befe.T
		}
	}
	return _gfde, nil
}

// CellText is used for keeping text with references to a cell where it is located.
type CellText struct {
	Text string
	Cell Cell
}

func (_fccbd Sheet) validateSheetNames() error {
	_degc := len([]rune(_fccbd.Name()))
	if _degc > 31 {
		return _c.Errorf("\u0073\u0068\u0065\u0065\u0074 \u006e\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073 \u0025\u0064\u0020\u0063\u0068\u0061\u0072\u0061\u0063\u0074\u0065\u0072\u0073\u002c\u0020\u006d\u0061\u0078\u0020\u006c\u0065\u006e\u0067\u0074\u0068\u0020\u0069\u0073\u0020\u00331", _fccbd.Name(), _degc)
	}
	return nil
}

// SetColOffset sets the column offset of the top-left anchor.
func (_baf OneCellAnchor) SetColOffset(m _ae.Distance) { _baf.TopLeft().SetColOffset(m) }
func (_edfc Sheet) ExtentsIndex() (string, uint32, string, uint32) {
	var _eacc, _effe, _efca, _adcd uint32 = 1, 1, 0, 0
	for _, _debg := range _edfc.Rows() {
		if _debg.RowNumber() < _eacc {
			_eacc = _debg.RowNumber()
		} else if _debg.RowNumber() > _effe {
			_effe = _debg.RowNumber()
		}
		for _, _decgc := range _debg.Cells() {
			_dgba, _ffaf := _gb.ParseCellReference(_decgc.Reference())
			if _ffaf == nil {
				if _dgba.ColumnIdx < _efca {
					_efca = _dgba.ColumnIdx
				} else if _dgba.ColumnIdx > _adcd {
					_adcd = _dgba.ColumnIdx
				}
			}
		}
	}
	return _gb.IndexToColumn(_efca), _eacc, _gb.IndexToColumn(_adcd), _effe
}

// SetTime sets the cell value to a date. It's stored as the number of days past
// th sheet epoch. When we support v5 strict, we can store an ISO 8601 date
// string directly, however that's not allowed with v5 transitional  (even
// though it works in Excel).
func (_cef Cell) SetTime(d _gd.Time) {
	_cef.clearValue()
	d = _gdg(d)
	_agd := _cef._ef.Epoch()
	if d.Before(_agd) {
		_cf.Log.Debug("t\u0069\u006d\u0065\u0073\u0020\u0062e\u0066\u006f\u0072\u0065\u0020\u00319\u0030\u0030\u0020\u0061\u0072\u0065\u0020n\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074e\u0064")
		return
	}
	_bab := d.Sub(_agd)
	_efc := new(_ba.Float)
	_aggb := new(_ba.Float)
	_aggb.SetPrec(128)
	_aggb.SetUint64(uint64(_bab))
	_aadb := new(_ba.Float)
	_aadb.SetUint64(24 * 60 * 60 * 1e9)
	_efc.Quo(_aggb, _aadb)
	_cef._dced.V = _f.String(_efc.Text('g', 20))
}

// SetWidthCells sets the height the anchored object by moving the right hand
// side. It is not compatible with SetWidth.
func (_bffbc TwoCellAnchor) SetWidthCells(w int32) {
	_bcbb := _bffbc.TopLeft()
	_eaga := _bffbc.BottomRight()
	_eaga.SetCol(_bcbb.Col() + w)
}

// Sheet is a single sheet within a workbook.
type Sheet struct {
	_fgca  *Workbook
	_bgfdd *_fge.CT_Sheet
	_defb  *_fge.Worksheet
}

// Borders returns the list of borders defined in the stylesheet.
func (_baff StyleSheet) Borders() []Border {
	_ccdb := []Border{}
	for _, _aefb := range _baff._ccde.Borders.Border {
		_ccdb = append(_ccdb, Border{_ed: _aefb})
	}
	return _ccdb
}

// RowOffset returns the offset from the row cell.
func (_bgfd CellMarker) RowOffset() _ae.Distance {
	if _bgfd._fdd.RowOff.ST_CoordinateUnqualified == nil {
		return 0
	}
	return _ae.Distance(float64(*_bgfd._fdd.RowOff.ST_CoordinateUnqualified) * _ae.EMU)
}

// Column returns the cell column
func (_dca Cell) Column() (string, error) {
	_cfa, _aff := _gb.ParseCellReference(_dca.Reference())
	if _aff != nil {
		return "", _aff
	}
	return _cfa.Column, nil
}

// Extents returns the sheet extents in the form "A1:B15". This requires
// scanning the entire sheet.
func (_ddfa Sheet) Extents() string {
	_bdbca, _cddad, _cgaga, _fddeb := _ddfa.ExtentsIndex()
	return _c.Sprintf("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d", _bdbca, _cddad, _cgaga, _fddeb)
}

// AddRule adds and returns a new rule that can be configured.
func (_dfb ConditionalFormatting) AddRule() ConditionalFormattingRule {
	_cdba := _fge.NewCT_CfRule()
	_dfb._addb.CfRule = append(_dfb._addb.CfRule, _cdba)
	_ecg := ConditionalFormattingRule{_cdba}
	_ecg.InitializeDefaults()
	_ecg.SetPriority(int32(len(_dfb._addb.CfRule) + 1))
	return _ecg
}

// SetRange sets the range that contains the possible values. This is incompatible with SetValues.
func (_dgaa DataValidationList) SetRange(cellRange string) {
	_dgaa._cddg.Formula1 = _f.String(cellRange)
	_dgaa._cddg.Formula2 = _f.String("\u0030")
}

// LessRows compares two rows based off of a column. If the column doesn't exist
// in one row, that row is 'less'.
func (_geg Comparer) LessRows(column string, lhs, rhs Row) bool {
	var _gaee, _afc Cell
	for _, _aae := range lhs.Cells() {
		_abg, _ := _gb.ParseCellReference(_aae.Reference())
		if _abg.Column == column {
			_gaee = _aae
			break
		}
	}
	for _, _eeca := range rhs.Cells() {
		_dedf, _ := _gb.ParseCellReference(_eeca.Reference())
		if _dedf.Column == column {
			_afc = _eeca
			break
		}
	}
	return _geg.LessCells(_gaee, _afc)
}

// SetWidthCells is a no-op.
func (_dbgce OneCellAnchor) SetWidthCells(int32) {}

// SetYSplit sets the row split point
func (_bbagf SheetView) SetYSplit(v float64) {
	_bbagf.ensurePane()
	_bbagf._gfdfg.Pane.YSplitAttr = _f.Float64(v)
}

// LockObject controls the locking of the sheet objects.
func (_ddbf SheetProtection) LockObject(b bool) {
	if !b {
		_ddbf._bbaf.ObjectsAttr = nil
	} else {
		_ddbf._bbaf.ObjectsAttr = _f.Bool(true)
	}
}

// X returns the inner XML entity for a stylesheet.
func (_cccf StyleSheet) X() *_fge.StyleSheet { return _cccf._ccde }

// SetStyle sets the cell style for an entire column.
func (_gbcg Column) SetStyle(cs CellStyle) { _gbcg._bgba.StyleAttr = _f.Uint32(cs.Index()) }

// Clear clears the cell's value and type.
func (_geb Cell) Clear() { _geb.clearValue(); _geb._dced.TAttr = _fge.ST_CellTypeUnset }

// SetPattern sets the pattern of the fill.
func (_abdd PatternFill) SetPattern(p _fge.ST_PatternType) { _abdd._acgb.PatternTypeAttr = p }

// AddHyperlink creates and sets a hyperlink on a cell.
func (_cb Cell) AddHyperlink(url string) {
	for _dfaa, _bcfc := range _cb._ef._egabd {
		if _bcfc == _cb._eg._defb {
			_cb.SetHyperlink(_cb._ef._bbea[_dfaa].AddHyperlink(url))
			return
		}
	}
}

// X returns the inner wrapped XML type.
func (_aaca ColorScale) X() *_fge.CT_ColorScale { return _aaca._ceea }
func _edd(_dec _gd.Time) _gd.Time {
	_dec = _dec.UTC()
	return _gd.Date(_dec.Year(), _dec.Month(), _dec.Day(), _dec.Hour(), _dec.Minute(), _dec.Second(), _dec.Nanosecond(), _gd.Local)
}

// SetHyperlink sets a hyperlink on a cell.
func (_baba Cell) SetHyperlink(hl _fa.Hyperlink) {
	_fffa := _baba._eg._defb
	if _fffa.Hyperlinks == nil {
		_fffa.Hyperlinks = _fge.NewCT_Hyperlinks()
	}
	_ggb := _fa.Relationship(hl)
	_ecd := _fge.NewCT_Hyperlink()
	_ecd.RefAttr = _baba.Reference()
	_ecd.IdAttr = _f.String(_ggb.ID())
	_fffa.Hyperlinks.Hyperlink = append(_fffa.Hyperlinks.Hyperlink, _ecd)
}

// SetSize sets the text size for a rich text run.
func (_geda RichTextRun) SetSize(m _ae.Distance) {
	_geda.ensureRpr()
	_dae := float64(m / _ae.Point)
	for _, _ffcb := range _geda._gbe.RPr.RPrEltChoice {
		if _ffcb.Sz != nil {
			_ffcb.Sz.ValAttr = _dae
			return
		}
	}
	_geda._gbe.RPr.RPrEltChoice = append(_geda._gbe.RPr.RPrEltChoice, &_fge.CT_RPrEltChoice{Sz: &_fge.CT_FontSize{ValAttr: _dae}})
}

// GetFormat sets the number format code.
func (_gebg NumberFormat) GetFormat() string { return _gebg._gage.FormatCodeAttr }
func (_edaa *Sheet) setArray(_aegb string, _bdad _bac.Result) error {
	_daeb, _fbccc := _gb.ParseCellReference(_aegb)
	if _fbccc != nil {
		return _fbccc
	}
	for _affef, _eaed := range _bdad.ValueArray {
		_befd := _edaa.Row(_daeb.RowIdx + uint32(_affef))
		for _caadf, _aade := range _eaed {
			_ggg := _befd.Cell(_gb.IndexToColumn(_daeb.ColumnIdx + uint32(_caadf)))
			if _aade.Type != _bac.ResultTypeEmpty {
				if _aade.IsBoolean {
					_ggg.SetBool(_aade.ValueNumber != 0)
				} else {
					_ggg.SetCachedFormulaResult(_aade.String())
				}
			}
		}
	}
	return nil
}

// SetRange sets the cell or range of cells that the validation should apply to.
// It can be a single cell (e.g. "A1") or a range of cells (e.g. "A1:B5")
func (_adcf DataValidation) SetRange(cellRange string) {
	_adcf._ebga.SqrefAttr = _fge.ST_Sqref{cellRange}
}

// SetHeight sets the row height in points.
func (_fgabb Row) SetHeight(d _ae.Distance) {
	_fgabb._feg.HtAttr = _f.Float64(float64(d))
	_fgabb._feg.CustomHeightAttr = _f.Bool(true)
}
func (_daff *Sheet) setList(_eccd string, _fbfgg _bac.Result) error {
	_aged, _acagf := _gb.ParseCellReference(_eccd)
	if _acagf != nil {
		return _acagf
	}
	_cgce := _daff.Row(_aged.RowIdx)
	for _afdb, _fdag := range _fbfgg.ValueList {
		_cdfg := _cgce.Cell(_gb.IndexToColumn(_aged.ColumnIdx + uint32(_afdb)))
		if _fdag.Type != _bac.ResultTypeEmpty {
			if _fdag.IsBoolean {
				_cdfg.SetBool(_fdag.ValueNumber != 0)
			} else {
				_cdfg.SetCachedFormulaResult(_fdag.String())
			}
		}
	}
	return nil
}

// SheetView is a view of a sheet. There is typically one per sheet, though more
// are supported.
type SheetView struct{ _gfdfg *_fge.CT_SheetView }

func (_aabc SortOrder) String() string {
	if _aabc >= SortOrder(len(_fedd)-1) {
		return _c.Sprintf("\u0053\u006f\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0028\u0025\u0064\u0029", _aabc)
	}
	return _gageb[_fedd[_aabc]:_fedd[_aabc+1]]
}

// SetWidth is a no-op.
func (_egfg TwoCellAnchor) SetWidth(w _ae.Distance) {}

// Close closes the workbook, removing any temporary files that might have been
// created when opening a document.
func (_fag *Workbook) Close() error {
	if _fag.TmpPath != "" {
		return _ce.RemoveAll(_fag.TmpPath)
	}
	return nil
}

// X returns the inner wrapped XML type.
func (_afef *Workbook) X() *_fge.Workbook { return _afef._fefd }

// Cells returns a slice of cells.  The cells can be manipulated, but appending
// to the slice will have no effect.
func (_cfce Row) Cells() []Cell {
	_dfaae := []Cell{}
	_cfgd := -1
	_ced := append([]*_fge.CT_Cell{}, _cfce._feg.C...)
	for _, _cfab := range _ced {
		if _cfab.RAttr == nil {
			_cf.Log.Debug("\u0052\u0041\u0074tr\u0020\u0069\u0073\u0020\u006e\u0069\u006c\u0020\u0066o\u0072 \u0061 \u0063e\u006c\u006c\u002c\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e")
			continue
		}
		_fbfga, _aecg := _gb.ParseCellReference(*_cfab.RAttr)
		if _aecg != nil {
			_cf.Log.Debug("\u0052\u0041\u0074t\u0072\u0020\u0069\u0073 \u0069\u006e\u0063\u006f\u0072\u0072\u0065c\u0074\u0020\u0066\u006f\u0072\u0020\u0061\u0020\u0063\u0065\u006c\u006c\u003a\u0020" + *_cfab.RAttr + ",\u0020\u0073\u006b\u0069\u0070\u0070\u0069\u006e\u0067\u002e")
			continue
		}
		_adfa := int(_fbfga.ColumnIdx)
		if _adfa-_cfgd > 1 {
			for _gaab := _cfgd + 1; _gaab < _adfa; _gaab++ {
				_dfaae = append(_dfaae, _cfce.Cell(_gb.IndexToColumn(uint32(_gaab))))
			}
		}
		_cfgd = _adfa
		_dfaae = append(_dfaae, Cell{_cfce._dbe, _cfce._gfac, _cfce._feg, _cfab})
	}
	return _dfaae
}

// SetStyle sets the style to be used for conditional rules
func (_gbff ConditionalFormattingRule) SetStyle(d DifferentialStyle) {
	_gbff._gcgc.DxfIdAttr = _f.Uint32(d.Index())
}

// X returns the inner wrapped XML type.
func (_cegf Drawing) X() *_fgf.WsDr { return _cegf._caeb }

// Workbook returns sheet's parent workbook.
func (_edbe *Sheet) Workbook() *Workbook { return _edbe._fgca }

// SetMaxLength sets the maximum bar length in percent.
func (_cbf DataBarScale) SetMaxLength(l uint32) { _cbf._dcec.MaxLengthAttr = _f.Uint32(l) }

// Sort sorts all of the rows within a sheet by the contents of a column. As the
// file format doesn't suppot indicating that a column should be sorted by the
// viewing/editing program, we actually need to reorder rows and change cell
// references during a sort. If the sheet contains formulas, you should call
// RecalculateFormulas() prior to sorting.  The column is in the form "C" and
// specifies the column to sort by. The firstRow is a 1-based index and
// specifies the firstRow to include in the sort, allowing skipping over a
// header row.
func (_defbc *Sheet) Sort(column string, firstRow uint32, order SortOrder) {
	_cec := _defbc._defb.SheetData.Row
	_eebe := _defbc.Rows()
	for _deac, _ddbc := range _eebe {
		if _ddbc.RowNumber() == firstRow {
			_cec = _defbc._defb.SheetData.Row[_deac:]
			break
		}
	}
	_agfc := Comparer{Order: order}
	_aa.Slice(_cec, func(_ebbe, _dgdg int) bool {
		return _agfc.LessRows(column, Row{_defbc._fgca, _defbc, _cec[_ebbe]}, Row{_defbc._fgca, _defbc, _cec[_dgdg]})
	})
	for _eeeg, _dcd := range _defbc.Rows() {
		_gfdb := uint32(_eeeg + 1)
		if _dcd.RowNumber() != _gfdb {
			_dcd.renumberAs(_gfdb)
		}
	}
}

// SetRotation configures the cell to be rotated.
func (_abf CellStyle) SetRotation(deg uint8) {
	if _abf._dece.Alignment == nil {
		_abf._dece.Alignment = _fge.NewCT_CellAlignment()
	}
	_abf._dece.ApplyAlignmentAttr = _f.Bool(true)
	_abf._dece.Alignment.TextRotationAttr = _f.Uint8(deg)
}

// GetBorder gets a Border from a cell style.
func (_gfd CellStyle) GetBorder() *_fge.CT_Border {
	if _edb := _gfd._dece.BorderIdAttr; _edb != nil {
		_fad := _gfd._decg.StyleSheet.Borders()
		if int(*_edb) < len(_fad) {
			return _fad[int(*_edb)].X()
		}
	}
	return nil
}
func (_fgea RichTextRun) ensureRpr() {
	if _fgea._gbe.RPr == nil {
		_fgea._gbe.RPr = _fge.NewCT_RPrElt()
	}
	if _fgea._gbe.RPr.RPrEltChoice == nil {
		_fgea._gbe.RPr.RPrEltChoice = []*_fge.CT_RPrEltChoice{}
	}
}
func (_ggbf Sheet) validateMergedCells() error {
	_addg := map[uint64]struct{}{}
	for _, _gcdb := range _ggbf.MergedCells() {
		_bedd, _edae, _caee := _gb.ParseRangeReference(_gcdb.Reference())
		if _caee != nil {
			return _c.Errorf("\u0073\u0068e\u0065\u0074\u0020\u006e\u0061m\u0065\u0020\u0027\u0025\u0073'\u0020\u0068\u0061\u0073\u0020\u0069\u006e\u0076\u0061\u006c\u0069\u0064\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006c\u006c\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u0020\u0025\u0073", _ggbf.Name(), _gcdb.Reference())
		}
		for _gageg := _bedd.RowIdx; _gageg <= _edae.RowIdx; _gageg++ {
			for _fdbd := _bedd.ColumnIdx; _fdbd <= _edae.ColumnIdx; _fdbd++ {
				_ggbb := uint64(_gageg)<<32 | uint64(_fdbd)
				if _, _afaf := _addg[_ggbb]; _afaf {
					return _c.Errorf("\u0073\u0068\u0065\u0065\u0074\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027\u0020\u0068\u0061\u0073\u0020\u006f\u0076\u0065\u0072\u006c\u0061\u0070p\u0069\u006e\u0067\u0020\u006d\u0065\u0072\u0067\u0065\u0064\u0020\u0063\u0065\u006cl\u0020r\u0061\u006e\u0067\u0065", _ggbf.Name())
				}
				_addg[_ggbb] = struct{}{}
			}
		}
	}
	return nil
}

// SetName sets the sheet name.
func (_fafcb *Sheet) SetName(name string) { _fafcb._bgfdd.NameAttr = name }

var _fedd = [...]uint8{0, 18, 37}

// Wrapped returns true if the cell will wrap text.
func (_aadc CellStyle) Wrapped() bool {
	if _aadc._dece.Alignment == nil {
		return false
	}
	if _aadc._dece.Alignment.WrapTextAttr == nil {
		return false
	}
	return *_aadc._dece.Alignment.WrapTextAttr
}

// ClearBorder clears any border configuration from the cell style.
func (_dcac CellStyle) ClearBorder() {
	_dcac._dece.BorderIdAttr = nil
	_dcac._dece.ApplyBorderAttr = nil
}

// Border is a cell border configuraton.
type Border struct {
	_ed  *_fge.CT_Border
	_cfb *_fge.CT_Borders
}

// AddNumberedRow adds a row with a given row number.  If you reuse a row number
// the resulting file will fail validation and fail to open in Office programs. Use
// Row instead which creates a new row or returns an existing row.
func (_ddf *Sheet) AddNumberedRow(rowNum uint32) Row {
	_gbeb := _fge.NewCT_Row()
	_gbeb.RAttr = _f.Uint32(rowNum)
	_ddf._defb.SheetData.Row = append(_ddf._defb.SheetData.Row, _gbeb)
	_aa.Slice(_ddf._defb.SheetData.Row, func(_bdbc, _eccg int) bool {
		_gefe := _ddf._defb.SheetData.Row[_bdbc].RAttr
		_ceeg := _ddf._defb.SheetData.Row[_eccg].RAttr
		if _gefe == nil {
			return true
		}
		if _ceeg == nil {
			return true
		}
		return *_gefe < *_ceeg
	})
	return Row{_ddf._fgca, _ddf, _gbeb}
}
func (_gadg Comments) getOrCreateAuthor(_bbdf string) uint32 {
	for _baa, _dbaac := range _gadg._dfef.Authors.Author {
		if _dbaac == _bbdf {
			return uint32(_baa)
		}
	}
	_eea := uint32(len(_gadg._dfef.Authors.Author))
	_gadg._dfef.Authors.Author = append(_gadg._dfef.Authors.Author, _bbdf)
	return _eea
}

// LockSheet controls the locking of the sheet.
func (_aace SheetProtection) LockSheet(b bool) {
	if !b {
		_aace._bbaf.SheetAttr = nil
	} else {
		_aace._bbaf.SheetAttr = _f.Bool(true)
	}
}
func (_ffce StyleSheet) appendBorder() Border {
	_bdgedd := _fge.NewCT_Border()
	_ffce._ccde.Borders.Border = append(_ffce._ccde.Borders.Border, _bdgedd)
	_ffce._ccde.Borders.CountAttr = _f.Uint32(uint32(len(_ffce._ccde.Borders.Border)))
	return Border{_bdgedd, _ffce._ccde.Borders}
}

// Comments returns the comments for a sheet.
func (_gdgbg *Sheet) Comments() Comments {
	for _bbdfd, _bfaf := range _gdgbg._fgca._egabd {
		if _bfaf == _gdgbg._defb {
			if _gdgbg._fgca._aacf[_bbdfd] == nil {
				_gdgbg._fgca._aacf[_bbdfd] = _fge.NewComments()
				_gdgbg._fgca._bbea[_bbdfd].AddAutoRelationship(_f.DocTypeSpreadsheet, _f.WorksheetType, _bbdfd+1, _f.CommentsType)
				_gdgbg._fgca.ContentTypes.AddOverride(_f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.CommentsType, _bbdfd+1), _f.CommentsContentType)
			}
			if len(_gdgbg._fgca._deea) == 0 {
				_gdgbg._fgca._deea = append(_gdgbg._fgca._deea, _ea.NewCommentDrawing())
				_bggf := _gdgbg._fgca._bbea[_bbdfd].AddAutoRelationship(_f.DocTypeSpreadsheet, _f.WorksheetType, 1, _f.VMLDrawingType)
				if _gdgbg._defb.LegacyDrawing == nil {
					_gdgbg._defb.LegacyDrawing = _fge.NewCT_LegacyDrawing()
				}
				_gdgbg._defb.LegacyDrawing.IdAttr = _bggf.ID()
			}
			return Comments{_gdgbg._fgca, _gdgbg._fgca._aacf[_bbdfd]}
		}
	}
	_cf.Log.Debug("\u0061\u0074\u0074\u0065\u006dp\u0074\u0065\u0064\u0020\u0074\u006f\u0020\u0061\u0063\u0063\u0065\u0073\u0073 \u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u0020\u0066\u006f\u0072\u0020\u006e\u006f\u006e\u002d\u0065\u0078\u0069\u0073\u0074\u0065\u006e\u0074\u0020\u0073\u0068\u0065\u0065t")
	return Comments{}
}

// IsWindowLocked returns whether the workbook windows are locked.
func (_fbec WorkbookProtection) IsWindowLocked() bool {
	return _fbec._edcb.LockWindowsAttr != nil && *_fbec._edcb.LockWindowsAttr
}

// Protection allows control over the workbook protections.
func (_adfc *Workbook) Protection() WorkbookProtection {
	if _adfc._fefd.WorkbookProtection == nil {
		_adfc._fefd.WorkbookProtection = _fge.NewCT_WorkbookProtection()
	}
	return WorkbookProtection{_adfc._fefd.WorkbookProtection}
}

// Index returns the index of the border for use with a cell style.
func (_bbe Border) Index() uint32 {
	for _bga, _eaf := range _bbe._cfb.Border {
		if _eaf == _bbe._ed {
			return uint32(_bga)
		}
	}
	return 0
}

// CellStyle is a formatting style for a cell. CellStyles are spreadsheet global
// and can be applied to cells across sheets.
type CellStyle struct {
	_decg *Workbook
	_dece *_fge.CT_Xf
	_add  *_fge.CT_CellXfs
}

// SetHeightCells is a no-op.
func (_bdce OneCellAnchor) SetHeightCells(int32) {}

// X returns the inner wrapped XML type.
func (_cgb DefinedName) X() *_fge.CT_DefinedName { return _cgb._cgaa }

var _gggb = _f.RelativeFilename(_f.DocTypeSpreadsheet, _f.OfficeDocumentType, _f.SharedStringsType, 0)

// IsError returns true if the cell is an error type cell.
func (_ccc Cell) IsError() bool { return _ccc._dced.TAttr == _fge.ST_CellTypeE }

// DataValidationCompare is a view on a data validation rule that is oriented
// towards value comparisons.
type DataValidationCompare struct{ _ccb *_fge.CT_DataValidation }

// SetRowOffset sets the row offset of the top-left of the image in fixed units.
func (_af AbsoluteAnchor) SetRowOffset(m _ae.Distance) {
	_af._fcc.Pos.YAttr.ST_CoordinateUnqualified = _f.Int64(int64(m / _ae.EMU))
}

// MoveTo moves the top-left of the anchored object.
func (_begb OneCellAnchor) MoveTo(col, row int32) {
	_begb.TopLeft().SetCol(col)
	_begb.TopLeft().SetRow(row)
}

// SetItalic causes the text to be displayed in italic.
func (_afea RichTextRun) SetItalic(b bool) {
	_afea.ensureRpr()
	for _, _gbca := range _afea._gbe.RPr.RPrEltChoice {
		if _gbca.I != nil {
			_gbca.I.ValAttr = _f.Bool(b)
			return
		}
	}
	_afea._gbe.RPr.RPrEltChoice = append(_afea._gbe.RPr.RPrEltChoice, &_fge.CT_RPrEltChoice{I: &_fge.CT_BooleanProperty{ValAttr: _f.Bool(b)}})
}
func (_da Border) SetDiagonal(style _fge.ST_BorderStyle, c _cea.Color, up, down bool) {
	if _da._ed.Diagonal == nil {
		_da._ed.Diagonal = _fge.NewCT_BorderPr()
	}
	_da._ed.Diagonal.Color = _fge.NewCT_Color()
	_da._ed.Diagonal.Color.RgbAttr = c.AsRGBAString()
	_da._ed.Diagonal.StyleAttr = style
	if up {
		_da._ed.DiagonalUpAttr = _f.Bool(true)
	}
	if down {
		_da._ed.DiagonalDownAttr = _f.Bool(true)
	}
}

// SetStyleIndex directly sets a style index to the cell.  This should only be
// called with an index retrieved from CellStyle.Index()
func (_eec Cell) SetStyleIndex(idx uint32) { _eec._dced.SAttr = _f.Uint32(idx) }

// Comments is the container for comments for a single sheet.
type Comments struct {
	_faff *Workbook
	_dfef *_fge.Comments
}

// TopLeft is a no-op.
func (_dfa AbsoluteAnchor) TopLeft() CellMarker { return CellMarker{} }
func (_dfec PatternFill) ClearFgColor()         { _dfec._acgb.FgColor = nil }

// GetFormula returns the formula for a cell.
func (_bdgf Cell) GetFormula() string {
	if _bdgf._dced.F != nil {
		return _bdgf._dced.F.Content
	}
	return ""
}

// IsEmpty checks if the cell style contains nothing.
func (_bea CellStyle) IsEmpty() bool {
	return _bea._decg == nil || _bea._dece == nil || _bea._add == nil || _bea._add.Xf == nil
}

// X returns the inner wrapped XML type.
func (_debd Row) X() *_fge.CT_Row { return _debd._feg }

// Type returns the type of anchor
func (_agf AbsoluteAnchor) Type() AnchorType { return AnchorTypeAbsolute }

// NewStyleSheet constructs a new default stylesheet.
func NewStyleSheet(wb *Workbook) StyleSheet {
	_cebc := _fge.NewStyleSheet()
	_cebc.CellStyleXfs = _fge.NewCT_CellStyleXfs()
	_cebc.CellXfs = _fge.NewCT_CellXfs()
	_cebc.CellStyles = _fge.NewCT_CellStyles()
	_dfga := _fge.NewCT_CellStyle()
	_dfga.NameAttr = _f.String("\u004e\u006f\u0072\u006d\u0061\u006c")
	_dfga.XfIdAttr = 0
	_dfga.BuiltinIdAttr = _f.Uint32(0)
	_cebc.CellStyles.CellStyle = append(_cebc.CellStyles.CellStyle, _dfga)
	_cebc.CellStyles.CountAttr = _f.Uint32(uint32(len(_cebc.CellStyles.CellStyle)))
	_ddggb := _fge.NewCT_Xf()
	_ddggb.NumFmtIdAttr = _f.Uint32(0)
	_ddggb.FontIdAttr = _f.Uint32(0)
	_ddggb.FillIdAttr = _f.Uint32(0)
	_ddggb.BorderIdAttr = _f.Uint32(0)
	_cebc.CellStyleXfs.Xf = append(_cebc.CellStyleXfs.Xf, _ddggb)
	_cebc.CellStyleXfs.CountAttr = _f.Uint32(uint32(len(_cebc.CellStyleXfs.Xf)))
	_ggfe := NewFills()
	_cebc.Fills = _ggfe.X()
	_bgac := _ggfe.appendFill().SetPatternFill()
	_bgac.SetPattern(_fge.ST_PatternTypeNone)
	_bgac = _ggfe.appendFill().SetPatternFill()
	_bgac.SetPattern(_fge.ST_PatternTypeGray125)
	_cebc.Fonts = _fge.NewCT_Fonts()
	_cebc.Borders = _fge.NewCT_Borders()
	_ebgfg := StyleSheet{wb, _cebc}
	_ebgfg.appendBorder().InitializeDefaults()
	_ebgg := _ebgfg.appendFont()
	_ebgg.SetName("\u0043a\u006c\u0069\u0062\u0072\u0069")
	_ebgg.SetSize(11)
	_fbae := _fge.NewCT_Xf()
	*_fbae = *_ddggb
	_fbae.XfIdAttr = _f.Uint32(0)
	_cebc.CellXfs.Xf = append(_cebc.CellXfs.Xf, _fbae)
	_cebc.CellXfs.CountAttr = _f.Uint32(uint32(len(_cebc.CellXfs.Xf)))
	return _ebgfg
}

// SetRowOffset sets the row offset of the two cell anchor
func (_ebcc TwoCellAnchor) SetRowOffset(m _ae.Distance) {
	_gffc := m - _ebcc.TopLeft().RowOffset()
	_ebcc.TopLeft().SetRowOffset(m)
	_ebcc.BottomRight().SetRowOffset(_ebcc.BottomRight().RowOffset() + _gffc)
}

type PatternFill struct {
	_acgb *_fge.CT_PatternFill
	_gffe *_fge.CT_Fill
}

// X returns the inner wrapped XML type.
func (_gfaa Table) X() *_fge.Table { return _gfaa._ecgbf }

// SetStringByID sets the cell type to string, and the value a string in the
// shared strings table.
func (_bdg Cell) SetStringByID(id int) {
	_bdg._ef.ensureSharedStringsRelationships()
	_bdg.clearValue()
	_bdg._dced.V = _f.String(_fg.Itoa(id))
	_bdg._dced.TAttr = _fge.ST_CellTypeS
}

// X returns the inner wrapped XML type.
func (_gbaf Sheet) X() *_fge.Worksheet { return _gbaf._defb }
func (_ggabe *Sheet) removeColumnFromMergedCells(_eabd uint32) error {
	if _ggabe._defb.MergeCells == nil || _ggabe._defb.MergeCells.MergeCell == nil {
		return nil
	}
	_gedcd := []*_fge.CT_MergeCell{}
	for _, _dfbb := range _ggabe.MergedCells() {
		_debfd := _gbcd(_dfbb.Reference(), _eabd, true)
		if _debfd != "" {
			_dfbb.SetReference(_debfd)
			_gedcd = append(_gedcd, _dfbb.X())
		}
	}
	_ggabe._defb.MergeCells.MergeCell = _gedcd
	return nil
}

// SetNumberFormatStandard sets the format based off of the ECMA 376 standard formats.  These
// formats are standardized and don't need to be defined in the styles.
func (_fddg CellStyle) SetNumberFormatStandard(s StandardFormat) {
	_fddg._dece.NumFmtIdAttr = _f.Uint32(uint32(s))
	_fddg._dece.ApplyNumberFormatAttr = _f.Bool(true)
}

// PasswordHash returns the hash of the workbook password.
func (_aabe SheetProtection) PasswordHash() string {
	if _aabe._bbaf.PasswordAttr == nil {
		return ""
	}
	return *_aabe._bbaf.PasswordAttr
}

// GetFormattedValue returns the formatted cell value as it would appear in
// Excel. This involves determining the format string to apply, parsing it, and
// then formatting the value according to the format string.  This should only
// be used if you care about replicating what Excel would show, otherwise
// GetValueAsNumber()/GetValueAsTime
func (_cce Cell) GetFormattedValue() string {
	_bcc := _cce.getFormat()
	switch _cce._dced.TAttr {
	case _fge.ST_CellTypeB:
		_gdb, _ := _cce.GetValueAsBool()
		if _gdb {
			return "\u0054\u0052\u0055\u0045"
		}
		return "\u0046\u0041\u004cS\u0045"
	case _fge.ST_CellTypeN:
		_gaa, _ := _cce.GetValueAsNumber()
		return _fff.Number(_gaa, _bcc)
	case _fge.ST_CellTypeE:
		if _cce._dced.V != nil {
			return *_cce._dced.V
		}
		return ""
	case _fge.ST_CellTypeS, _fge.ST_CellTypeInlineStr:
		return _fff.String(_cce.GetString(), _bcc)
	case _fge.ST_CellTypeStr:
		_bcb := _cce.GetString()
		if _fff.IsNumber(_bcb) {
			_dea, _ := _fg.ParseFloat(_bcb, 64)
			return _fff.Number(_dea, _bcc)
		}
		return _fff.String(_bcb, _bcc)
	case _fge.ST_CellTypeUnset:
		fallthrough
	default:
		_aag, _ := _cce.GetRawValue()
		if len(_aag) == 0 {
			return ""
		}
		_fdb, _dac := _cce.GetValueAsNumber()
		if _dac == nil {
			return _fff.Number(_fdb, _bcc)
		}
		return _fff.String(_aag, _bcc)
	}
}

// StandardFormat is a standard ECMA 376 number format.
//
//go:generate stringer -type=StandardFormat
type StandardFormat uint32

// TopLeft returns the CellMaker for the top left corner of the anchor.
func (_deef TwoCellAnchor) TopLeft() CellMarker { return CellMarker{_deef._efed.From} }

// FormulaContext returns a formula evaluation context that can be used to
// evaluate formaulas.
func (_fcef *Sheet) FormulaContext() _bac.Context { return _bbfe(_fcef) }

// GetFormat returns a cell data format.
func (_dddc *evalContext) GetFormat(cellRef string) string {
	return _dddc._dgf.Cell(cellRef).getFormat()
}

// X returns the inner wrapped XML type.
func (_eaa Column) X() *_fge.CT_Col { return _eaa._bgba }

// WorkbookText is an array of extracted text items which has some methods for representing extracted text from a workbook.
type WorkbookText struct{ Sheets []*SheetText }

// SetHeight is a nop-op.
func (_eadb TwoCellAnchor) SetHeight(h _ae.Distance) {}

// GetFill gets a Fill from a cell style.
func (_age CellStyle) GetFill() *_fge.CT_Fill {
	if _eeddb := _age._dece.FillIdAttr; _eeddb != nil {
		_gad := _age._decg.StyleSheet.Fills().X().Fill
		if int(*_eeddb) < len(_gad) {
			return _gad[int(*_eeddb)]
		}
	}
	return nil
}

// SetHidden controls the visibility of a column.
func (_dfde Column) SetHidden(b bool) {
	if !b {
		_dfde._bgba.HiddenAttr = nil
	} else {
		_dfde._bgba.HiddenAttr = _f.Bool(true)
	}
}

// X returns the inner wrapped XML type.
func (_ggfd IconScale) X() *_fge.CT_IconSet { return _ggfd._gbffb }

// DVCompareType is a comparison type for a data validation rule. This restricts
// the input format of the cell.
type DVCompareType byte

// IsStructureLocked returns whether the workbook structure is locked.
func (_ceff WorkbookProtection) IsStructureLocked() bool {
	return _ceff._edcb.LockStructureAttr != nil && *_ceff._edcb.LockStructureAttr
}

// IconScale maps values to icons.
type IconScale struct{ _gbffb *_fge.CT_IconSet }
type Fills struct{ _dbgaf *_fge.CT_Fills }

// X returns the inner wrapped XML type.
func (_fdgee SharedStrings) X() *_fge.Sst { return _fdgee._ebge }

// Name returns the sheet name
func (_gdgd Sheet) Name() string { return _gdgd._bgfdd.NameAttr }

var _fbad *_df.Regexp = _df.MustCompile("\u005e(\u005ba\u002d\u007a\u005d\u002b\u0029(\u005b\u0030-\u0039\u005d\u002b\u0029\u0024")

// AddDataValidation adds a data validation rule to a sheet.
func (_dee *Sheet) AddDataValidation() DataValidation {
	if _dee._defb.DataValidations == nil {
		_dee._defb.DataValidations = _fge.NewCT_DataValidations()
	}
	_fdfd := _fge.NewCT_DataValidation()
	_fdfd.ShowErrorMessageAttr = _f.Bool(true)
	_dee._defb.DataValidations.DataValidation = append(_dee._defb.DataValidations.DataValidation, _fdfd)
	_dee._defb.DataValidations.CountAttr = _f.Uint32(uint32(len(_dee._defb.DataValidations.DataValidation)))
	return DataValidation{_fdfd}
}

// RemoveCalcChain removes the cached caculation chain. This is sometimes needed
// as we don't update it when rows are added/removed.
func (_fcgc *Workbook) RemoveCalcChain() {
	var _fefdb string
	for _, _cafg := range _fcgc._cbag.Relationships() {
		if _cafg.Type() == "ht\u0074\u0070\u003a\u002f\u002f\u0073\u0063he\u006d\u0061\u0073\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006da\u0074\u0073\u002e\u006f\u0072\u0067\u002f\u006f\u0066\u0066\u0069\u0063\u0065\u0044\u006f\u0063\u0075\u006d\u0065\u006et\u002f\u0032\u0030\u0030\u0036\u002fr\u0065\u006c\u0061\u0074\u0069\u006f\u006e\u0073\u0068i\u0070s\u002f\u0063\u0061\u006c\u0063\u0043\u0068\u0061\u0069\u006e" {
			_fefdb = "\u0078\u006c\u002f" + _cafg.Target()
			_fcgc._cbag.Remove(_cafg)
			break
		}
	}
	if _fefdb == "" {
		return
	}
	_fcgc.ContentTypes.RemoveOverride(_fefdb)
	for _ggafd, _abfg := range _fcgc.ExtraFiles {
		if _abfg.ZipPath == _fefdb {
			_fcgc.ExtraFiles[_ggafd] = _fcgc.ExtraFiles[len(_fcgc.ExtraFiles)-1]
			_fcgc.ExtraFiles = _fcgc.ExtraFiles[:len(_fcgc.ExtraFiles)-1]
			return
		}
	}
}

// SetHeightCells is a no-op.
func (_dgg AbsoluteAnchor) SetHeightCells(int32) {}

// SetUnderline controls if the run is underlined.
func (_gaeea RichTextRun) SetUnderline(u _fge.ST_UnderlineValues) {
	_gaeea.ensureRpr()
	for _, _fdef := range _gaeea._gbe.RPr.RPrEltChoice {
		if _fdef.U != nil {
			_fdef.U.ValAttr = u
			return
		}
	}
	_gaeea._gbe.RPr.RPrEltChoice = append(_gaeea._gbe.RPr.RPrEltChoice, &_fge.CT_RPrEltChoice{U: &_fge.CT_UnderlineProperty{ValAttr: u}})
}

// DataValidationList is just a view on a DataValidation configured as a list.
// It presents a drop-down combo box for spreadsheet users to select values. The
// contents of the dropdown can either pull from a rang eof cells (SetRange) or
// specified directly (SetValues).
type DataValidationList struct{ _cddg *_fge.CT_DataValidation }

// Validate validates the sheet, returning an error if it is found to be invalid.
func (_cede Sheet) Validate() error {
	_gedg := []func() error{_cede.validateRowCellNumbers, _cede.validateMergedCells, _cede.validateSheetNames}
	for _, _ebee := range _gedg {
		if _aefe := _ebee(); _aefe != nil {
			return _aefe
		}
	}
	if _dggc := _cede._defb.Validate(); _dggc != nil {
		return _dggc
	}
	return _cede._defb.Validate()
}
func (_aeggc StyleSheet) appendFont() Font {
	_bdab := _fge.NewCT_Font()
	_aeggc._ccde.Fonts.Font = append(_aeggc._ccde.Fonts.Font, _bdab)
	_aeggc._ccde.Fonts.CountAttr = _f.Uint32(uint32(len(_aeggc._ccde.Fonts.Font)))
	return Font{_bdab, _aeggc._ccde}
}

// RemoveColumn removes column from the sheet and moves all columns to the right of the removed column one step left.
func (_ffad *Sheet) RemoveColumn(column string) error {
	_dbfga, _edbb := _ffad.getAllCellsInFormulaArraysForColumn()
	if _edbb != nil {
		return _edbb
	}
	_eeba := _gb.ColumnToIndex(column)
	for _, _caeg := range _ffad.Rows() {
		_fbcdf := _c.Sprintf("\u0025\u0073\u0025\u0064", column, *_caeg.X().RAttr)
		if _, _cade := _dbfga[_fbcdf]; _cade {
			return nil
		}
	}
	for _, _cedd := range _ffad.Rows() {
		_cgcf := _cedd._feg.C
		for _adgeb, _gfbeb := range _cgcf {
			_bfag, _cgedg := _gb.ParseCellReference(*_gfbeb.RAttr)
			if _cgedg != nil {
				return _cgedg
			}
			if _bfag.ColumnIdx == _eeba {
				_cedd._feg.C = append(_cgcf[:_adgeb], _ffad.slideCellsLeft(_cgcf[_adgeb+1:])...)
				break
			} else if _bfag.ColumnIdx > _eeba {
				_cedd._feg.C = append(_cgcf[:_adgeb], _ffad.slideCellsLeft(_cgcf[_adgeb:])...)
				break
			}
		}
	}
	_edbb = _ffad.updateAfterRemove(_eeba, _be.UpdateActionRemoveColumn)
	if _edbb != nil {
		return _edbb
	}
	_edbb = _ffad.removeColumnFromNamedRanges(_eeba)
	if _edbb != nil {
		return _edbb
	}
	_edbb = _ffad.removeColumnFromMergedCells(_eeba)
	if _edbb != nil {
		return _edbb
	}
	for _, _gbba := range _ffad._fgca.Sheets() {
		_gbba.RecalculateFormulas()
	}
	return nil
}

// AddImage adds an image to the workbook package, returning a reference that
// can be used to add the image to a drawing.
func (_fgadc *Workbook) AddImage(i _fa.Image) (_fa.ImageRef, error) {
	_deadf := _fa.MakeImageRef(i, &_fgadc.DocBase, _fgadc._cbag)
	if i.Data == nil && i.Path == "" {
		return _deadf, _fb.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _deadf, _fb.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _deadf, _fb.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	if i.Path != "" {
		_eaea := _ce.Add(i.Path)
		if _eaea != nil {
			return _deadf, _eaea
		}
	}
	_fgadc.Images = append(_fgadc.Images, _deadf)
	return _deadf, nil
}

// Reference returns the cell reference (e.g. "A4"). This is not required,
// however both unioffice and Excel will always set it.
func (_dfe Cell) Reference() string {
	if _dfe._dced.RAttr != nil {
		return *_dfe._dced.RAttr
	}
	return ""
}
func (_ged Font) SetSize(size float64) {
	_bffa := false
	for _fffd, _bgaf := range _ged._caed.FontChoice {
		if _bgaf.Sz != nil {
			_ged._caed.FontChoice[_fffd].Sz = &_fge.CT_FontSize{ValAttr: size}
			_bffa = true
		}
	}
	if !_bffa {
		_ged._caed.FontChoice = append(_ged._caed.FontChoice, &_fge.CT_FontChoice{Sz: &_fge.CT_FontSize{ValAttr: size}})
	}
}

// SetString sets the cell type to string, and the value to the given string,
// returning an ID from the shared strings table. To reuse a string, call
// SetStringByID with the ID returned.
func (_dd Cell) SetString(s string) int {
	_dd._ef.ensureSharedStringsRelationships()
	_dd.clearValue()
	_dab := _dd._ef.SharedStrings.AddString(s)
	_dd._dced.V = _f.String(_fg.Itoa(_dab))
	_dd._dced.TAttr = _fge.ST_CellTypeS
	return _dab
}

// Epoch returns the point at which the dates/times in the workbook are relative to.
func (_afcc *Workbook) Epoch() _gd.Time {
	if _afcc.Uses1904Dates() {
		_gd.Date(1904, 1, 1, 0, 0, 0, 0, _gd.UTC)
	}
	return _gd.Date(1899, 12, 30, 0, 0, 0, 0, _gd.UTC)
}

// SetOperator sets the operator for the rule.
func (_fgac ConditionalFormattingRule) SetOperator(t _fge.ST_ConditionalFormattingOperator) {
	_fgac._gcgc.OperatorAttr = t
}

// SetFgColor sets the *fill* foreground color.  As an example, the solid pattern foreground color becomes the
// background color of the cell when applied.
func (_bbab PatternFill) SetFgColor(c _cea.Color) {
	_bbab._acgb.FgColor = _fge.NewCT_Color()
	_bbab._acgb.FgColor.RgbAttr = c.AsRGBAString()
}

// Type returns the type of anchor
func (_eecba TwoCellAnchor) Type() AnchorType { return AnchorTypeTwoCell }

// SetFont sets the font name for a rich text run.
func (_bfaa RichTextRun) SetFont(s string) {
	_bfaa.ensureRpr()
	for _, _dbb := range _bfaa._gbe.RPr.RPrEltChoice {
		if _dbb.RFont != nil {
			_dbb.RFont.ValAttr = s
			return
		}
	}
	_bfaa._gbe.RPr.RPrEltChoice = append(_bfaa._gbe.RPr.RPrEltChoice, &_fge.CT_RPrEltChoice{RFont: &_fge.CT_FontName{ValAttr: s}})
}

// X returns the inner wrapped XML type.
func (_fcgd DataValidation) X() *_fge.CT_DataValidation { return _fcgd._ebga }

// Comments returns the list of comments for this sheet
func (_bacf Comments) Comments() []Comment {
	_aca := []Comment{}
	for _, _eeda := range _bacf._dfef.CommentList.Comment {
		_aca = append(_aca, Comment{_bacf._faff, _eeda, _bacf._dfef})
	}
	return _aca
}

// CellReference returns the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_fbfg Comment) CellReference() string { return _fbfg._gade.RefAttr }

// MakeComments constructs a new Comments wrapper.
func MakeComments(w *Workbook, x *_fge.Comments) Comments { return Comments{w, x} }

// SetAutoFilter creates autofilters on the sheet. These are the automatic
// filters that are common for a header row.  The RangeRef should be of the form
// "A1:C5" and cover the entire range of cells to be filtered, not just the
// header. SetAutoFilter replaces any existing auto filter on the sheet.
func (_dgee *Sheet) SetAutoFilter(rangeRef string) {
	rangeRef = _d.Replace(rangeRef, "\u0024", "", -1)
	_dgee._defb.AutoFilter = _fge.NewCT_AutoFilter()
	_dgee._defb.AutoFilter.RefAttr = _f.String(rangeRef)
	_gedc := "\u0027" + _dgee.Name() + "\u0027\u0021"
	var _gaeeg DefinedName
	for _, _dbec := range _dgee._fgca.DefinedNames() {
		if _dbec.Name() == _ecff {
			if _d.HasPrefix(_dbec.Content(), _gedc) {
				_gaeeg = _dbec
				_gaeeg.SetContent(_dgee.RangeReference(rangeRef))
				break
			}
		}
	}
	if _gaeeg.X() == nil {
		_gaeeg = _dgee._fgca.AddDefinedName(_ecff, _dgee.RangeReference(rangeRef))
	}
	for _dgd, _aab := range _dgee._fgca._egabd {
		if _aab == _dgee._defb {
			_gaeeg.SetLocalSheetID(uint32(_dgd))
		}
	}
}

// SetText sets the text to be displayed.
func (_fbga RichTextRun) SetText(s string) { _fbga._gbe.T = s }
func _dffg(_fde string) bool {
	_fde = _d.Replace(_fde, "\u0024", "", -1)
	if _adcc := _fbad.FindStringSubmatch(_d.ToLower(_fde)); len(_adcc) > 2 {
		_gfec := _adcc[1]
		_babg, _fce := _fg.Atoi(_adcc[2])
		if _fce != nil {
			return false
		}
		return _babg <= 1048576 && _gfec <= "\u007a\u007a"
	}
	return false
}

const (
	DVCompareTypeWholeNumber = DVCompareType(_fge.ST_DataValidationTypeWhole)
	DVCompareTypeDecimal     = DVCompareType(_fge.ST_DataValidationTypeDecimal)
	DVCompareTypeDate        = DVCompareType(_fge.ST_DataValidationTypeDate)
	DVCompareTypeTime        = DVCompareType(_fge.ST_DataValidationTypeTime)
	DVompareTypeTextLength   = DVCompareType(_fge.ST_DataValidationTypeTextLength)
)

// SetHeightCells sets the height the anchored object by moving the bottom.  It
// is not compatible with SetHeight.
func (_aecae TwoCellAnchor) SetHeightCells(h int32) {
	_aecae.SetHeight(0)
	_gdcc := _aecae.TopLeft()
	_dcee := _aecae.BottomRight()
	_dcee.SetRow(_gdcc.Row() + h)
}

// ValidateWithPath validates the sheet passing path informaton for a better
// error message
func (_ece Sheet) ValidateWithPath(path string) error  { return _ece._defb.ValidateWithPath(path) }
func (_gfff DataValidationCompare) SetValue2(v string) { _gfff._ccb.Formula2 = &v }

// AddConditionalFormatting adds conditional formatting to the sheet.
func (_egf *Sheet) AddConditionalFormatting(cellRanges []string) ConditionalFormatting {
	_gfgg := _fge.NewCT_ConditionalFormatting()
	_egf._defb.ConditionalFormatting = append(_egf._defb.ConditionalFormatting, _gfgg)
	_dfbgg := make(_fge.ST_Sqref, 0, 0)
	_gfgg.SqrefAttr = &_dfbgg
	for _, _ccdfd := range cellRanges {
		*_gfgg.SqrefAttr = append(*_gfgg.SqrefAttr, _ccdfd)
	}
	return ConditionalFormatting{_gfgg}
}

// AbsoluteAnchor has a fixed top-left corner in distance units as well as a
// fixed height/width.
type AbsoluteAnchor struct{ _fcc *_fgf.CT_AbsoluteAnchor }

// Name returns the name of the table
func (_dcdd Table) Name() string {
	if _dcdd._ecgbf.NameAttr != nil {
		return *_dcdd._ecgbf.NameAttr
	}
	return ""
}

// Open opens and reads a workbook from a file (.xlsx).
func Open(filename string) (*Workbook, error) {
	_efef, _gdcg := _abd.Open(filename)
	if _gdcg != nil {
		return nil, _c.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _gdcg)
	}
	defer _efef.Close()
	_bdeg, _gdcg := _abd.Stat(filename)
	if _gdcg != nil {
		return nil, _c.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _gdcg)
	}
	_bbcd, _gdcg := Read(_efef, _bdeg.Size())
	if _gdcg != nil {
		return nil, _gdcg
	}
	_beae, _ := _g.Abs(_g.Dir(filename))
	_bbcd._deff = _g.Join(_beae, filename)
	return _bbcd, nil
}

// HasFormula returns true if the cell has an asoociated formula.
func (_aed Cell) HasFormula() bool { return _aed._dced.F != nil }
func (_gegce *Workbook) ensureSharedStringsRelationships() {
	_fcdg := false
	for _, _cfba := range _gegce.ContentTypes.X().TypesChoice {
		if _cfba.Override != nil && _cfba.Override.ContentTypeAttr == _f.SharedStringsContentType {
			_fcdg = true
			break
		}
	}
	if !_fcdg {
		_gegce.ContentTypes.AddOverride(_ebdc, _f.SharedStringsContentType)
	}
	_dbffd := false
	for _, _cbce := range _gegce._cbag.Relationships() {
		if _cbce.X().TargetAttr == _gggb {
			_dbffd = true
			break
		}
	}
	if !_dbffd {
		_gegce._cbag.AddRelationship(_gggb, _f.SharedStringsType)
	}
}

// DefinedName is a named range, formula, etc.
type DefinedName struct{ _cgaa *_fge.CT_DefinedName }

const (
	DVOpGreater = _fge.ST_DataValidationOperatorGreaterThanOrEqual
)

func _def() *_fgf.CT_TwoCellAnchor {
	_bfcb := _fgf.NewCT_TwoCellAnchor()
	_bfcb.EditAsAttr = _fgf.ST_EditAsOneCell
	_bfcb.From.Col = 5
	_bfcb.From.Row = 0
	_bfcb.From.ColOff.ST_CoordinateUnqualified = _f.Int64(0)
	_bfcb.From.RowOff.ST_CoordinateUnqualified = _f.Int64(0)
	_bfcb.To.Col = 10
	_bfcb.To.Row = 20
	_bfcb.To.ColOff.ST_CoordinateUnqualified = _f.Int64(0)
	_bfcb.To.RowOff.ST_CoordinateUnqualified = _f.Int64(0)
	return _bfcb
}

// RemoveDefinedName removes an existing defined name.
func (_fgdd *Workbook) RemoveDefinedName(dn DefinedName) error {
	if dn.X() == nil {
		return _fb.New("\u0061\u0074\u0074\u0065\u006d\u0070t\u0020\u0074\u006f\u0020\u0072\u0065\u006d\u006f\u0076\u0065\u0020\u006e\u0069l\u0020\u0044\u0065\u0066\u0069\u006e\u0065d\u004e\u0061\u006d\u0065")
	}
	for _ddcc, _gcaf := range _fgdd._fefd.DefinedNames.DefinedName {
		if _gcaf == dn.X() {
			copy(_fgdd._fefd.DefinedNames.DefinedName[_ddcc:], _fgdd._fefd.DefinedNames.DefinedName[_ddcc+1:])
			_fgdd._fefd.DefinedNames.DefinedName[len(_fgdd._fefd.DefinedNames.DefinedName)-1] = nil
			_fgdd._fefd.DefinedNames.DefinedName = _fgdd._fefd.DefinedNames.DefinedName[:len(_fgdd._fefd.DefinedNames.DefinedName)-1]
			return nil
		}
	}
	return _fb.New("\u0064\u0065\u0066\u0069ne\u0064\u0020\u006e\u0061\u006d\u0065\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075n\u0064")
}

// GetDrawing return the worksheet drawing and its relationships if exists.
func (_bdged *Sheet) GetDrawing() (*_fgf.WsDr, _fa.Relationships) {
	if _fcba := _bdged._defb.Drawing; _fcba != nil {
		_fcfg := 0
		for _, _dgb := range _bdged._fgca._egabd {
			if _eadg := _dgb.Drawing; _eadg != nil {
				if _dgb == _bdged._defb {
					return _bdged._fgca._beed[_fcfg], _bdged._fgca._gfgab[_fcfg]
				}
				_fcfg++
			}
		}
	}
	return nil, _fa.Relationships{}
}

// Text returns text from the workbook as one string separated with line breaks.
func (_fcce *WorkbookText) Text() string {
	_gdfa := _fc.NewBuffer([]byte{})
	for _, _bgg := range _fcce.Sheets {
		_gdfa.WriteString(_bgg.Text())
	}
	return _gdfa.String()
}

// PasswordHash returns the password hash for a workbook using the modified
// spreadsheetML password hash that is compatible with Excel.
func PasswordHash(s string) string {
	_ebcb := uint16(0)
	if len(s) > 0 {
		for _egd := len(s) - 1; _egd >= 0; _egd-- {
			_edg := s[_egd]
			_ebcb = ((_ebcb >> 14) & 0x01) | ((_ebcb << 1) & 0x7fff)
			_ebcb ^= uint16(_edg)
		}
		_ebcb = ((_ebcb >> 14) & 0x01) | ((_ebcb << 1) & 0x7fff)
		_ebcb ^= uint16(len(s))
		_ebcb ^= (0x8000 | ('N' << 8) | 'K')
	}
	return _c.Sprintf("\u0025\u0030\u0034\u0058", uint64(_ebcb))
}
func NewPatternFill(fills *_fge.CT_Fills) PatternFill {
	_fdde := _fge.NewCT_Fill()
	_fdde.FillChoice = _fge.NewCT_FillChoice()
	_fdde.FillChoice.PatternFill = _fge.NewCT_PatternFill()
	return PatternFill{_fdde.FillChoice.PatternFill, _fdde}
}

// ConditionalFormatting controls the formatting styles and rules for a range of
// cells with the same conditional formatting.
type ConditionalFormatting struct {
	_addb *_fge.CT_ConditionalFormatting
}

var (
	_dade = [...]uint8{0, 21, 46, 61, 76, 91}
	_adef = [...]uint8{0, 21, 37, 53, 69, 85, 103, 119, 135, 151, 167, 185, 201, 217, 239}
	_cbgd = [...]uint8{0, 16, 32, 48, 64}
	_dcdg = [...]uint8{0, 16, 32, 48, 64, 80}
)

// X returns the inner wrapped XML type.
func (_gfa MergedCell) X() *_fge.CT_MergeCell { return _gfa._dbac }
func CreateDefaultNumberFormat(id StandardFormat) NumberFormat {
	_gdcb := NumberFormat{_gage: _fge.NewCT_NumFmt()}
	_gdcb._gage.NumFmtIdAttr = uint32(id)
	_gdcb._gage.FormatCodeAttr = "\u0047e\u006e\u0065\u0072\u0061\u006c"
	switch id {
	case StandardFormat0:
		_gdcb._gage.FormatCodeAttr = "\u0047e\u006e\u0065\u0072\u0061\u006c"
	case StandardFormat1:
		_gdcb._gage.FormatCodeAttr = "\u0030"
	case StandardFormat2:
		_gdcb._gage.FormatCodeAttr = "\u0030\u002e\u0030\u0030"
	case StandardFormat3:
		_gdcb._gage.FormatCodeAttr = "\u0023\u002c\u0023#\u0030"
	case StandardFormat4:
		_gdcb._gage.FormatCodeAttr = "\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030"
	case StandardFormat9:
		_gdcb._gage.FormatCodeAttr = "\u0030\u0025"
	case StandardFormat10:
		_gdcb._gage.FormatCodeAttr = "\u0030\u002e\u00300\u0025"
	case StandardFormat11:
		_gdcb._gage.FormatCodeAttr = "\u0030\u002e\u0030\u0030\u0045\u002b\u0030\u0030"
	case StandardFormat12:
		_gdcb._gage.FormatCodeAttr = "\u0023\u0020\u003f/\u003f"
	case StandardFormat13:
		_gdcb._gage.FormatCodeAttr = "\u0023 \u003f\u003f\u002f\u003f\u003f"
	case StandardFormat14:
		_gdcb._gage.FormatCodeAttr = "\u006d\u002f\u0064\u002f\u0079\u0079"
	case StandardFormat15:
		_gdcb._gage.FormatCodeAttr = "\u0064\u002d\u006d\u006d\u006d\u002d\u0079\u0079"
	case StandardFormat16:
		_gdcb._gage.FormatCodeAttr = "\u0064\u002d\u006dm\u006d"
	case StandardFormat17:
		_gdcb._gage.FormatCodeAttr = "\u006d\u006d\u006d\u002d\u0079\u0079"
	case StandardFormat18:
		_gdcb._gage.FormatCodeAttr = "\u0068\u003a\u006d\u006d\u0020\u0041\u004d\u002f\u0050\u004d"
	case StandardFormat19:
		_gdcb._gage.FormatCodeAttr = "\u0068\u003a\u006d\u006d\u003a\u0073\u0073\u0020\u0041\u004d\u002f\u0050\u004d"
	case StandardFormat20:
		_gdcb._gage.FormatCodeAttr = "\u0068\u003a\u006d\u006d"
	case StandardFormat21:
		_gdcb._gage.FormatCodeAttr = "\u0068:\u006d\u006d\u003a\u0073\u0073"
	case StandardFormat22:
		_gdcb._gage.FormatCodeAttr = "m\u002f\u0064\u002f\u0079\u0079\u0020\u0068\u003a\u006d\u006d"
	case StandardFormat37:
		_gdcb._gage.FormatCodeAttr = "\u0023\u002c\u0023\u0023\u0030\u0020\u003b\u0028\u0023,\u0023\u0023\u0030\u0029"
	case StandardFormat38:
		_gdcb._gage.FormatCodeAttr = "\u0023\u002c\u0023\u00230 \u003b\u005b\u0052\u0065\u0064\u005d\u0028\u0023\u002c\u0023\u0023\u0030\u0029"
	case StandardFormat39:
		_gdcb._gage.FormatCodeAttr = "\u0023\u002c\u0023\u00230.\u0030\u0030\u003b\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029"
	case StandardFormat40:
		_gdcb._gage.FormatCodeAttr = "\u0023,\u0023\u0023\u0030\u002e\u0030\u0030\u003b\u005b\u0052\u0065\u0064]\u0028\u0023\u002c\u0023\u0023\u0030\u002e\u0030\u0030\u0029"
	case StandardFormat45:
		_gdcb._gage.FormatCodeAttr = "\u006d\u006d\u003as\u0073"
	case StandardFormat46:
		_gdcb._gage.FormatCodeAttr = "\u005bh\u005d\u003a\u006d\u006d\u003a\u0073s"
	case StandardFormat47:
		_gdcb._gage.FormatCodeAttr = "\u006dm\u003a\u0073\u0073\u002e\u0030"
	case StandardFormat48:
		_gdcb._gage.FormatCodeAttr = "\u0023\u0023\u0030\u002e\u0030\u0045\u002b\u0030"
	case StandardFormat49:
		_gdcb._gage.FormatCodeAttr = "\u0040"
	}
	return _gdcb
}
func (_ga Border) SetRight(style _fge.ST_BorderStyle, c _cea.Color) {
	if _ga._ed.Right == nil {
		_ga._ed.Right = _fge.NewCT_BorderPr()
	}
	_ga._ed.Right.Color = _fge.NewCT_Color()
	_ga._ed.Right.Color.RgbAttr = c.AsRGBAString()
	_ga._ed.Right.StyleAttr = style
}

// Row will return a row with a given row number, creating a new row if
// necessary.
func (_ceb *Sheet) Row(rowNum uint32) Row {
	for _, _egb := range _ceb._defb.SheetData.Row {
		if _egb.RAttr != nil && *_egb.RAttr == rowNum {
			return Row{_ceb._fgca, _ceb, _egb}
		}
	}
	return _ceb.AddNumberedRow(rowNum)
}
func (_cffdg *Sheet) updateAfterRemove(_aedd uint32, _afdc _be.UpdateAction) error {
	_adeg := _cffdg.Name()
	_bead := &_be.UpdateQuery{UpdateType: _afdc, ColumnIdx: _aedd, SheetToUpdate: _adeg}
	for _, _egadf := range _cffdg._fgca.Sheets() {
		_bead.UpdateCurrentSheet = _adeg == _egadf.Name()
		for _, _bbff := range _egadf.Rows() {
			for _, _cebb := range _bbff.Cells() {
				if _cebb.X().F != nil {
					_bffe := _cebb.X().F.Content
					_acdg := _bac.ParseString(_bffe)
					if _acdg == nil {
						_cebb.SetError("\u0023\u0052\u0045F\u0021")
					} else {
						_bcbaf := _acdg.Update(_bead)
						_cebb.X().F.Content = _c.Sprintf("\u003d\u0025\u0073", _bcbaf.String())
					}
				}
			}
		}
	}
	return nil
}

type ConditionalFormattingRule struct{ _gcgc *_fge.CT_CfRule }

// Validate attempts to validate the structure of a workbook.
func (_eabdf *Workbook) Validate() error {
	if _eabdf == nil || _eabdf._fefd == nil {
		return _fb.New("\u0077o\u0072\u006bb\u006f\u006f\u006b\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065")
	}
	_caef := uint32(0)
	for _, _fca := range _eabdf._fefd.Sheets.Sheet {
		if _fca.SheetIdAttr > _caef {
			_caef = _fca.SheetIdAttr
		}
	}
	if _caef != uint32(len(_eabdf._egabd)) {
		return _c.Errorf("\u0066\u006f\u0075\u006e\u0064\u0020%\u0064\u0020\u0077\u006f\u0072\u006b\u0073\u0068\u0065\u0065\u0074\u0020\u0064\u0065\u0073\u0063\u0072\u0069\u0070\u0074i\u006f\u006e\u0073\u0020\u0061\u006e\u0064\u0020\u0025\u0064\u0020\u0077\u006f\u0072k\u0073h\u0065\u0065\u0074\u0073", _caef, len(_eabdf._egabd))
	}
	_cceb := map[string]struct{}{}
	for _baeec, _ggceg := range _eabdf._fefd.Sheets.Sheet {
		_dagef := Sheet{_eabdf, _ggceg, _eabdf._egabd[_baeec]}
		if _, _dgdc := _cceb[_dagef.Name()]; _dgdc {
			return _c.Errorf("\u0077\u006f\u0072k\u0062\u006f\u006f\u006b\u002f\u0053\u0068\u0065\u0065\u0074\u005b\u0025\u0064\u005d\u0020\u0068\u0061\u0073\u0020\u0064\u0075\u0070\u006c\u0069\u0063\u0061\u0074\u0065\u0020n\u0061\u006d\u0065\u0020\u0027\u0025\u0073\u0027", _baeec, _dagef.Name())
		}
		_cceb[_dagef.Name()] = struct{}{}
		if _abb := _dagef.ValidateWithPath(_c.Sprintf("\u0077o\u0072k\u0062\u006f\u006f\u006b\u002fS\u0068\u0065e\u0074\u005b\u0025\u0064\u005d", _baeec)); _abb != nil {
			return _abb
		}
		if _gfacf := _dagef.Validate(); _gfacf != nil {
			return _gfacf
		}
	}
	return nil
}

// AddRun adds a new run of text to the cell.
func (_cfcd RichText) AddRun() RichTextRun {
	_deag := _fge.NewCT_RElt()
	_cfcd._faae.R = append(_cfcd._faae.R, _deag)
	return RichTextRun{_deag}
}

// AddMergedCells merges cells within a sheet.
func (_afb *Sheet) AddMergedCells(fromRef, toRef string) MergedCell {
	if _afb._defb.MergeCells == nil {
		_afb._defb.MergeCells = _fge.NewCT_MergeCells()
	}
	_fbeb := _fge.NewCT_MergeCell()
	_fbeb.RefAttr = _c.Sprintf("\u0025\u0073\u003a%\u0073", fromRef, toRef)
	_afb._defb.MergeCells.MergeCell = append(_afb._defb.MergeCells.MergeCell, _fbeb)
	_afb._defb.MergeCells.CountAttr = _f.Uint32(uint32(len(_afb._defb.MergeCells.MergeCell)))
	return MergedCell{_afb._fgca, _afb, _fbeb}
}

// Column returns or creates a column that with a given index (1-N).  Columns
// can span multiple column indices, this method will return the column that
// applies to a column index if it exists or create a new column that only
// applies to the index passed in otherwise.
func (_decb *Sheet) Column(idx uint32) Column {
	for _, _edga := range _decb._defb.Cols {
		for _, _fgbf := range _edga.Col {
			if idx >= _fgbf.MinAttr && idx <= _fgbf.MaxAttr {
				return Column{_fgbf}
			}
		}
	}
	var _bffg *_fge.CT_Cols
	if len(_decb._defb.Cols) == 0 {
		_bffg = _fge.NewCT_Cols()
		_decb._defb.Cols = append(_decb._defb.Cols, _bffg)
	} else {
		_bffg = _decb._defb.Cols[0]
	}
	_ccf := _fge.NewCT_Col()
	_ccf.MinAttr = idx
	_ccf.MaxAttr = idx
	_bffg.Col = append(_bffg.Col, _ccf)
	return Column{_ccf}
}

// AddDifferentialStyle adds a new empty differential cell style to the stylesheet.
func (_bbgb StyleSheet) AddDifferentialStyle() DifferentialStyle {
	if _bbgb._ccde.Dxfs == nil {
		_bbgb._ccde.Dxfs = _fge.NewCT_Dxfs()
	}
	_bcgb := _fge.NewCT_Dxf()
	_bbgb._ccde.Dxfs.Dxf = append(_bbgb._ccde.Dxfs.Dxf, _bcgb)
	_bbgb._ccde.Dxfs.CountAttr = _f.Uint32(uint32(len(_bbgb._ccde.Dxfs.Dxf)))
	return DifferentialStyle{_bcgb, _bbgb._eafa, _bbgb._ccde.Dxfs}
}
func (_fddgb *Workbook) onNewRelationship(_ddde *_dg.DecodeMap, _ebdb, _caebb string, _aaea []*_ag.File, _eefc *_ge.Relationship, _dcaf _dg.Target) error {
	_dcdf := _f.DocTypeSpreadsheet
	switch _caebb {
	case _f.OfficeDocumentType:
		_fddgb._fefd = _fge.NewWorkbook()
		_ddde.AddTarget(_ebdb, _fddgb._fefd, _caebb, 0)
		_fddgb._cbag = _fa.NewRelationships()
		_ddde.AddTarget(_dg.RelationsPathFor(_ebdb), _fddgb._cbag.X(), _caebb, 0)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, 0)
	case _f.CorePropertiesType:
		_ddde.AddTarget(_ebdb, _fddgb.CoreProperties.X(), _caebb, 0)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, 0)
	case _f.CustomPropertiesType:
		_ddde.AddTarget(_ebdb, _fddgb.CustomProperties.X(), _caebb, 0)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, 0)
	case _f.ExtendedPropertiesType:
		_ddde.AddTarget(_ebdb, _fddgb.AppProperties.X(), _caebb, 0)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, 0)
	case _f.WorksheetType:
		_bccb := _fge.NewWorksheet()
		_ecgc, _daed := _db.StringToNumbers(_ebdb)
		if !_daed {
			_ecgc = len(_fddgb._egabd)
		}
		_ddde.AddTarget(_ebdb, _bccb, _caebb, uint32(_ecgc))
		_fgge := _fa.NewRelationships()
		_ddde.AddTarget(_dg.RelationsPathFor(_ebdb), _fgge.X(), _caebb, 0)
		_fddgb._bbea = append(_fddgb._bbea, _fgge)
		_fddgb._aacf = append(_fddgb._aacf, nil)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, _ecgc)
		if _fddgb._fefd.Sheets != nil {
			if len(_fddgb._egabd) < 1 {
				_fddgb._egabd = make([]*_fge.Worksheet, len(_fddgb._fefd.Sheets.Sheet))
			}
			for _bgfbd, _ccfg := range _fddgb._fefd.Sheets.Sheet {
				if _ccfg.IdAttr == _eefc.IdAttr {
					_fddgb._egabd[_bgfbd] = _bccb
				}
			}
		} else {
			_fddgb._egabd = append(_fddgb._egabd, _bccb)
		}
	case _f.StylesType:
		_fddgb.StyleSheet = NewStyleSheet(_fddgb)
		_ddde.AddTarget(_ebdb, _fddgb.StyleSheet.X(), _caebb, 0)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, 0)
	case _f.ThemeType:
		_gebgd := _cg.NewTheme()
		_fddgb._edgb = append(_fddgb._edgb, _gebgd)
		_ddde.AddTarget(_ebdb, _gebgd, _caebb, 0)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, len(_fddgb._edgb))
	case _f.SharedStringsType:
		_fddgb.SharedStrings = NewSharedStrings()
		_ddde.AddTarget(_ebdb, _fddgb.SharedStrings.X(), _caebb, 0)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, 0)
	case _f.ThumbnailType:
		for _aded, _bgaa := range _aaea {
			if _bgaa == nil {
				continue
			}
			if _bgaa.Name == _ebdb {
				_agbf, _bacag := _bgaa.Open()
				if _bacag != nil {
					return _c.Errorf("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073", _bacag)
				}
				_fddgb.Thumbnail, _, _bacag = _b.Decode(_agbf)
				_agbf.Close()
				if _bacag != nil {
					return _c.Errorf("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073", _bacag)
				}
				_aaea[_aded] = nil
			}
		}
	case _f.ImageType:
		for _ecaf, _dfag := range _fddgb._caafe {
			_fcca := _ff.Clean(_ebdb)
			if _fcca == _ecaf {
				_eefc.TargetAttr = _dfag
				return nil
			}
		}
		_cggb := _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, len(_fddgb.Images)+1)
		for _cbdg, _deeag := range _aaea {
			if _deeag == nil {
				continue
			}
			if _deeag.Name == _ff.Clean(_ebdb) {
				_fcfd, _gcecf := _dg.ExtractToDiskTmp(_deeag, _fddgb.TmpPath)
				if _gcecf != nil {
					return _gcecf
				}
				_cgac, _gcecf := _fa.ImageFromStorage(_fcfd)
				if _gcecf != nil {
					return _gcecf
				}
				_bedb := _fa.MakeImageRef(_cgac, &_fddgb.DocBase, _fddgb._cbag)
				_bedb.SetTarget(_cggb)
				_fddgb._caafe[_deeag.Name] = _cggb
				_fddgb.Images = append(_fddgb.Images, _bedb)
				_aaea[_cbdg] = nil
			}
		}
		_eefc.TargetAttr = _cggb
	case _f.DrawingType:
		_bebdd := _fgf.NewWsDr()
		_aaee := uint32(len(_fddgb._beed))
		_ddde.AddTarget(_ebdb, _bebdd, _caebb, _aaee)
		_fddgb._beed = append(_fddgb._beed, _bebdd)
		_cadb := _fa.NewRelationships()
		_ddde.AddTarget(_dg.RelationsPathFor(_ebdb), _cadb.X(), _caebb, _aaee)
		_fddgb._gfgab = append(_fddgb._gfgab, _cadb)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, len(_fddgb._beed))
	case _f.VMLDrawingType:
		_gecd := _ea.NewContainer()
		_aedbb := uint32(len(_fddgb._deea))
		_ddde.AddTarget(_ebdb, _gecd, _caebb, _aedbb)
		_fddgb._deea = append(_fddgb._deea, _gecd)
	case _f.CommentsType:
		_fddgb._aacf[_dcaf.Index] = _fge.NewComments()
		_ddde.AddTarget(_ebdb, _fddgb._aacf[_dcaf.Index], _caebb, _dcaf.Index)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, len(_fddgb._aacf))
	case _f.ChartType:
		_aggbb := _dc.NewChartSpace()
		_gdea := uint32(len(_fddgb._cdbc))
		_ddde.AddTarget(_ebdb, _aggbb, _caebb, _gdea)
		_fddgb._cdbc = append(_fddgb._cdbc, _aggbb)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, len(_fddgb._cdbc))
		if _fddgb._gcae == nil {
			_fddgb._gcae = make(map[string]*_dc.ChartSpace)
		}
		_fddgb._gcae[_eefc.TargetAttr] = _aggbb
	case _f.TableType:
		_gdfgc := _fge.NewTable()
		_geff := uint32(len(_fddgb._eafaa))
		_ddde.AddTarget(_ebdb, _gdfgc, _caebb, _geff)
		_fddgb._eafaa = append(_fddgb._eafaa, _gdfgc)
		_eefc.TargetAttr = _f.RelativeFilename(_dcdf, _dcaf.Typ, _caebb, len(_fddgb._eafaa))
	default:
		_cf.Log.Debug("\u0075\u006e\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065d\u0020\u0072\u0065\u006c\u0061\u0074\u0069o\u006e\u0073\u0068\u0069\u0070\u0020\u0025\u0073\u0020\u0025\u0073", _ebdb, _caebb)
	}
	return nil
}

// AddFont creates a new empty Font style.
func (_ebgba StyleSheet) AddFont() Font { _baad := _fge.NewCT_Font(); return Font{_baad, _ebgba._ccde} }

// Priority returns the rule priority
func (_fdc ConditionalFormattingRule) Priority() int32 { return _fdc._gcgc.PriorityAttr }

// RichText is a container for the rich text within a cell. It's similar to a
// paragaraph for a document, except a cell can only contain one rich text item.
type RichText struct{ _faae *_fge.CT_Rst }

// SetBold causes the text to be displayed in bold.
func (_eeb RichTextRun) SetBold(b bool) {
	_eeb.ensureRpr()
	for _, _bbef := range _eeb._gbe.RPr.RPrEltChoice {
		if _bbef.B != nil {
			_bbef.B.ValAttr = _f.Bool(b)
			return
		}
	}
	_eeb._gbe.RPr.RPrEltChoice = append(_eeb._gbe.RPr.RPrEltChoice, &_fge.CT_RPrEltChoice{B: &_fge.CT_BooleanProperty{ValAttr: _f.Bool(b)}})
}

// IsBool returns true if the cell boolean value.
func (_dge *evalContext) IsBool(cellRef string) bool { return _dge._dgf.Cell(cellRef).IsBool() }

// RangeReference converts a range reference of the form 'A1:A5' to 'Sheet
// 1'!$A$1:$A$5 . Renaming a sheet after calculating a range reference will
// invalidate the reference.
func (_gedaa Sheet) RangeReference(n string) string {
	_fgdg := _d.Split(n, "\u003a")
	_cefg, _ := _gb.ParseCellReference(_fgdg[0])
	_aagb := _c.Sprintf("\u0024\u0025\u0073\u0024\u0025\u0064", _cefg.Column, _cefg.RowIdx)
	if len(_fgdg) == 1 {
		return _c.Sprintf("\u0027%\u0073\u0027\u0021\u0025\u0073", _gedaa.Name(), _aagb)
	}
	_gfgf, _ := _gb.ParseCellReference(_fgdg[1])
	_dffce := _c.Sprintf("\u0024\u0025\u0073\u0024\u0025\u0064", _gfgf.Column, _gfgf.RowIdx)
	return _c.Sprintf("\u0027\u0025\u0073\u0027\u0021\u0025\u0073\u003a\u0025\u0073", _gedaa.Name(), _aagb, _dffce)
}

// MoveTo repositions the anchor without changing the objects size.
func (_daagg TwoCellAnchor) MoveTo(col, row int32) {
	_ebbg := _daagg.TopLeft()
	_decc := _daagg.BottomRight()
	_ebd := _decc.Col() - _ebbg.Col()
	_egbdf := _decc.Row() - _ebbg.Row()
	_ebbg.SetCol(col)
	_ebbg.SetRow(row)
	_decc.SetCol(col + _ebd)
	_decc.SetRow(row + _egbdf)
}

// Cell retrieves or adds a new cell to a row. Col is the column (e.g. 'A', 'B')
func (_afcg Row) Cell(col string) Cell {
	_acge := _c.Sprintf("\u0025\u0073\u0025\u0064", col, _afcg.RowNumber())
	for _, _ddc := range _afcg._feg.C {
		if _ddc.RAttr != nil && *_ddc.RAttr == _acge {
			return Cell{_afcg._dbe, _afcg._gfac, _afcg._feg, _ddc}
		}
	}
	return _afcg.AddNamedCell(col)
}

// SetAuthor sets the author of the comment. If the comment body contains the
// author's name (as is the case with Excel and Comments.AddCommentWithStyle, it
// will not be changed).  This method only changes the metadata author of the
// comment.
func (_fgd Comment) SetAuthor(author string) {
	_fgd._gade.AuthorIdAttr = Comments{_fgd._bcbf, _fgd._bad}.getOrCreateAuthor(author)
}

// DataBarScale is a colored scale that fills the cell with a background
// gradeint depending on the value.
type DataBarScale struct{ _dcec *_fge.CT_DataBar }

// SetCellReference sets the cell reference within a sheet that a comment refers
// to (e.g. "A1")
func (_fdaf Comment) SetCellReference(cellRef string) { _fdaf._gade.RefAttr = cellRef }
func (_gcaag *Sheet) setShared(_fbcc string, _bbca, _beag _gb.CellReference, _gagc string) {
	_dfc := _gcaag.FormulaContext()
	_fdcf := _bac.NewEvaluator()
	for _abegg := _bbca.RowIdx; _abegg <= _beag.RowIdx; _abegg++ {
		for _gedf := _bbca.ColumnIdx; _gedf <= _beag.ColumnIdx; _gedf++ {
			_fgeb := _abegg - _bbca.RowIdx
			_cbad := _gedf - _bbca.ColumnIdx
			_dfc.SetOffset(_cbad, _fgeb)
			_dagd := _fdcf.Eval(_dfc, _gagc)
			_egga := _c.Sprintf("\u0025\u0073\u0025\u0064", _gb.IndexToColumn(_gedf), _abegg)
			_bccf := _gcaag.Cell(_egga)
			if _dagd.Type == _bac.ResultTypeNumber {
				_bccf.X().TAttr = _fge.ST_CellTypeN
			} else {
				_bccf.X().TAttr = _fge.ST_CellTypeInlineStr
			}
			_bccf.X().V = _f.String(_dagd.Value())
		}
	}
	_ = _fdcf
	_ = _dfc
}

// SetMinLength sets the minimum bar length in percent.
func (_fbb DataBarScale) SetMinLength(l uint32) { _fbb._dcec.MinLengthAttr = _f.Uint32(l) }

// GetOrCreateStandardNumberFormat gets or creates a cell style with a given
// standard format. This should only be used when you want to perform
// number/date/time formatting only.  Manipulating the style returned will cause
// all cells using style returned from this for a given format to be formatted.
func (_gafg StyleSheet) GetOrCreateStandardNumberFormat(f StandardFormat) CellStyle {
	for _, _cgcbf := range _gafg.CellStyles() {
		if _cgcbf.HasNumberFormat() && _cgcbf.NumberFormat() == uint32(f) {
			return _cgcbf
		}
	}
	_fccf := _gafg.AddCellStyle()
	_fccf.SetNumberFormatStandard(f)
	return _fccf
}
func (_gdfg Font) SetBold(b bool) {
	_adda := false
	for _bfda, _eac := range _gdfg._caed.FontChoice {
		if _eac.B != nil {
			if b {
				_gdfg._caed.FontChoice[_bfda].B = &_fge.CT_BooleanProperty{}
			} else {
				_gdfg._caed.FontChoice[_bfda] = nil
			}
			_adda = true
		}
	}
	if !_adda {
		_gdfg._caed.FontChoice = append(_gdfg._caed.FontChoice, &_fge.CT_FontChoice{B: &_fge.CT_BooleanProperty{}})
	}
}

// SetColorScale configures the rule as a color scale, removing existing
// configuration.
func (_ccd ConditionalFormattingRule) SetColorScale() ColorScale {
	_ccd.clear()
	_ccd.SetType(_fge.ST_CfTypeColorScale)
	_ccd._gcgc.ColorScale = _fge.NewCT_ColorScale()
	return ColorScale{_ccd._gcgc.ColorScale}
}

// BottomRight is a no-op.
func (_ffe OneCellAnchor) BottomRight() CellMarker { return CellMarker{} }

// Cell returns the actual cell behind the merged region
func (_dfee MergedCell) Cell() Cell {
	_afff := _dfee.Reference()
	if _daag := _d.Index(_dfee.Reference(), "\u003a"); _daag != -1 {
		_afff = _afff[0:_daag]
		return _dfee._edfd.Cell(_afff)
	}
	return Cell{}
}

// AddDrawing adds a drawing to a workbook.  However the drawing is not actually
// displayed or used until it's set on a sheet.
func (_ffff *Workbook) AddDrawing() Drawing {
	_caff := _fgf.NewWsDr()
	_ffff._beed = append(_ffff._beed, _caff)
	_fgadb := _f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.DrawingType, len(_ffff._beed))
	_ffff.ContentTypes.AddOverride(_fgadb, _f.DrawingContentType)
	_ffff._gfgab = append(_ffff._gfgab, _fa.NewRelationships())
	return Drawing{_ffff, _caff}
}

// AddCellStyle creates a new empty cell style.
func (_bdcb StyleSheet) AddCellStyle() CellStyle {
	_bdabe := _fge.NewCT_Xf()
	return CellStyle{_bdcb._eafa, _bdabe, _bdcb._ccde.CellXfs}
}

// ClearAutoFilter removes the autofilters from the sheet.
func (_gecc *Sheet) ClearAutoFilter() {
	_gecc._defb.AutoFilter = nil
	_efb := "\u0027" + _gecc.Name() + "\u0027\u0021"
	for _, _cdeg := range _gecc._fgca.DefinedNames() {
		if _cdeg.Name() == _ecff {
			if _d.HasPrefix(_cdeg.Content(), _efb) {
				_gecc._fgca.RemoveDefinedName(_cdeg)
				break
			}
		}
	}
}

// IsSheetLocked returns whether the sheet objects are locked.
func (_gcaaa SheetProtection) IsObjectLocked() bool {
	return _gcaaa._bbaf.ObjectsAttr != nil && *_gcaaa._bbaf.ObjectsAttr
}

// GetLabelPrefix returns label prefix which depends on the cell's horizontal alignment.
func (_dffd *evalContext) GetLabelPrefix(cellRef string) string {
	return _dffd._dgf.Cell(cellRef).getLabelPrefix()
}

// SetBorder is a helper function for creating borders across multiple cells. In
// the OOXML spreadsheet format, a border applies to a single cell.  To draw a
// 'boxed' border around multiple cells, you need to apply different styles to
// the cells on the top,left,right,bottom and four corners.  This function
// breaks apart a single border into its components and applies it to cells as
// needed to give the effect of a border applying to multiple cells.
func (_cgde *Sheet) SetBorder(cellRange string, border Border) error {
	_gfdf, _decea, _bgbe := _gb.ParseRangeReference(cellRange)
	if _bgbe != nil {
		return _bgbe
	}
	_bdef := _cgde._fgca.StyleSheet.AddCellStyle()
	_gdfb := _cgde._fgca.StyleSheet.AddBorder()
	_bdef.SetBorder(_gdfb)
	_gdfb._ed.Top = border._ed.Top
	_gdfb._ed.Left = border._ed.Left
	_deaf := _cgde._fgca.StyleSheet.AddCellStyle()
	_ddgb := _cgde._fgca.StyleSheet.AddBorder()
	_deaf.SetBorder(_ddgb)
	_ddgb._ed.Top = border._ed.Top
	_ddgb._ed.Right = border._ed.Right
	_aacac := _cgde._fgca.StyleSheet.AddCellStyle()
	_fae := _cgde._fgca.StyleSheet.AddBorder()
	_aacac.SetBorder(_fae)
	_fae._ed.Top = border._ed.Top
	_gded := _cgde._fgca.StyleSheet.AddCellStyle()
	_fdf := _cgde._fgca.StyleSheet.AddBorder()
	_gded.SetBorder(_fdf)
	_fdf._ed.Left = border._ed.Left
	_dcga := _cgde._fgca.StyleSheet.AddCellStyle()
	_cafc := _cgde._fgca.StyleSheet.AddBorder()
	_dcga.SetBorder(_cafc)
	_cafc._ed.Right = border._ed.Right
	_faef := _cgde._fgca.StyleSheet.AddCellStyle()
	_dddcab := _cgde._fgca.StyleSheet.AddBorder()
	_faef.SetBorder(_dddcab)
	_dddcab._ed.Bottom = border._ed.Bottom
	_efeb := _cgde._fgca.StyleSheet.AddCellStyle()
	_efebe := _cgde._fgca.StyleSheet.AddBorder()
	_efeb.SetBorder(_efebe)
	_efebe._ed.Bottom = border._ed.Bottom
	_efebe._ed.Left = border._ed.Left
	_egde := _cgde._fgca.StyleSheet.AddCellStyle()
	_ada := _cgde._fgca.StyleSheet.AddBorder()
	_egde.SetBorder(_ada)
	_ada._ed.Bottom = border._ed.Bottom
	_ada._ed.Right = border._ed.Right
	_aggf := _gfdf.RowIdx
	_eage := _gfdf.ColumnIdx
	_ebed := _decea.RowIdx
	_cbec := _decea.ColumnIdx
	for _ddgbf := _aggf; _ddgbf <= _ebed; _ddgbf++ {
		for _bcbfa := _eage; _bcbfa <= _cbec; _bcbfa++ {
			_deagb := _c.Sprintf("\u0025\u0073\u0025\u0064", _gb.IndexToColumn(_bcbfa), _ddgbf)
			switch {
			case _ddgbf == _aggf && _bcbfa == _eage:
				_cgde.Cell(_deagb).SetStyle(_bdef)
			case _ddgbf == _aggf && _bcbfa == _cbec:
				_cgde.Cell(_deagb).SetStyle(_deaf)
			case _ddgbf == _ebed && _bcbfa == _eage:
				_cgde.Cell(_deagb).SetStyle(_efeb)
			case _ddgbf == _ebed && _bcbfa == _cbec:
				_cgde.Cell(_deagb).SetStyle(_egde)
			case _ddgbf == _aggf:
				_cgde.Cell(_deagb).SetStyle(_aacac)
			case _ddgbf == _ebed:
				_cgde.Cell(_deagb).SetStyle(_faef)
			case _bcbfa == _eage:
				_cgde.Cell(_deagb).SetStyle(_gded)
			case _bcbfa == _cbec:
				_cgde.Cell(_deagb).SetStyle(_dcga)
			}
		}
	}
	return nil
}

// ClearProtection clears all workbook protections.
func (_cbba *Workbook) ClearProtection() { _cbba._fefd.WorkbookProtection = nil }

// New constructs a new workbook.
func New() *Workbook {
	_fbgf := &Workbook{}
	_fbgf._fefd = _fge.NewWorkbook()
	_fbgf.AppProperties = _fa.NewAppProperties()
	_fbgf.CoreProperties = _fa.NewCoreProperties()
	_fbgf.StyleSheet = NewStyleSheet(_fbgf)
	_fbgf.Rels = _fa.NewRelationships()
	_fbgf._cbag = _fa.NewRelationships()
	_fbgf.Rels.AddRelationship(_f.RelativeFilename(_f.DocTypeSpreadsheet, "", _f.ExtendedPropertiesType, 0), _f.ExtendedPropertiesType)
	_fbgf.Rels.AddRelationship(_f.RelativeFilename(_f.DocTypeSpreadsheet, "", _f.CorePropertiesType, 0), _f.CorePropertiesType)
	_fbgf.Rels.AddRelationship(_f.RelativeFilename(_f.DocTypeSpreadsheet, "", _f.OfficeDocumentType, 0), _f.OfficeDocumentType)
	_fbgf._cbag.AddRelationship(_f.RelativeFilename(_f.DocTypeSpreadsheet, _f.OfficeDocumentType, _f.StylesType, 0), _f.StylesType)
	_fbgf.ContentTypes = _fa.NewContentTypes()
	_fbgf.ContentTypes.AddDefault("\u0076\u006d\u006c", _f.VMLDrawingContentType)
	_fbgf.ContentTypes.AddOverride(_f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.OfficeDocumentType, 0), "\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066o\u0072\u006d\u0061\u0074s\u002d\u006f\u0066\u0066\u0069\u0063e\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0073\u0070\u0072\u0065\u0061\u0064\u0073\u0068e\u0065\u0074\u006d\u006c\u002e\u0073\u0068\u0065\u0065\u0074\u002e\u006d\u0061\u0069\u006e\u002b\u0078\u006d\u006c")
	_fbgf.ContentTypes.AddOverride(_f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.StylesType, 0), _f.SMLStyleSheetContentType)
	_fbgf.SharedStrings = NewSharedStrings()
	_fbgf.ContentTypes.AddOverride(_f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.SharedStringsType, 0), _f.SharedStringsContentType)
	_fbgf._cbag.AddRelationship(_f.RelativeFilename(_f.DocTypeSpreadsheet, _f.OfficeDocumentType, _f.SharedStringsType, 0), _f.SharedStringsType)
	_fbgf._caafe = map[string]string{}
	return _fbgf
}

// Rows returns all of the rows in a sheet.
func (_ddad *Sheet) Rows() []Row {
	_cfge := []Row{}
	for _, _beeg := range _ddad._defb.SheetData.Row {
		_cfge = append(_cfge, Row{_ddad._fgca, _ddad, _beeg})
	}
	return _cfge
}

// AddNumberFormat adds a new blank number format to the stylesheet.
func (_dffdf StyleSheet) AddNumberFormat() NumberFormat {
	if _dffdf._ccde.NumFmts == nil {
		_dffdf._ccde.NumFmts = _fge.NewCT_NumFmts()
	}
	_ffbf := _fge.NewCT_NumFmt()
	_ffbf.NumFmtIdAttr = uint32(200 + len(_dffdf._ccde.NumFmts.NumFmt))
	_dffdf._ccde.NumFmts.NumFmt = append(_dffdf._ccde.NumFmts.NumFmt, _ffbf)
	_dffdf._ccde.NumFmts.CountAttr = _f.Uint32(uint32(len(_dffdf._ccde.NumFmts.NumFmt)))
	return NumberFormat{_dffdf._eafa, _ffbf}
}

// SetFormulaRaw sets the cell type to formula, and the raw formula to the given string
func (_gbag Cell) SetFormulaRaw(s string) {
	_cd := _bac.ParseString(s)
	if _cd == nil {
		return
	}
	_gbag.clearValue()
	_gbag._dced.TAttr = _fge.ST_CellTypeStr
	_gbag._dced.F = _fge.NewCT_CellFormula()
	_gbag._dced.F.Content = s
}

// TwoCellAnchor is an anchor that is attached to a top-left cell with a fixed
// width/height in cells.
type TwoCellAnchor struct{ _efed *_fgf.CT_TwoCellAnchor }

// Read reads a workbook from an io.Reader(.xlsx).
func Read(r _ad.ReaderAt, size int64) (*Workbook, error) {
	const _abgg = "\u0073\u0070r\u0065\u0061\u0064s\u0068\u0065\u0065\u0074\u003a\u0052\u0065\u0061\u0064"
	if !_e.GetLicenseKey().IsLicensed() && !_cfbf {
		_c.Println("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065")
		_c.Println("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
		return nil, _fb.New("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064")
	}
	_abc := "\u0075n\u006b\u006e\u006f\u0077\u006e"
	if _efeg, _fedg := r.(*_abd.File); _fedg {
		_abc = _efeg.Name()
	}
	_eafb := New()
	_bfacg, _gddf := _e.GenRefId("\u0073\u0072")
	if _gddf != nil {
		_cf.Log.Error("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gddf)
		return nil, _gddf
	}
	_eafb._fead = _bfacg
	if _aeaf := _e.Track(_eafb._fead, _abgg, _abc); _aeaf != nil {
		_cf.Log.Error("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _aeaf)
		return nil, _aeaf
	}
	_eegc, _gddf := _ce.TempDir("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0078\u006c\u0073\u0078")
	if _gddf != nil {
		return nil, _gddf
	}
	_eafb.TmpPath = _eegc
	_faaf, _gddf := _ag.NewReader(r, size)
	if _gddf != nil {
		return nil, _c.Errorf("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073", _gddf)
	}
	_bdcd := []*_ag.File{}
	_bdcd = append(_bdcd, _faaf.File...)
	_cgdd := false
	for _, _gfbb := range _bdcd {
		if _gfbb.FileHeader.Name == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
			_cgdd = true
			break
		}
	}
	if _cgdd {
		_eafb.CreateCustomProperties()
	}
	_fgde := _dg.DecodeMap{}
	_fgde.SetOnNewRelationshipFunc(_eafb.onNewRelationship)
	_fgde.AddTarget(_f.ContentTypesFilename, _eafb.ContentTypes.X(), "", 0)
	_fgde.AddTarget(_f.BaseRelsFilename, _eafb.Rels.X(), "", 0)
	if _fbcd := _fgde.Decode(_bdcd); _fbcd != nil {
		return nil, _fbcd
	}
	for _, _fced := range _bdcd {
		if _fced == nil {
			continue
		}
		if _eee := _eafb.AddExtraFileFromZip(_fced); _eee != nil {
			return nil, _eee
		}
	}
	if _cgdd {
		_ede := false
		for _, _abeg := range _eafb.Rels.X().Relationship {
			if _abeg.TargetAttr == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
				_ede = true
				break
			}
		}
		if !_ede {
			_eafb.AddCustomRelationships()
		}
	}
	return _eafb, nil
}

// SortOrder is a column sort order.
//
//go:generate stringer -type=SortOrder
type SortOrder byte

func (_cff CellStyle) SetShrinkToFit(b bool) {
	if _cff._dece.Alignment == nil {
		_cff._dece.Alignment = _fge.NewCT_CellAlignment()
	}
	_cff._dece.ApplyAlignmentAttr = _f.Bool(true)
	if !b {
		_cff._dece.Alignment.ShrinkToFitAttr = nil
	} else {
		_cff._dece.Alignment.ShrinkToFitAttr = _f.Bool(b)
	}
}
func (_edbf Sheet) IsValid() bool { return _edbf._defb != nil }

// AddFill creates a new empty Fill style.
func (_fed Fills) AddFill() Fill { _cfd := _fge.NewCT_Fill(); return Fill{_cfd, _fed._dbgaf} }

// SetType sets the type of the rule.
func (_cag ConditionalFormattingRule) SetType(t _fge.ST_CfType) { _cag._gcgc.TypeAttr = t }

// Col returns the column of the cell marker.
func (_ded CellMarker) Col() int32 { return _ded._fdd.Col }

// SetCol set the column of the cell marker.
func (_bgc CellMarker) SetCol(col int32) { _bgc._fdd.Col = col }

// NumberFormat is a number formatting string that can be applied to a cell
// style.
type NumberFormat struct {
	_bcgef *Workbook
	_gage  *_fge.CT_NumFmt
}

// RemoveFont removes a font from the style sheet.  It *does not* update styles that refer
// to this font.
func (_bggg StyleSheet) RemoveFont(f Font) error {
	for _gacb, _cagf := range _bggg._ccde.Fonts.Font {
		if _cagf == f.X() {
			_bggg._ccde.Fonts.Font = append(_bggg._ccde.Fonts.Font[:_gacb], _bggg._ccde.Fonts.Font[_gacb+1:]...)
			return nil
		}
	}
	return _fb.New("\u0066\u006f\u006e\u0074\u0020\u006e\u006f\u0074\u0020f\u006f\u0075\u006e\u0064")
}

// SetShowRuler controls the visibility of the ruler
func (_fadda SheetView) SetShowRuler(b bool) {
	if !b {
		_fadda._gfdfg.ShowRulerAttr = _f.Bool(false)
	} else {
		_fadda._gfdfg.ShowRulerAttr = nil
	}
}

// GetSheet returns a sheet by name, or an error if a sheet by the given name
// was not found.
func (_fbdca *Workbook) GetSheet(name string) (Sheet, error) {
	for _, _bbeed := range _fbdca.Sheets() {
		if _bbeed.Name() == name {
			return _bbeed, nil
		}
	}
	return Sheet{}, ErrorNotFound
}

// SetNumberFormat applies a number format to a cell style avoiding redundancy. The function checks if the given string
// already exists in the saved number formats. If found, the existing number format is reused; otherwise,
// the new number format is added to the saved number formats collection. The number format is then applied to the cell style,
// affecting all styles that reference it by index.
func (_fgab CellStyle) SetNumberFormat(s string) {
	var _fgg NumberFormat
	if _fgab._decg.StyleSheet._ccde.NumFmts == nil {
		_fgab._decg.StyleSheet._ccde.NumFmts = _fge.NewCT_NumFmts()
	}
	_dgc := _fgab._decg.StyleSheet._ccde.NumFmts.NumFmt
	for _, _bca := range _dgc {
		if _bb.DeepEqual(_bca.FormatCodeAttr, s) {
			_fgg = NumberFormat{_fgab._decg, _bca}
			_fgab._dece.ApplyNumberFormatAttr = _f.Bool(true)
			_fgab._dece.NumFmtIdAttr = _f.Uint32(_fgg.ID())
			return
		}
	}
	_cab := _fge.NewCT_NumFmt()
	_cab.NumFmtIdAttr = uint32(200 + len(_fgab._decg.StyleSheet._ccde.NumFmts.NumFmt))
	_fgab._decg.StyleSheet._ccde.NumFmts.NumFmt = append(_fgab._decg.StyleSheet._ccde.NumFmts.NumFmt, _cab)
	_fgab._decg.StyleSheet._ccde.NumFmts.CountAttr = _f.Uint32(uint32(len(_fgab._decg.StyleSheet._ccde.NumFmts.NumFmt)))
	_fgg = NumberFormat{_fgab._decg, _cab}
	_fgg._gage.FormatCodeAttr = s
	_fgab._dece.ApplyNumberFormatAttr = _f.Bool(true)
	_fgab._dece.NumFmtIdAttr = _f.Uint32(_fgg.ID())
}
func (_gebe Fill) SetPatternFill() PatternFill {
	if _gebe._afcd.FillChoice == nil {
		_gebe._afcd.FillChoice = _fge.NewCT_FillChoice()
	}
	_gebe._afcd.FillChoice.GradientFill = nil
	_gebe._afcd.FillChoice.PatternFill = _fge.NewCT_PatternFill()
	_gebe._afcd.FillChoice.PatternFill.PatternTypeAttr = _fge.ST_PatternTypeSolid
	return PatternFill{_gebe._afcd.FillChoice.PatternFill, _gebe._afcd}
}

// CopySheet copies the existing sheet at index `ind` and puts its copy with the name `copiedSheetName`.
func (_fdcg *Workbook) CopySheet(ind int, copiedSheetName string) (Sheet, error) {
	if _fdcg.SheetCount() <= ind {
		return Sheet{}, ErrorNotFound
	}
	var _fgacf _fa.Relationship
	for _, _ccdeg := range _fdcg._cbag.Relationships() {
		if _ccdeg.ID() == _fdcg._fefd.Sheets.Sheet[ind].IdAttr {
			var _cafa bool
			if _fgacf, _cafa = _fdcg._cbag.CopyRelationship(_ccdeg.ID()); !_cafa {
				return Sheet{}, ErrorNotFound
			}
			break
		}
	}
	_fdcg.ContentTypes.CopyOverride(_f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.WorksheetContentType, ind+1), _f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.WorksheetContentType, len(_fdcg.ContentTypes.X().TypesChoice)))
	_daea := *_fdcg._egabd[ind]
	_fdcg._egabd = append(_fdcg._egabd, &_daea)
	var _efdf uint32 = 0
	for _, _abcb := range _fdcg._fefd.Sheets.Sheet {
		if _abcb.SheetIdAttr > _efdf {
			_efdf = _abcb.SheetIdAttr
		}
	}
	_efdf++
	_egeg := *_fdcg._fefd.Sheets.Sheet[ind]
	_egeg.IdAttr = _fgacf.ID()
	_egeg.NameAttr = copiedSheetName
	_egeg.SheetIdAttr = _efdf
	_fdcg._fefd.Sheets.Sheet = append(_fdcg._fefd.Sheets.Sheet, &_egeg)
	_dfaf := _fa.NewRelationshipsCopy(_fdcg._bbea[ind])
	_fdcg._bbea = append(_fdcg._bbea, _dfaf)
	_gfce := _fdcg._aacf[ind]
	if _gfce == nil {
		_fdcg._aacf = append(_fdcg._aacf, nil)
	} else {
		_afegb := *_gfce
		_fdcg._aacf = append(_fdcg._aacf, &_afegb)
	}
	_ddgf := Sheet{_fdcg, &_egeg, &_daea}
	return _ddgf, nil
}

// SetDrawing sets the worksheet drawing.  A worksheet can have a reference to a
// single drawing, but the drawing can have many charts.
func (_cdfce *Sheet) SetDrawing(d Drawing) {
	var _affb _fa.Relationships
	for _dfg, _ecef := range _cdfce._fgca._egabd {
		if _ecef == _cdfce._defb {
			_affb = _cdfce._fgca._bbea[_dfg]
			break
		}
	}
	var _egcb string
	for _dccc, _gbg := range d._dfbc._beed {
		if _gbg == d._caeb {
			_fddec := _affb.AddAutoRelationship(_f.DocTypeSpreadsheet, _f.WorksheetType, _dccc+1, _f.DrawingType)
			_egcb = _fddec.ID()
			break
		}
	}
	_cdfce._defb.Drawing = _fge.NewCT_Drawing()
	_cdfce._defb.Drawing.IdAttr = _egcb
}

// CellsWithEmpty returns a slice of cells including empty ones from the first column to the last one used in the sheet.
// The cells can be manipulated, but appending to the slice will have no effect.
func (_cda Row) CellsWithEmpty(lastColIdx uint32) []Cell {
	_bgfb := []Cell{}
	for _gbee := uint32(0); _gbee <= lastColIdx; _gbee++ {
		_bffb := _cda.Cell(_gb.IndexToColumn(_gbee))
		_bgfb = append(_bgfb, _bffb)
	}
	return _bgfb
}

const (
	DVCompareOpEqual        = DVCompareOp(_fge.ST_DataValidationOperatorEqual)
	DVCompareOpBetween      = DVCompareOp(_fge.ST_DataValidationOperatorBetween)
	DVCompareOpNotBetween   = DVCompareOp(_fge.ST_DataValidationOperatorNotBetween)
	DVCompareOpNotEqual     = DVCompareOp(_fge.ST_DataValidationOperatorNotEqual)
	DVCompareOpGreater      = DVCompareOp(_fge.ST_DataValidationOperatorGreaterThan)
	DVCompareOpGreaterEqual = DVCompareOp(_fge.ST_DataValidationOperatorGreaterThanOrEqual)
	DVCompareOpLess         = DVCompareOp(_fge.ST_DataValidationOperatorLessThan)
	DVCompareOpLessEqual    = DVCompareOp(_fge.ST_DataValidationOperatorLessThanOrEqual)
)

// AddFormatValue adds a format value (databars require two).
func (_ebgb DataBarScale) AddFormatValue(t _fge.ST_CfvoType, val string) {
	_ddb := _fge.NewCT_Cfvo()
	_ddb.TypeAttr = t
	_ddb.ValAttr = _f.String(val)
	_ebgb._dcec.Cfvo = append(_ebgb._dcec.Cfvo, _ddb)
}
func (_agg Cell) getLocked() bool {
	if _agg._dced.SAttr == nil {
		return false
	}
	_affg := *_agg._dced.SAttr
	_eef := _agg._ef.StyleSheet.GetCellStyle(_affg)
	return *_eef._dece.Protection.LockedAttr
}

// RowNumber returns the row number (1-N), or zero if it is unset.
func (_eefg Row) RowNumber() uint32 {
	if _eefg._feg.RAttr != nil {
		return *_eefg._feg.RAttr
	}
	return 0
}

// NewSharedStrings constructs a new Shared Strings table.
func NewSharedStrings() SharedStrings {
	return SharedStrings{_ebge: _fge.NewSst(), _cbdf: make(map[string]int)}
}

// Operator returns the operator for the rule
func (_cae ConditionalFormattingRule) Operator() _fge.ST_ConditionalFormattingOperator {
	return _cae._gcgc.OperatorAttr
}

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_gcca *Sheet) ClearCachedFormulaResults() {
	for _, _ddag := range _gcca.Rows() {
		for _, _bge := range _ddag.Cells() {
			if _bge.X().F != nil {
				_bge.X().V = nil
			}
		}
	}
}

// SetFormulaShared sets the cell type to formula shared, and the raw formula to
// the given string. The range is the range of cells that the formula applies
// to, and is used to conserve disk space.
func (_bed Cell) SetFormulaShared(formulaStr string, rows, cols uint32) error {
	_ac := _bac.ParseString(formulaStr)
	if _ac == nil {
		return _fb.New(_c.Sprintf("\u0043a\u006en\u006f\u0074\u0020\u0070\u0061\u0072\u0073\u0065\u0020\u0025\u0073", formulaStr))
	}
	_bed.clearValue()
	_bed._dced.TAttr = _fge.ST_CellTypeStr
	_bed._dced.F = _fge.NewCT_CellFormula()
	_bed._dced.F.TAttr = _fge.ST_CellFormulaTypeShared
	_bed._dced.F.Content = formulaStr
	_dfd, _abe := _gb.ParseCellReference(_bed.Reference())
	if _abe != nil {
		return _abe
	}
	_gf := uint32(0)
	for _, _cdg := range _bed._eg.Rows() {
		for _, _eda := range _cdg._feg.C {
			if _eda.F != nil && _eda.F.SiAttr != nil && *_eda.F.SiAttr >= _gf {
				_gf = *_eda.F.SiAttr
			}
		}
	}
	_gf++
	_ebg := _c.Sprintf("\u0025s\u0025\u0064\u003a\u0025\u0073\u0025d", _dfd.Column, _dfd.RowIdx, _gb.IndexToColumn(_dfd.ColumnIdx+cols), _dfd.RowIdx+rows)
	_bed._dced.F.RefAttr = _f.String(_ebg)
	_bed._dced.F.SiAttr = _f.Uint32(_gf)
	_bgf := Sheet{_bed._ef, _bed._eg._bgfdd, _bed._eg._defb}
	for _gc := _dfd.RowIdx; _gc <= _dfd.RowIdx+rows; _gc++ {
		for _bbc := _dfd.ColumnIdx; _bbc <= _dfd.ColumnIdx+cols; _bbc++ {
			if _gc == _dfd.RowIdx && _bbc == _dfd.ColumnIdx {
				continue
			}
			_ceg := _c.Sprintf("\u0025\u0073\u0025\u0064", _gb.IndexToColumn(_bbc), _gc)
			_bgf.Cell(_ceg).Clear()
			_bgf.Cell(_ceg).X().F = _fge.NewCT_CellFormula()
			_bgf.Cell(_ceg).X().F.TAttr = _fge.ST_CellFormulaTypeShared
			_bgf.Cell(_ceg).X().F.SiAttr = _f.Uint32(_gf)
		}
	}
	return nil
}

// Row returns the row of the cell marker.
func (_bbf CellMarker) Row() int32 { return _bbf._fdd.Row }

// LastRow returns the name of last row which contains data in range of context sheet's given columns.
func (_ceac *evalContext) LastRow(col string) int {
	_aaf := _ceac._dgf
	_adge := int(_gb.ColumnToIndex(col))
	_bce := 1
	for _, _cdcd := range _aaf._defb.SheetData.Row {
		if _cdcd.RAttr != nil {
			_fafe := Row{_aaf._fgca, _aaf, _cdcd}
			_ege := len(_fafe.Cells())
			if _ege > _adge {
				_bce = int(_fafe.RowNumber())
			}
		}
	}
	return _bce
}
func (_ecgb *evalContext) SetOffset(col, row uint32) { _ecgb._gca = col; _ecgb._cdd = row }
func (_aea DifferentialStyle) Fill() Fill {
	if _aea._ceag.Fill == nil {
		_aea._ceag.Fill = _fge.NewCT_Fill()
	}
	return Fill{_aea._ceag.Fill, nil}
}

// SetTopLeft sets the top left visible cell after the split.
func (_ceaf SheetView) SetTopLeft(cellRef string) {
	_ceaf.ensurePane()
	_ceaf._gfdfg.Pane.TopLeftCellAttr = &cellRef
}

// Sheets returns the sheets from the workbook.
func (_dgdb *Workbook) Sheets() []Sheet {
	_eegbe := []Sheet{}
	for _gbcde, _cceeb := range _dgdb._egabd {
		_beegb := _dgdb._fefd.Sheets.Sheet[_gbcde]
		if _beegb.StateAttr == _fge.ST_SheetStateHidden || _beegb.StateAttr == _fge.ST_SheetStateVeryHidden {
			continue
		}
		_dgfc := Sheet{_dgdb, _beegb, _cceeb}
		_eegbe = append(_eegbe, _dgfc)
	}
	return _eegbe
}

const _gageb = "\u0053\u006fr\u0074\u004f\u0072\u0064e\u0072\u0041s\u0063\u0065\u006e\u0064\u0069\u006e\u0067\u0053o\u0072\u0074\u004f\u0072\u0064\u0065\u0072\u0044\u0065\u0073\u0063\u0065n\u0064\u0069\u006e\u0067"

// LockWindow controls the locking of the workbook windows.
func (_agdad WorkbookProtection) LockWindow(b bool) {
	if !b {
		_agdad._edcb.LockWindowsAttr = nil
	} else {
		_agdad._edcb.LockWindowsAttr = _f.Bool(true)
	}
}

// InsertRow inserts a new row into a spreadsheet at a particular row number.  This
// row will now be the row number specified, and any rows after it will be renumbed.
func (_agb *Sheet) InsertRow(rowNum int) Row {
	_cfbd := uint32(rowNum)
	for _, _cbc := range _agb.Rows() {
		if _cbc._feg.RAttr != nil && *_cbc._feg.RAttr >= _cfbd {
			*_cbc._feg.RAttr++
			for _, _fbac := range _cbc.Cells() {
				_agc, _aegc := _gb.ParseCellReference(_fbac.Reference())
				if _aegc != nil {
					continue
				}
				_agc.RowIdx++
				_fbac._dced.RAttr = _f.String(_agc.String())
			}
		}
	}
	for _, _fafec := range _agb.MergedCells() {
		_egce, _bdd, _aeab := _gb.ParseRangeReference(_fafec.Reference())
		if _aeab != nil {
			continue
		}
		if int(_egce.RowIdx) >= rowNum {
			_egce.RowIdx++
		}
		if int(_bdd.RowIdx) >= rowNum {
			_bdd.RowIdx++
		}
		_eddg := _c.Sprintf("\u0025\u0073\u003a%\u0073", _egce, _bdd)
		_fafec.SetReference(_eddg)
	}
	return _agb.AddNumberedRow(_cfbd)
}

// RemoveMergedCell removes merging from a cell range within a sheet.  The cells
// that made up the merged cell remain, but are no lon merged.
func (_agee *Sheet) RemoveMergedCell(mc MergedCell) {
	for _bebd, _ecdfa := range _agee._defb.MergeCells.MergeCell {
		if _ecdfa == mc.X() {
			copy(_agee._defb.MergeCells.MergeCell[_bebd:], _agee._defb.MergeCells.MergeCell[_bebd+1:])
			_agee._defb.MergeCells.MergeCell[len(_agee._defb.MergeCells.MergeCell)-1] = nil
			_agee._defb.MergeCells.MergeCell = _agee._defb.MergeCells.MergeCell[:len(_agee._defb.MergeCells.MergeCell)-1]
		}
	}
}
func (_ccaf Fills) appendFill() Fill {
	_abce := _fge.NewCT_Fill()
	_ccaf._dbgaf.Fill = append(_ccaf._dbgaf.Fill, _abce)
	_ccaf._dbgaf.CountAttr = _f.Uint32(uint32(len(_ccaf._dbgaf.Fill)))
	return Fill{_abce, _ccaf._dbgaf}
}

// AddCell adds a cell to a spreadsheet.
func (_gfcf Row) AddCell() Cell {
	_fadg := uint32(len(_gfcf._feg.C))
	var _gef *string
	if _fadg > 0 {
		_feae := _f.Stringf("\u0025\u0073\u0025\u0064", _gb.IndexToColumn(_fadg-1), _gfcf.RowNumber())
		if _gfcf._feg.C[_fadg-1].RAttr != nil && *_gfcf._feg.C[_fadg-1].RAttr == *_feae {
			_gef = _f.Stringf("\u0025\u0073\u0025\u0064", _gb.IndexToColumn(_fadg), _gfcf.RowNumber())
		}
	}
	_gaffd := _fge.NewCT_Cell()
	_gfcf._feg.C = append(_gfcf._feg.C, _gaffd)
	if _gef == nil {
		_egab := uint32(0)
		for _, _efee := range _gfcf._feg.C {
			if _efee.RAttr != nil {
				_fbddf, _ := _gb.ParseCellReference(*_efee.RAttr)
				if _fbddf.ColumnIdx >= _egab {
					_egab = _fbddf.ColumnIdx + 1
				}
			}
		}
		_gef = _f.Stringf("\u0025\u0073\u0025\u0064", _gb.IndexToColumn(_egab), _gfcf.RowNumber())
	}
	_gaffd.RAttr = _gef
	return Cell{_gfcf._dbe, _gfcf._gfac, _gfcf._feg, _gaffd}
}

// InitialView returns the first defined sheet view. If there are no views, one
// is created and returned.
func (_fded *Sheet) InitialView() SheetView {
	if _fded._defb.SheetViews == nil || len(_fded._defb.SheetViews.SheetView) == 0 {
		return _fded.AddView()
	}
	return SheetView{_fded._defb.SheetViews.SheetView[0]}
}

// SetHorizontalAlignment sets the horizontal alignment of a cell style.
func (_ccce CellStyle) SetHorizontalAlignment(a _fge.ST_HorizontalAlignment) {
	if _ccce._dece.Alignment == nil {
		_ccce._dece.Alignment = _fge.NewCT_CellAlignment()
	}
	_ccce._dece.Alignment.HorizontalAttr = a
	_ccce._dece.ApplyAlignmentAttr = _f.Bool(true)
}

// LockStructure controls the locking of the workbook structure.
func (_gggc WorkbookProtection) LockStructure(b bool) {
	if !b {
		_gggc._edcb.LockStructureAttr = nil
	} else {
		_gggc._edcb.LockStructureAttr = _f.Bool(true)
	}
}

// GetFont gets a Font from a cell style.
func (_cdfc CellStyle) GetFont() *_fge.CT_Font {
	if _fbfe := _cdfc._dece.FontIdAttr; _fbfe != nil {
		_fdg := _cdfc._decg.StyleSheet.Fonts()
		if int(*_fbfe) < len(_fdg) {
			return _fdg[int(*_fbfe)].X()
		}
	}
	return nil
}

var _ebdc = _f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.SharedStringsType, 0)

// SetDataBar configures the rule as a data bar, removing existing
// configuration.
func (_ecdfe ConditionalFormattingRule) SetDataBar() DataBarScale {
	_ecdfe.clear()
	_ecdfe.SetType(_fge.ST_CfTypeDataBar)
	_ecdfe._gcgc.DataBar = _fge.NewCT_DataBar()
	_ecce := DataBarScale{_ecdfe._gcgc.DataBar}
	_ecce.SetShowValue(true)
	_ecce.SetMinLength(10)
	_ecce.SetMaxLength(90)
	return _ecce
}

// X returns the inner wrapped XML type.
func (_bdge ConditionalFormatting) X() *_fge.CT_ConditionalFormatting { return _bdge._addb }

// Type returns the type of anchor
func (_gaafc OneCellAnchor) Type() AnchorType { return AnchorTypeOneCell }

// X returns the inner wrapped XML type.
func (_affe DataBarScale) X() *_fge.CT_DataBar { return _affe._dcec }

// SetBorder applies a border to a cell style avoiding redundancy. The function checks if the given border
// already exists in the saved borders. If found, the existing border is reused; otherwise,
// the new border is added to the saved borders collection. The border is then applied to the cell style,
// affecting all styles that reference it by index.
func (_dbc CellStyle) SetBorder(b Border) {
	_cee := b._cfb.Border
	for _, _bef := range _cee {
		if _bb.DeepEqual(_bef, b._ed) {
			b._ed = _bef
			_dbc._dece.BorderIdAttr = _f.Uint32(b.Index())
			_dbc._dece.ApplyBorderAttr = _f.Bool(true)
			return
		}
	}
	b._cfb.Border = append(b._cfb.Border, b._ed)
	b._cfb.CountAttr = _f.Uint32(uint32(len(b._cfb.Border)))
	_dbc._dece.BorderIdAttr = _f.Uint32(b.Index())
	_dbc._dece.ApplyBorderAttr = _f.Bool(true)
}

// GetFilename returns the filename of the context's workbook.
func (_gff *evalContext) GetFilename() string { return _gff._dgf._fgca.GetFilename() }

// ExtractText returns text from the sheet as a SheetText object.
func (_beaa *Sheet) ExtractText() *SheetText {
	_fcbe := []CellText{}
	for _, _cba := range _beaa.Rows() {
		for _, _efa := range _cba.Cells() {
			if !_efa.IsEmpty() {
				if _bdfd := _efa.GetFormattedValue(); _bdfd != "" {
					_fcbe = append(_fcbe, CellText{Text: _bdfd, Cell: _efa})
				}
			}
		}
	}
	return &SheetText{Cells: _fcbe}
}

var _cfbf = false

const (
	SortOrderAscending SortOrder = iota
	SortOrderDescending
)

// AddSheet adds a new sheet to a workbook.
func (_edfdc *Workbook) AddSheet() Sheet {
	_acc := _fge.NewCT_Sheet()
	_acc.SheetIdAttr = 1
	for _, _gbge := range _edfdc._fefd.Sheets.Sheet {
		if _acc.SheetIdAttr <= _gbge.SheetIdAttr {
			_acc.SheetIdAttr = _gbge.SheetIdAttr + 1
		}
	}
	_edfdc._fefd.Sheets.Sheet = append(_edfdc._fefd.Sheets.Sheet, _acc)
	_acc.NameAttr = _c.Sprintf("\u0053\u0068\u0065\u0065\u0074\u0020\u0025\u0064", _acc.SheetIdAttr)
	_dafa := _fge.NewWorksheet()
	_dafa.Dimension = _fge.NewCT_SheetDimension()
	_dafa.Dimension.RefAttr = "\u0041\u0031"
	_edfdc._egabd = append(_edfdc._egabd, _dafa)
	_caace := _fa.NewRelationships()
	_edfdc._bbea = append(_edfdc._bbea, _caace)
	_dafa.SheetData = _fge.NewCT_SheetData()
	_edfdc._aacf = append(_edfdc._aacf, nil)
	_dggb := _f.DocTypeSpreadsheet
	_gbaa := _edfdc._cbag.AddAutoRelationship(_dggb, _f.OfficeDocumentType, len(_edfdc._fefd.Sheets.Sheet), _f.WorksheetType)
	_acc.IdAttr = _gbaa.ID()
	_edfdc.ContentTypes.AddOverride(_f.AbsoluteFilename(_dggb, _f.WorksheetContentType, len(_edfdc._fefd.Sheets.Sheet)), _f.WorksheetContentType)
	return Sheet{_edfdc, _acc, _dafa}
}

// MoveTo is a no-op.
func (_fgfb AbsoluteAnchor) MoveTo(x, y int32) {}

// SetWidth sets the width of the anchored object.
func (_fbc OneCellAnchor) SetWidth(w _ae.Distance) { _fbc._gfgaf.Ext.CxAttr = int64(w / _ae.EMU) }

// X returns the inner wrapped XML type.
func (_gfbe Comment) X() *_fge.CT_Comment { return _gfbe._gade }

// Uses1904Dates returns true if the the workbook uses dates relative to
// 1 Jan 1904. This is uncommon.
func (_gfee *Workbook) Uses1904Dates() bool {
	if _gfee._fefd.WorkbookPr == nil || _gfee._fefd.WorkbookPr.Date1904Attr == nil {
		return false
	}
	return *_gfee._fefd.WorkbookPr.Date1904Attr
}
func (_bbbf *Sheet) addNumberedRowFast(_cca uint32) Row {
	_bfb := _fge.NewCT_Row()
	_bfb.RAttr = _f.Uint32(_cca)
	_bbbf._defb.SheetData.Row = append(_bbbf._defb.SheetData.Row, _bfb)
	return Row{_bbbf._fgca, _bbbf, _bfb}
}

// AddImage adds an image with a paricular anchor type, returning an anchor to
// allow adusting the image size/position.
func (_cgff Drawing) AddImage(img _fa.ImageRef, at AnchorType) Anchor {
	_face := 0
	for _cdda, _bdb := range _cgff._dfbc.Images {
		if _bdb == img {
			_face = _cdda + 1
			break
		}
	}
	var _adgb string
	for _gfbc, _aead := range _cgff._dfbc._beed {
		if _aead == _cgff._caeb {
			_fea := _c.Sprintf("\u002e\u002e\u002f\u006ded\u0069\u0061\u002f\u0069\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", _face, img.Format())
			_baed := _cgff._dfbc._gfgab[_gfbc].AddRelationship(_fea, _f.ImageType)
			_adgb = _baed.ID()
			break
		}
	}
	var _fdabf Anchor
	var _ccbg *_fgf.CT_Picture
	switch at {
	case AnchorTypeAbsolute:
		_efe := _egeb()
		_cgff._caeb.EG_Anchor = append(_cgff._caeb.EG_Anchor, &_fgf.EG_Anchor{AnchorChoice: &_fgf.EG_AnchorChoice{AbsoluteAnchor: _efe}})
		_efe.ObjectChoicesChoice = &_fgf.EG_ObjectChoicesChoice{}
		_efe.ObjectChoicesChoice.Pic = _fgf.NewCT_Picture()
		_efe.Pos.XAttr.ST_CoordinateUnqualified = _f.Int64(0)
		_efe.Pos.YAttr.ST_CoordinateUnqualified = _f.Int64(0)
		_ccbg = _efe.ObjectChoicesChoice.Pic
		_fdabf = AbsoluteAnchor{_efe}
	case AnchorTypeOneCell:
		_fcb := _gdd()
		_cgff._caeb.EG_Anchor = append(_cgff._caeb.EG_Anchor, &_fgf.EG_Anchor{AnchorChoice: &_fgf.EG_AnchorChoice{OneCellAnchor: _fcb}})
		_fcb.ObjectChoicesChoice = &_fgf.EG_ObjectChoicesChoice{}
		_fcb.ObjectChoicesChoice.Pic = _fgf.NewCT_Picture()
		_ccbg = _fcb.ObjectChoicesChoice.Pic
		_fdabf = OneCellAnchor{_fcb}
	case AnchorTypeTwoCell:
		_dbga := _def()
		_cgff._caeb.EG_Anchor = append(_cgff._caeb.EG_Anchor, &_fgf.EG_Anchor{AnchorChoice: &_fgf.EG_AnchorChoice{TwoCellAnchor: _dbga}})
		_dbga.ObjectChoicesChoice = &_fgf.EG_ObjectChoicesChoice{}
		_dbga.ObjectChoicesChoice.Pic = _fgf.NewCT_Picture()
		_ccbg = _dbga.ObjectChoicesChoice.Pic
		_fdabf = TwoCellAnchor{_dbga}
	}
	_ccbg.NvPicPr.CNvPr.IdAttr = uint32(len(_cgff._caeb.EG_Anchor))
	_ccbg.NvPicPr.CNvPr.NameAttr = "\u0049\u006d\u0061g\u0065"
	_ccbg.BlipFill.Blip = _cg.NewCT_Blip()
	_ccbg.BlipFill.Blip.EmbedAttr = _f.String(_adgb)
	_ccbg.BlipFill.FillModePropertiesChoice.Stretch = _cg.NewCT_StretchInfoProperties()
	_ccbg.SpPr = _cg.NewCT_ShapeProperties()
	_ccbg.SpPr.Xfrm = _cg.NewCT_Transform2D()
	_ccbg.SpPr.Xfrm.Off = _cg.NewCT_Point2D()
	_ccbg.SpPr.Xfrm.Off.XAttr.ST_CoordinateUnqualified = _f.Int64(0)
	_ccbg.SpPr.Xfrm.Off.YAttr.ST_CoordinateUnqualified = _f.Int64(0)
	_ccbg.SpPr.Xfrm.Ext = _cg.NewCT_PositiveSize2D()
	_ccbg.SpPr.Xfrm.Ext.CxAttr = int64(float64(img.Size().X*_ae.Pixel72) / _ae.EMU)
	_ccbg.SpPr.Xfrm.Ext.CyAttr = int64(float64(img.Size().Y*_ae.Pixel72) / _ae.EMU)
	_ccbg.SpPr.GeometryChoice.PrstGeom = _cg.NewCT_PresetGeometry2D()
	_ccbg.SpPr.GeometryChoice.PrstGeom.PrstAttr = _cg.ST_ShapeTypeRect
	_ccbg.SpPr.Ln = _cg.NewCT_LineProperties()
	_ccbg.SpPr.Ln.LineFillPropertiesChoice.NoFill = _cg.NewCT_NoFillProperties()
	return _fdabf
}

// SetHeight sets the height of the anchored object.
func (_eag AbsoluteAnchor) SetHeight(h _ae.Distance) { _eag._fcc.Ext.CyAttr = int64(h / _ae.EMU) }

// HasFormula returns true if the cell contains formula.
func (_edad *evalContext) HasFormula(cellRef string) bool {
	return _edad._dgf.Cell(cellRef).HasFormula()
}

// AddDefinedName adds a name for a cell or range reference that can be used in
// formulas and charts.
func (_gebgc *Workbook) AddDefinedName(name, ref string) DefinedName {
	if _gebgc._fefd.DefinedNames == nil {
		_gebgc._fefd.DefinedNames = _fge.NewCT_DefinedNames()
	}
	_ebbac := _fge.NewCT_DefinedName()
	_ebbac.Content = ref
	_ebbac.NameAttr = name
	_gebgc._fefd.DefinedNames.DefinedName = append(_gebgc._fefd.DefinedNames.DefinedName, _ebbac)
	return DefinedName{_ebbac}
}

// SetPriority sets the rule priority
func (_fbd ConditionalFormattingRule) SetPriority(p int32) { _fbd._gcgc.PriorityAttr = p }

// SetFont applies a font to a cell style avoiding redundancy. The function checks if the given font
// already exists in the saved fonts. If found, the existing font is reused; otherwise,
// the new font is added to the saved fonts collection. The font is then applied to the cell style,
// affecting all styles that reference it by index.
func (_gbc CellStyle) SetFont(f Font) {
	_gbd := f._cfg.Fonts.Font
	for _, _aaa := range _gbd {
		if _bb.DeepEqual(_aaa, f._caed) {
			f._caed = _aaa
			_gbc._dece.FontIdAttr = _f.Uint32(f.Index())
			_gbc._dece.ApplyFontAttr = _f.Bool(true)
			return
		}
	}
	f._cfg.Fonts.Font = append(f._cfg.Fonts.Font, f._caed)
	f._cfg.Fonts.CountAttr = _f.Uint32(uint32(len(f._cfg.Fonts.Font)))
	_gbc._dece.FontIdAttr = _f.Uint32(f.Index())
	_gbc._dece.ApplyFontAttr = _f.Bool(true)
}

// SetReference sets the regin of cells that the merged cell applies to.
func (_fccb MergedCell) SetReference(ref string) { _fccb._dbac.RefAttr = ref }

// ClearFill clears any fill configuration from the cell style.
func (_bbb CellStyle) ClearFill() { _bbb._dece.FillIdAttr = nil; _bbb._dece.ApplyFillAttr = nil }

// BottomRight returns the CellMaker for the bottom right corner of the anchor.
func (_ffgg TwoCellAnchor) BottomRight() CellMarker { return CellMarker{_ffgg._efed.To} }

// Type returns the type of the rule
func (_gce ConditionalFormattingRule) Type() _fge.ST_CfType { return _gce._gcgc.TypeAttr }

// AddView adds a sheet view.
func (_fbbb *Sheet) AddView() SheetView {
	if _fbbb._defb.SheetViews == nil {
		_fbbb._defb.SheetViews = _fge.NewCT_SheetViews()
	}
	_dgbf := _fge.NewCT_SheetView()
	_fbbb._defb.SheetViews.SheetView = append(_fbbb._defb.SheetViews.SheetView, _dgbf)
	return SheetView{_dgbf}
}

// X returns the inner wrapped XML type.
func (_bbg Cell) X() *_fge.CT_Cell { return _bbg._dced }

// X returns the inner wrapped XML type.
func (_ebf RichTextRun) X() *_fge.CT_RElt { return _ebf._gbe }

// SaveToFile writes the workbook out to a file.
func (_daec *Workbook) SaveToFile(path string) error {
	_agff, _cgab := _abd.Create(path)
	if _cgab != nil {
		return _cgab
	}
	defer _agff.Close()
	return _daec.Save(_agff)
}

// X returns the inner wrapped XML type.
func (_abfa WorkbookProtection) X() *_fge.CT_WorkbookProtection { return _abfa._edcb }
func _gdg(_eedd _gd.Time) _gd.Time {
	_eedd = _eedd.Local()
	return _gd.Date(_eedd.Year(), _eedd.Month(), _eedd.Day(), _eedd.Hour(), _eedd.Minute(), _eedd.Second(), _eedd.Nanosecond(), _gd.UTC)
}

// X returns the inner wrapped XML type.
func (_deb RichText) X() *_fge.CT_Rst              { return _deb._faae }
func (_ccdfc PatternFill) X() *_fge.CT_PatternFill { return _ccdfc._acgb }
func _bbfe(_fdge *Sheet) *evalContext {
	return &evalContext{_dgf: _fdge, _gdgf: make(map[string]struct{})}
}

// RecalculateFormulas re-computes any computed formula values that are stored
// in the sheet. As unioffice formula support is still new and not all functins are
// supported,  if formula execution fails either due to a parse error or missing
// function, or erorr in the result (even if expected) the cached value will be
// left empty allowing Excel to recompute it on load.
func (_gagff *Sheet) RecalculateFormulas() {
	_gbda := _bac.NewEvaluator()
	_bfce := _gagff.FormulaContext()
	for _, _bebac := range _gagff.Rows() {
		for _, _fcd := range _bebac.Cells() {
			if _fcd.X().F != nil {
				_ddaa := _fcd.X().F.Content
				if _fcd.X().F.TAttr == _fge.ST_CellFormulaTypeShared && len(_ddaa) == 0 {
					continue
				}
				_aaeg := _gbda.Eval(_bfce, _ddaa).AsString()
				if _aaeg.Type == _bac.ResultTypeError {
					_cf.Log.Debug("\u0065\u0072\u0072o\u0072\u0020\u0065\u0076a\u0075\u006c\u0061\u0074\u0069\u006e\u0067 \u0066\u006f\u0072\u006d\u0075\u006c\u0061\u0020\u0025\u0073\u003a\u0020\u0025\u0073", _ddaa, _aaeg.ErrorMessage)
					_fcd.X().V = nil
				} else {
					if _aaeg.Type == _bac.ResultTypeNumber {
						_fcd.X().TAttr = _fge.ST_CellTypeN
					} else {
						_fcd.X().TAttr = _fge.ST_CellTypeInlineStr
					}
					_fcd.X().V = _f.String(_aaeg.Value())
					if _fcd.X().F.TAttr == _fge.ST_CellFormulaTypeArray {
						if _aaeg.Type == _bac.ResultTypeArray {
							_gagff.setArray(_fcd.Reference(), _aaeg)
						} else if _aaeg.Type == _bac.ResultTypeList {
							_gagff.setList(_fcd.Reference(), _aaeg)
						}
					} else if _fcd.X().F.TAttr == _fge.ST_CellFormulaTypeShared && _fcd.X().F.RefAttr != nil {
						_debf, _ddac, _bccd := _gb.ParseRangeReference(*_fcd.X().F.RefAttr)
						if _bccd != nil {
							_cf.Log.Debug("\u0065\u0072r\u006f\u0072\u0020\u0069n\u0020\u0073h\u0061\u0072\u0065\u0064\u0020\u0066\u006f\u0072m\u0075\u006c\u0061\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063e\u003a\u0020\u0025\u0073", _bccd)
							continue
						}
						_gagff.setShared(_fcd.Reference(), _debf, _ddac, _ddaa)
					}
				}
			}
		}
	}
}

// SetNumberWithStyle sets a number and applies a standard format to the cell.
func (_ddd Cell) SetNumberWithStyle(v float64, f StandardFormat) {
	_ddd.SetNumber(v)
	_ddd.SetStyle(_ddd._ef.StyleSheet.GetOrCreateStandardNumberFormat(f))
}

// SetError sets the cell type to error and the value to the given error message.
func (_dead Cell) SetError(msg string) {
	_dead.clearValue()
	_dead._dced.V = _f.String(msg)
	_dead._dced.TAttr = _fge.ST_CellTypeE
}

// X returns the inner wrapped XML type.
func (_fgb Font) X() *_fge.CT_Font { return _fgb._caed }
func (_cac *Sheet) getAllCellsInFormulaArraysForColumn() (map[string]bool, error) {
	return _cac.getAllCellsInFormulaArrays(false)
}

// AddRow adds a new row to a sheet.  You can mix this with numbered rows,
// however it will get confusing. You should prefer to use either automatically
// numbered rows with AddRow or manually numbered rows with Row/AddNumberedRow
func (_cabfb *Sheet) AddRow() Row {
	_bgad := uint32(0)
	_bbdg := uint32(len(_cabfb._defb.SheetData.Row))
	if _bbdg > 0 && _cabfb._defb.SheetData.Row[_bbdg-1].RAttr != nil && *_cabfb._defb.SheetData.Row[_bbdg-1].RAttr == _bbdg {
		return _cabfb.addNumberedRowFast(_bbdg + 1)
	}
	for _, _eadd := range _cabfb._defb.SheetData.Row {
		if _eadd.RAttr != nil && *_eadd.RAttr > _bgad {
			_bgad = *_eadd.RAttr
		}
	}
	return _cabfb.AddNumberedRow(_bgad + 1)
}
func (_beddd SheetView) ensurePane() {
	if _beddd._gfdfg.Pane == nil {
		_beddd._gfdfg.Pane = _fge.NewCT_Pane()
		_beddd._gfdfg.Pane.ActivePaneAttr = _fge.ST_PaneBottomLeft
	}
}

// Themes returns the array of workbook dml.Theme.
func (_ebeg *Workbook) Themes() []*_cg.Theme { return _ebeg._edgb }

// SetZoom controls the zoom level of the sheet and is measured in percent. The
// default value is 100.
func (_ecfg SheetView) SetZoom(pct uint32) { _ecfg._gfdfg.ZoomScaleAttr = &pct }

// Fonts returns the list of fonts defined in the stylesheet.
func (_aecf StyleSheet) Fonts() []Font {
	_fcgg := []Font{}
	for _, _ddga := range _aecf._ccde.Fonts.Font {
		_fcgg = append(_fcgg, Font{_ddga, _aecf._ccde})
	}
	return _fcgg
}

var _ecfb []string = []string{"\u007a\u0068\u002dH\u004b", "\u007a\u0068\u002dM\u004f", "\u007a\u0068\u002dC\u004e", "\u007a\u0068\u002dS\u0047", "\u007a\u0068\u002dT\u0057", "\u006a\u0061\u002dJ\u0050", "\u006b\u006f\u002dK\u0052"}

func (_gaaf *evalContext) NamedRange(ref string) _bac.Reference {
	for _, _gfef := range _gaaf._dgf._fgca.DefinedNames() {
		if _gfef.Name() == ref {
			return _bac.MakeRangeReference(_gfef.Content())
		}
	}
	for _, _cfc := range _gaaf._dgf._fgca.Tables() {
		if _cfc.Name() == ref {
			return _bac.MakeRangeReference(_c.Sprintf("\u0025\u0073\u0021%\u0073", _gaaf._dgf.Name(), _cfc.Reference()))
		}
	}
	return _bac.ReferenceInvalid
}

type SheetProtection struct{ _bbaf *_fge.CT_SheetProtection }

// CellMarker represents a cell position
type CellMarker struct{ _fdd *_fgf.CT_Marker }

func (_dda ConditionalFormattingRule) clear() {
	_dda._gcgc.OperatorAttr = _fge.ST_ConditionalFormattingOperatorUnset
	_dda._gcgc.ColorScale = nil
	_dda._gcgc.IconSet = nil
	_dda._gcgc.Formula = nil
}

// SetWidthCells is a no-op.
func (_cga AbsoluteAnchor) SetWidthCells(int32) {}

// InitializeDefaults initializes a border to its defaulte empty values.
func (_ffa Border) InitializeDefaults() {
	_ffa._ed.Left = _fge.NewCT_BorderPr()
	_ffa._ed.Bottom = _fge.NewCT_BorderPr()
	_ffa._ed.Right = _fge.NewCT_BorderPr()
	_ffa._ed.Top = _fge.NewCT_BorderPr()
	_ffa._ed.Diagonal = _fge.NewCT_BorderPr()
}

// SetValue sets the first value to be used in the comparison.  For comparisons
// that need only one value, this is the only value used.  For comparisons like
// 'between' that require two values, SetValue2 must also be used.
func (_bcg DataValidationCompare) SetValue(v string) { _bcg._ccb.Formula1 = &v }

// Index returns the index of the differential style.
func (_afde DifferentialStyle) Index() uint32 {
	for _aec, _ceagf := range _afde._eefe.Dxf {
		if _afde._ceag == _ceagf {
			return uint32(_aec)
		}
	}
	return 0
}

// BottomRight is a no-op.
func (_de AbsoluteAnchor) BottomRight() CellMarker { return CellMarker{} }

// SetRow set the row of the cell marker.
func (_gde CellMarker) SetRow(row int32) { _gde._fdd.Row = row }

// X returns the inner wrapped XML type.
func (_gfe ConditionalFormattingRule) X() *_fge.CT_CfRule { return _gfe._gcgc }
func (_ggcb StyleSheet) GetNumberFormat(id uint32) NumberFormat {
	if id >= 0 && id < 50 {
		return CreateDefaultNumberFormat(StandardFormat(id))
	}
	for _, _edag := range _ggcb._ccde.NumFmts.NumFmt {
		if _edag.NumFmtIdAttr == id {
			return NumberFormat{_ggcb._eafa, _edag}
		}
	}
	return NumberFormat{}
}

// CopySheetByName copies the existing sheet with the name `name` and puts its copy with the name `copiedSheetName`.
func (_cedef *Workbook) CopySheetByName(name, copiedSheetName string) (Sheet, error) {
	_beff := -1
	for _aeafd, _eebc := range _cedef.Sheets() {
		if name == _eebc.Name() {
			_beff = _aeafd
			break
		}
	}
	if _beff == -1 {
		return Sheet{}, ErrorNotFound
	}
	return _cedef.CopySheet(_beff, copiedSheetName)
}

// SetWidth controls the width of a column.
func (_acd Column) SetWidth(w _ae.Distance) {
	_acd._bgba.WidthAttr = _f.Float64(float64(w / _ae.Character))
}

// RichTextRun is a segment of text within a cell that is directly formatted.
type RichTextRun struct{ _gbe *_fge.CT_RElt }

// Reference returns the region of cells that are merged.
func (_cabf MergedCell) Reference() string { return _cabf._dbac.RefAttr }

// AddBorder creates a new empty Border style.
func (_ddfe StyleSheet) AddBorder() Border {
	_cagg := _fge.NewCT_Border()
	return Border{_cagg, _ddfe._ccde.Borders}
}

// OneCellAnchor is anchored to a top-left cell with a fixed with/height
// in distance.
type OneCellAnchor struct{ _gfgaf *_fgf.CT_OneCellAnchor }

// ExtractText returns text from the workbook as a WorkbookText object.
func (_deca *Workbook) ExtractText() *WorkbookText {
	_ecca := []*SheetText{}
	for _, _bfd := range _deca.Sheets() {
		_ecca = append(_ecca, &SheetText{Cells: _bfd.ExtractText().Cells})
	}
	return &WorkbookText{Sheets: _ecca}
}

// AddComment adds a new comment and returns a RichText which will contain the
// styled comment text.
func (_gbac Comments) AddComment(cellRef string, author string) RichText {
	_cgdf := _fge.NewCT_Comment()
	_gbac._dfef.CommentList.Comment = append(_gbac._dfef.CommentList.Comment, _cgdf)
	_cgdf.RefAttr = cellRef
	_cgdf.AuthorIdAttr = _gbac.getOrCreateAuthor(author)
	_cgdf.Text = _fge.NewCT_Rst()
	return RichText{_cgdf.Text}
}

// SetActiveSheetIndex sets the index of the active sheet (0-n) which will be
// the tab displayed when the spreadsheet is initially opened.
func (_ebbgc *Workbook) SetActiveSheetIndex(idx uint32) {
	if _ebbgc._fefd.BookViews == nil {
		_ebbgc._fefd.BookViews = _fge.NewCT_BookViews()
	}
	if len(_ebbgc._fefd.BookViews.WorkbookView) == 0 {
		_ebbgc._fefd.BookViews.WorkbookView = append(_ebbgc._fefd.BookViews.WorkbookView, _fge.NewCT_BookView())
	}
	_ebbgc._fefd.BookViews.WorkbookView[0].ActiveTabAttr = _f.Uint32(idx)
}
func _egeb() *_fgf.CT_AbsoluteAnchor { _fddgd := _fgf.NewCT_AbsoluteAnchor(); return _fddgd }

// SetWrapped configures the cell to wrap text.
func (_bfc CellStyle) SetWrapped(b bool) {
	if _bfc._dece.Alignment == nil {
		_bfc._dece.Alignment = _fge.NewCT_CellAlignment()
	}
	if !b {
		_bfc._dece.Alignment.WrapTextAttr = nil
	} else {
		_bfc._dece.Alignment.WrapTextAttr = _f.Bool(true)
		_bfc._dece.ApplyAlignmentAttr = _f.Bool(true)
	}
}
func (_cad Cell) getRawSortValue() (string, bool) {
	if _cad.HasFormula() {
		_bde := _cad.GetCachedFormulaResult()
		return _bde, _fff.IsNumber(_bde)
	}
	_caa, _ := _cad.GetRawValue()
	return _caa, _fff.IsNumber(_caa)
}

// Comparer is used to compare rows based off a column and cells based off of
// their value.
type Comparer struct{ Order SortOrder }

// SetXSplit sets the column split point
func (_dcda SheetView) SetXSplit(v float64) {
	_dcda.ensurePane()
	_dcda._gfdfg.Pane.XSplitAttr = _f.Float64(v)
}
func (_bcbc PatternFill) ClearBgColor() { _bcbc._acgb.BgColor = nil }

// AnchorType is the type of anchor.
type AnchorType byte

const _ecff = "_\u0078\u006c\u006e\u006d._\u0046i\u006c\u0074\u0065\u0072\u0044a\u0074\u0061\u0062\u0061\u0073\u0065"

// SetNumber sets the cell type to number, and the value to the given number
func (_fga Cell) SetNumber(v float64) {
	_fga.clearValue()
	if _gdf.IsNaN(v) || _gdf.IsInf(v, 0) {
		_fga._dced.TAttr = _fge.ST_CellTypeE
		_fga._dced.V = _f.String("\u0023\u004e\u0055M\u0021")
		return
	}
	_fga._dced.TAttr = _fge.ST_CellTypeN
	_fga._dced.V = _f.String(_fg.FormatFloat(v, 'f', -1, 64))
}

// GetEpoch returns a workbook's time epoch.
func (_fadde *evalContext) GetEpoch() _gd.Time { return _fadde._dgf._fgca.Epoch() }

// SetFrozen removes any existing sheet views and creates a new single view with
// either the first row, first column or both frozen.
func (_dcfc *Sheet) SetFrozen(firstRow, firstCol bool) {
	_dcfc._defb.SheetViews = nil
	_febc := _dcfc.AddView()
	_febc.SetState(_fge.ST_PaneStateFrozen)
	switch {
	case firstRow && firstCol:
		_febc.SetYSplit(1)
		_febc.SetXSplit(1)
		_febc.SetTopLeft("\u0042\u0032")
	case firstRow:
		_febc.SetYSplit(1)
		_febc.SetTopLeft("\u0041\u0032")
	case firstCol:
		_febc.SetXSplit(1)
		_febc.SetTopLeft("\u0042\u0031")
	}
}

// ClearCachedFormulaResults clears any computed formula values that are stored
// in the sheet. This may be required if you modify cells that are used as a
// formula input to force the formulas to be recomputed the next time the sheet
// is opened in Excel.
func (_gedd *Workbook) ClearCachedFormulaResults() {
	for _, _acde := range _gedd.Sheets() {
		_acde.ClearCachedFormulaResults()
	}
}
func (_gdc Border) SetBottom(style _fge.ST_BorderStyle, c _cea.Color) {
	if _gdc._ed.Bottom == nil {
		_gdc._ed.Bottom = _fge.NewCT_BorderPr()
	}
	_gdc._ed.Bottom.Color = _fge.NewCT_Color()
	_gdc._ed.Bottom.Color.RgbAttr = c.AsRGBAString()
	_gdc._ed.Bottom.StyleAttr = style
}
func (_cgfg StandardFormat) String() string {
	switch {
	case 0 <= _cgfg && _cgfg <= 4:
		return _cdfa[_dade[_cgfg]:_dade[_cgfg+1]]
	case 9 <= _cgfg && _cgfg <= 22:
		_cgfg -= 9
		return _ace[_adef[_cgfg]:_adef[_cgfg+1]]
	case 37 <= _cgfg && _cgfg <= 40:
		_cgfg -= 37
		return _fgaf[_cbgd[_cgfg]:_cbgd[_cgfg+1]]
	case 45 <= _cgfg && _cgfg <= 49:
		_cgfg -= 45
		return _cdcf[_dcdg[_cgfg]:_dcdg[_cgfg+1]]
	default:
		return _c.Sprintf("\u0053t\u0061n\u0064\u0061\u0072\u0064\u0046o\u0072\u006da\u0074\u0028\u0025\u0064\u0029", _cgfg)
	}
}

// IsHidden returns whether the row is hidden or not.
func (_beba Row) IsHidden() bool { return _beba._feg.HiddenAttr != nil && *_beba._feg.HiddenAttr }
func (_cbe Font) SetColor(c _cea.Color) {
	_gcaa := _fge.NewCT_Color()
	_acg := "\u0066\u0066" + *c.AsRGBString()
	_gcaa.RgbAttr = &_acg
	_adf := false
	for _cffd, _agfb := range _cbe._caed.FontChoice {
		if _agfb.Color != nil {
			_cbe._caed.FontChoice[_cffd].Color = _gcaa
			_adf = true
		}
	}
	if !_adf {
		_cbe._caed.FontChoice = append(_cbe._caed.FontChoice, &_fge.CT_FontChoice{Color: _gcaa})
	}
}

// NumberFormat returns the number format that the cell style uses, or zero if
// it is not set.
func (_aeec CellStyle) NumberFormat() uint32 {
	if _aeec._dece.NumFmtIdAttr == nil {
		return 0
	}
	return *_aeec._dece.NumFmtIdAttr
}

// SetInlineString adds a string inline instead of in the shared strings table.
func (_bba Cell) SetInlineString(s string) {
	_bba.clearValue()
	_bba._dced.Is = _fge.NewCT_Rst()
	_bba._dced.Is.T = _f.String(s)
	_bba._dced.TAttr = _fge.ST_CellTypeInlineStr
}

// SetPassword sets the password hash to a hash of the input password.
func (_fcebe SheetProtection) SetPassword(pw string) { _fcebe.SetPasswordHash(PasswordHash(pw)) }

// Reference returns the table reference (the cells within the table)
func (_gabe Table) Reference() string { return _gabe._ecgbf.RefAttr }

// X returns the inner wrapped XML type.
func (_bbdd DifferentialStyle) X() *_fge.CT_Dxf { return _bbdd._ceag }

// ColorScale colors a cell background based off of the cell value.
type ColorScale struct{ _ceea *_fge.CT_ColorScale }

// IsSheetLocked returns whether the sheet is locked.
func (_gfdd SheetProtection) IsSheetLocked() bool {
	return _gfdd._bbaf.SheetAttr != nil && *_gfdd._bbaf.SheetAttr
}
func (_fbdd DataValidation) SetList() DataValidationList {
	_fbdd.clear()
	_fbdd._ebga.TypeAttr = _fge.ST_DataValidationTypeList
	_fbdd._ebga.OperatorAttr = _fge.ST_DataValidationOperatorEqual
	return DataValidationList{_fbdd._ebga}
}

// Cell creates or returns a cell given a cell reference of the form 'A10'
func (_bebaa *Sheet) Cell(cellRef string) Cell {
	_bcd, _fdgd := _gb.ParseCellReference(cellRef)
	if _fdgd != nil {
		_cf.Log.Debug("\u0065\u0072\u0072\u006f\u0072\u0020\u0070\u0061\u0072\u0073\u0069\u006e\u0067\u0020\u0063e\u006cl\u0020\u0072\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065\u003a\u0020\u0025\u0073", _fdgd)
		return _bebaa.AddRow().AddCell()
	}
	return _bebaa.Row(_bcd.RowIdx).Cell(_bcd.Column)
}

// SetPassword sets the password hash to a hash of the input password.
func (_ddce WorkbookProtection) SetPassword(pw string) { _ddce.SetPasswordHash(PasswordHash(pw)) }

type MergedCell struct {
	_aefc *Workbook
	_edfd *Sheet
	_dbac *_fge.CT_MergeCell
}

const (
	_cdfa = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061tGe\u006e\u0065\u0072\u0061\u006cS\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0057\u0068\u006f\u006ce\u004e\u0075\u006d\u0062\u0065\u0072\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0032\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0034"
	_ace  = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074P\u0065\u0072\u0063\u0065\u006e\u0074\u0053\u0074\u0061nd\u0061r\u0064F\u006fr\u006d\u0061\u0074\u0031\u0030\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0031\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064F\u006f\u0072\u006d\u0061\u0074\u0031\u0032\u0053\u0074a\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0033\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061\u0074\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046o\u0072\u006d\u0061\u0074\u00315\u0053\u0074\u0061\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0037S\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0031\u0038\u0053\u0074\u0061n\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0054\u0069\u006d\u0065\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00320\u0053\u0074a\u006e\u0064a\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0032\u0031\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0044\u0061t\u0065\u0054\u0069\u006d\u0065"
	_fgaf = "\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0033\u0037\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006da\u0074\u0033\u0038\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u00339\u0053\u0074\u0061\u006e\u0064\u0061r\u0064\u0046o\u0072\u006da\u00744\u0030"
	_cdcf = "\u0053t\u0061\u006e\u0064a\u0072\u0064\u0046o\u0072ma\u0074\u0034\u0035\u0053\u0074\u0061\u006ed\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0036\u0053\u0074\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061\u0074\u0034\u0037\u0053ta\u006ed\u0061\u0072\u0064\u0046\u006f\u0072m\u0061\u0074\u0034\u0038\u0053t\u0061\u006e\u0064\u0061\u0072\u0064\u0046\u006f\u0072\u006d\u0061t\u0034\u0039"
)

func _gdd() *_fgf.CT_OneCellAnchor { _bcfcf := _fgf.NewCT_OneCellAnchor(); return _bcfcf }

// Text returns text from the sheet as one string separated with line breaks.
func (_ade *SheetText) Text() string {
	_dfda := _fc.NewBuffer([]byte{})
	for _, _cbg := range _ade.Cells {
		if _cbg.Text != "" {
			_dfda.WriteString(_cbg.Text)
			_dfda.WriteString("\u000a")
		}
	}
	return _dfda.String()
}

// SetFormat sets the number format code.
func (_aaed NumberFormat) SetFormat(f string) { _aaed._gage.FormatCodeAttr = f }

// SetContent sets the defined name content.
func (_cabd DefinedName) SetContent(s string) { _cabd._cgaa.Content = s }

// SetShowValue controls if the cell value is displayed.
func (_dbgc DataBarScale) SetShowValue(b bool) { _dbgc._dcec.ShowValueAttr = _f.Bool(b) }

// SetColOffset sets the column offset of the two cell anchor.
func (_eacg TwoCellAnchor) SetColOffset(m _ae.Distance) {
	_afffb := m - _eacg.TopLeft().ColOffset()
	_eacg.TopLeft().SetColOffset(m)
	_eacg.BottomRight().SetColOffset(_eacg.BottomRight().ColOffset() + _afffb)
}

// SetColor sets the text color.
func (_edcg RichTextRun) SetColor(c _cea.Color) {
	_edcg.ensureRpr()
	_cbaa := "\u0066\u0066" + *c.AsRGBString()
	for _, _geeg := range _edcg._gbe.RPr.RPrEltChoice {
		if _geeg.Color != nil {
			_geeg.Color.RgbAttr = &_cbaa
			return
		}
	}
	_edcg._gbe.RPr.RPrEltChoice = append(_edcg._gbe.RPr.RPrEltChoice, &_fge.CT_RPrEltChoice{Color: &_fge.CT_Color{RgbAttr: &_cbaa}})
}

// SetPasswordHash sets the password hash to the input.
func (_ccfa WorkbookProtection) SetPasswordHash(pwHash string) {
	_ccfa._edcb.WorkbookPasswordAttr = _f.String(pwHash)
}
func (_cgcb Font) Index() uint32 {
	for _fbbg, _dbfg := range _cgcb._cfg.Fonts.Font {
		if _cgcb._caed == _dbfg {
			return uint32(_fbbg)
		}
	}
	return 0
}

// SetValues sets the possible values. This is incompatible with SetRange.
func (_ecdfee DataValidationList) SetValues(values []string) {
	_ecdfee._cddg.Formula1 = _f.String("\u0022" + _d.Join(values, "\u002c") + "\u0022")
	_ecdfee._cddg.Formula2 = _f.String("\u0030")
}

// AddString adds a string to the shared string cache.
func (_caad SharedStrings) AddString(v string) int {
	if _agfe, _dgcb := _caad._cbdf[v]; _dgcb {
		return _agfe
	}
	_debe := _fge.NewCT_Rst()
	_debe.T = _f.String(v)
	_caad._ebge.Si = append(_caad._ebge.Si, _debe)
	_gadga := len(_caad._ebge.Si) - 1
	_caad._cbdf[v] = _gadga
	_caad._ebge.CountAttr = _f.Uint32(uint32(len(_caad._ebge.Si)))
	_caad._ebge.UniqueCountAttr = _caad._ebge.CountAttr
	return _gadga
}

// Font allows editing fonts within a spreadsheet stylesheet.
type Font struct {
	_caed *_fge.CT_Font
	_cfg  *_fge.StyleSheet
}

// RemoveSheet removes the sheet with the given index from the workbook.
func (_dbfe *Workbook) RemoveSheet(ind int) error {
	if _dbfe.SheetCount() <= ind {
		return ErrorNotFound
	}
	for _, _becf := range _dbfe._cbag.Relationships() {
		if _becf.ID() == _dbfe._fefd.Sheets.Sheet[ind].IdAttr {
			_dbfe._cbag.Remove(_becf)
			break
		}
	}
	_dbfe.ContentTypes.RemoveOverride(_f.AbsoluteFilename(_f.DocTypeSpreadsheet, _f.WorksheetContentType, ind+1))
	copy(_dbfe._egabd[ind:], _dbfe._egabd[ind+1:])
	_dbfe._egabd = _dbfe._egabd[:len(_dbfe._egabd)-1]
	_deeaa := _dbfe._fefd.Sheets.Sheet[ind]
	copy(_dbfe._fefd.Sheets.Sheet[ind:], _dbfe._fefd.Sheets.Sheet[ind+1:])
	_dbfe._fefd.Sheets.Sheet = _dbfe._fefd.Sheets.Sheet[:len(_dbfe._fefd.Sheets.Sheet)-1]
	for _addab := range _dbfe._fefd.Sheets.Sheet {
		if _dbfe._fefd.Sheets.Sheet[_addab].SheetIdAttr > _deeaa.SheetIdAttr {
			_dbfe._fefd.Sheets.Sheet[_addab].SheetIdAttr--
		}
	}
	copy(_dbfe._bbea[ind:], _dbfe._bbea[ind+1:])
	_dbfe._bbea = _dbfe._bbea[:len(_dbfe._bbea)-1]
	copy(_dbfe._aacf[ind:], _dbfe._aacf[ind+1:])
	_dbfe._aacf = _dbfe._aacf[:len(_dbfe._aacf)-1]
	return nil
}

// DataValidation controls cell validation
type DataValidation struct{ _ebga *_fge.CT_DataValidation }

func (_geba Cell) setLocked(_cdf bool) {
	_gebb := _geba._dced.SAttr
	if _gebb != nil {
		_ecdc := _geba._ef.StyleSheet.GetCellStyle(*_gebb)
		if _ecdc._dece.Protection == nil {
			_ecdc._dece.Protection = _fge.NewCT_CellProtection()
		}
		_ecdc._dece.Protection.LockedAttr = &_cdf
	}
}

// MergedCells returns the merged cell regions within the sheet.
func (_gcge *Sheet) MergedCells() []MergedCell {
	if _gcge._defb.MergeCells == nil {
		return nil
	}
	_cgedb := []MergedCell{}
	for _, _agggb := range _gcge._defb.MergeCells.MergeCell {
		_cgedb = append(_cgedb, MergedCell{_gcge._fgca, _gcge, _agggb})
	}
	return _cgedb
}
func NewFills() Fills { return Fills{_fge.NewCT_Fills()} }

// IsBool returns true if the cell is a boolean type cell.
func (_bee Cell) IsBool() bool        { return _bee._dced.TAttr == _fge.ST_CellTypeB }
func (_ffcg Fills) X() *_fge.CT_Fills { return _ffcg._dbgaf }

// SetHidden hides or unhides the row
func (_eddd Row) SetHidden(hidden bool) {
	if !hidden {
		_eddd._feg.HiddenAttr = nil
	} else {
		_eddd._feg.HiddenAttr = _f.Bool(true)
	}
}

// SetIcons sets the icon set to use for display.
func (_dad IconScale) SetIcons(t _fge.ST_IconSetType) { _dad._gbffb.IconSetAttr = t }

// SetDateWithStyle sets a date with the default date style applied.
func (_bcce Cell) SetDateWithStyle(d _gd.Time) {
	_bcce.SetDate(d)
	for _, _dff := range _bcce._ef.StyleSheet.CellStyles() {
		if _dff.HasNumberFormat() && _dff.NumberFormat() == uint32(StandardFormatDate) {
			_bcce.SetStyle(_dff)
			return
		}
	}
	_fcg := _bcce._ef.StyleSheet.AddCellStyle()
	_fcg.SetNumberFormatStandard(StandardFormatDate)
	_bcce.SetStyle(_fcg)
}

// SetVerticalAlignment sets the vertical alignment of a cell style.
func (_daf CellStyle) SetVerticalAlignment(a _fge.ST_VerticalAlignment) {
	if _daf._dece.Alignment == nil {
		_daf._dece.Alignment = _fge.NewCT_CellAlignment()
	}
	_daf._dece.ApplyAlignmentAttr = _f.Bool(true)
	_daf._dece.Alignment.VerticalAttr = a
}

// SetColOffset sets a column offset in absolute distance.
func (_dcb CellMarker) SetColOffset(m _ae.Distance) {
	_dcb._fdd.ColOff.ST_CoordinateUnqualified = _f.Int64(int64(m / _ae.EMU))
}
func (_gbf ConditionalFormattingRule) InitializeDefaults() {
	_gbf.SetType(_fge.ST_CfTypeCellIs)
	_gbf.SetOperator(_fge.ST_ConditionalFormattingOperatorGreaterThan)
	_gbf.SetPriority(1)
}
