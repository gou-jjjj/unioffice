//
// Copyright 2020 FoxyUtils ehf. All rights reserved.
//
// This is a commercial product and requires a license to operate.
// A trial license can be obtained at https://unidoc.io
//
// DO NOT EDIT: generated by unitwist Go source code obfuscator.
//
// Use of this source code is governed by the UniDoc End User License Agreement
// terms that can be accessed at https://unidoc.io/eula/

/*
Package document provides creation, reading, and writing of ECMA 376 Open
Office XML documents.

Example:

	doc := document.New()
	para := doc.AddParagraph()
	run := para.AddRun()
	run.SetText("foo")
	doc.SaveToFile("foo.docx")
*/
package document

import (
	_fa "archive/zip"
	_ag "bytes"
	_d "encoding/xml"
	_bea "errors"
	_dd "fmt"
	_bfa "image"
	_c "image/jpeg"
	_ga "io"
	_gc "math/rand"
	_ea "os"
	_f "path/filepath"
	_be "regexp"
	_b "strconv"
	_ac "strings"
	_bf "time"
	_a "unicode"
	_e "unioffice"
	_bg "unioffice/color"
	_ee "unioffice/common"
	_cd "unioffice/common/axcontrol"
	_gd "unioffice/common/logger"
	_af "unioffice/common/tempstorage"
	_ec "unioffice/internal/formatutils"
	_de "unioffice/internal/license"
	_cdg "unioffice/measurement"
	_da "unioffice/schema/schemas.microsoft.com/office/activeX"
	_ad "unioffice/schema/soo/dml"
	_bd "unioffice/schema/soo/dml/chart"
	_gg "unioffice/schema/soo/dml/picture"
	_fae "unioffice/schema/soo/ofc/sharedTypes"
	_eab "unioffice/schema/soo/pkg/relationships"
	_deg "unioffice/schema/soo/wml"
	_dc "unioffice/schema/urn/schemas_microsoft_com/vml"
	_bgg "unioffice/vmldrawing"
	_db "unioffice/zippkg"
)

// AddWatermarkText adds new watermark text to the document.
func (_fdg *Document) AddWatermarkText(text string) WatermarkText {
	var _bfga []Header
	if _ddab, _dgff := _fdg.BodySection().GetHeader(_deg.ST_HdrFtrDefault); _dgff {
		_bfga = append(_bfga, _ddab)
	}
	if _cgbg, _fec := _fdg.BodySection().GetHeader(_deg.ST_HdrFtrEven); _fec {
		_bfga = append(_bfga, _cgbg)
	}
	if _aagfe, _aba := _fdg.BodySection().GetHeader(_deg.ST_HdrFtrFirst); _aba {
		_bfga = append(_bfga, _aagfe)
	}
	if len(_bfga) < 1 {
		_edad := _fdg.AddHeader()
		_fdg.BodySection().SetHeader(_edad, _deg.ST_HdrFtrDefault)
		_bfga = append(_bfga, _edad)
	}
	_cecfc := NewWatermarkText()
	for _, _cgfa := range _bfga {
		_fdca := _cgfa.Paragraphs()
		if len(_fdca) < 1 {
			_bcaa := _cgfa.AddParagraph()
			_bcaa.AddRun().AddText("")
		}
		for _, _faa := range _cgfa.X().EG_BlockLevelElts {
			for _, _cceb := range _faa.BlockLevelEltsChoice.EG_ContentBlockContent {
				for _, _dabc := range _cceb.ContentBlockContentChoice.P {
					for _, _ffdd := range _dabc.EG_PContent {
						for _, _aada := range _ffdd.PContentChoice.EG_ContentRunContent {
							if _aada.ContentRunContentChoice.R == nil {
								continue
							}
							_aada.ContentRunContentChoice.R.EG_RunInnerContent = append(_aada.ContentRunContentChoice.R.EG_RunInnerContent, &_deg.EG_RunInnerContent{RunInnerContentChoice: &_deg.EG_RunInnerContentChoice{Pict: _cecfc._deegd}})
						}
					}
				}
			}
		}
	}
	_cecfc.SetText(text)
	return _cecfc
}

// Fonts returns the style's Fonts.
func (_ffcd RunProperties) Fonts() Fonts {
	if _ffcd._bfed.RFonts == nil {
		_ffcd._bfed.RFonts = _deg.NewCT_Fonts()
	}
	return Fonts{_ffcd._bfed.RFonts}
}

// Caps returns true if run font is capitalized.
func (_ggeea RunProperties) Caps() bool { return _dabbe(_ggeea._bfed.Caps) }

// TOCOptions specify options for table of contents customization.
type TOCOptions struct {

	// UseHyperlinks makes the table of contents entries hyperlinks.
	UseHyperlinks bool

	// OmitPageNumbers allows omitting page numbers from the table of contents.
	OmitPageNumbers bool

	// HeadingLevel uses paragraphs formatted with all of the specified range of built-in heading styles.
	// "3-3" is to show only third heading level, for instance.
	HeadingLevel string
}

// Name returns the name of the bookmark whcih is the document unique ID that
// identifies the bookmark.
func (_fbgb Bookmark) Name() string { return _fbgb._ggfb.NameAttr }
func (_aedd *Document) insertNumberingFromStyleProperties(_eabg Numbering, _agdgf ParagraphStyleProperties) {
	_fgcgc := _agdgf.NumId()
	_fegb := int64(-1)
	if _fgcgc > -1 {
		for _, _fbdg := range _eabg._gcfa.Num {
			if _fbdg.NumIdAttr == _fgcgc {
				if _fbdg.AbstractNumId != nil {
					_fegb = _fbdg.AbstractNumId.ValAttr
					_ecbad := false
					for _, _cegeb := range _aedd.Numbering._gcfa.Num {
						if _cegeb.NumIdAttr == _fgcgc {
							_ecbad = true
							break
						}
					}
					if !_ecbad {
						_aedd.Numbering._gcfa.Num = append(_aedd.Numbering._gcfa.Num, _fbdg)
					}
					break
				}
			}
		}
		for _, _ccfde := range _eabg._gcfa.AbstractNum {
			if _ccfde.AbstractNumIdAttr == _fegb {
				_gaac := false
				for _, _adddb := range _aedd.Numbering._gcfa.AbstractNum {
					if _adddb.AbstractNumIdAttr == _fegb {
						_gaac = true
						break
					}
				}
				if !_gaac {
					_aedd.Numbering._gcfa.AbstractNum = append(_aedd.Numbering._gcfa.AbstractNum, _ccfde)
				}
				break
			}
		}
	}
}

// ParagraphStyles returns only the paragraph styles.
func (_dfacf Styles) ParagraphStyles() []Style {
	_affed := []Style{}
	for _, _dfafb := range _dfacf._cegfc.Style {
		if _dfafb.TypeAttr != _deg.ST_StyleTypeParagraph {
			continue
		}
		_affed = append(_affed, Style{_dfafb})
	}
	return _affed
}

// InlineDrawing is an inlined image within a run.
type InlineDrawing struct {
	_cbge  *Document
	_bfcfc *_deg.WdInline
}

func (_bcca Run) newIC() *_deg.EG_RunInnerContent {
	_cdgb := _deg.NewEG_RunInnerContent()
	_bcca._gabc.EG_RunInnerContent = append(_bcca._gabc.EG_RunInnerContent, _cdgb)
	return _cdgb
}

// NewNumbering constructs a new numbering.
func NewNumbering() Numbering { _eaggc := _deg.NewNumbering(); return Numbering{_eaggc} }

// SetProperties sets the `RunProperties` to the `Run` element
func (_fagca Run) SetProperties(rp RunProperties) {
	if rp._bfed == nil {
		_fagca._gabc.RPr = _deg.NewCT_RPr()
	} else {
		_cfadc := _deg.NewCT_RPr()
		if rp._bfed.RStyle != nil {
			_cfadc.RStyle = &_deg.CT_String{ValAttr: rp._bfed.RStyle.ValAttr}
		}
		if rp._bfed.RFonts != nil {
			_cfadc.RFonts = &_deg.CT_Fonts{HintAttr: rp._bfed.RFonts.HintAttr, AsciiAttr: rp._bfed.RFonts.AsciiAttr, HAnsiAttr: rp._bfed.RFonts.HAnsiAttr, EastAsiaAttr: rp._bfed.RFonts.EastAsiaAttr, CsAttr: rp._bfed.RFonts.CsAttr, AsciiThemeAttr: rp._bfed.RFonts.AsciiThemeAttr, HAnsiThemeAttr: rp._bfed.RFonts.HAnsiThemeAttr, EastAsiaThemeAttr: rp._bfed.RFonts.EastAsiaThemeAttr, CsthemeAttr: rp._bfed.RFonts.CsthemeAttr}
		}
		if rp._bfed.B != nil {
			_cfadc.B = &_deg.CT_OnOff{}
			if rp._bfed.B.ValAttr != nil {
				_agdag := *rp._bfed.B.ValAttr
				_cfadc.B.ValAttr = &_agdag
			}
		}
		if rp._bfed.BCs != nil {
			_cfadc.BCs = &_deg.CT_OnOff{}
			if rp._bfed.BCs.ValAttr != nil {
				_adcdd := *rp._bfed.BCs.ValAttr
				_cfadc.BCs.ValAttr = &_adcdd
			}
		}
		if rp._bfed.I != nil {
			_cfadc.I = &_deg.CT_OnOff{}
			if rp._bfed.I.ValAttr != nil {
				_dbegb := *rp._bfed.I.ValAttr
				_cfadc.I.ValAttr = &_dbegb
			}
		}
		if rp._bfed.ICs != nil {
			_cfadc.ICs = &_deg.CT_OnOff{}
			if rp._bfed.ICs.ValAttr != nil {
				_efbff := *rp._bfed.ICs.ValAttr
				_cfadc.ICs.ValAttr = &_efbff
			}
		}
		if rp._bfed.Caps != nil {
			_cfadc.Caps = &_deg.CT_OnOff{}
			if rp._bfed.Caps.ValAttr != nil {
				_eccab := *rp._bfed.Caps.ValAttr
				_cfadc.Caps.ValAttr = &_eccab
			}
		}
		if rp._bfed.SmallCaps != nil {
			_cfadc.SmallCaps = &_deg.CT_OnOff{}
			if rp._bfed.SmallCaps.ValAttr != nil {
				_ceacf := *rp._bfed.SmallCaps.ValAttr
				_cfadc.SmallCaps.ValAttr = &_ceacf
			}
		}
		if rp._bfed.Strike != nil {
			_cfadc.Strike = &_deg.CT_OnOff{}
			if rp._bfed.Strike.ValAttr != nil {
				_bgfbdb := *rp._bfed.Strike.ValAttr
				_cfadc.Strike.ValAttr = &_bgfbdb
			}
		}
		if rp._bfed.Dstrike != nil {
			_cfadc.Dstrike = &_deg.CT_OnOff{}
			if rp._bfed.Dstrike.ValAttr != nil {
				_dbgdge := *rp._bfed.Dstrike.ValAttr
				_cfadc.Dstrike.ValAttr = &_dbgdge
			}
		}
		if rp._bfed.Outline != nil {
			_cfadc.Outline = &_deg.CT_OnOff{}
			if rp._bfed.Outline.ValAttr != nil {
				_dbebcg := *rp._bfed.Outline.ValAttr
				_cfadc.Outline.ValAttr = &_dbebcg
			}
		}
		if rp._bfed.Shadow != nil {
			_cfadc.Shadow = &_deg.CT_OnOff{}
			if rp._bfed.Shadow.ValAttr != nil {
				_gcbgc := *rp._bfed.Shadow.ValAttr
				_cfadc.Shadow.ValAttr = &_gcbgc
			}
		}
		if rp._bfed.Emboss != nil {
			_cfadc.Emboss = &_deg.CT_OnOff{}
			if rp._bfed.Emboss.ValAttr != nil {
				_cbec := *rp._bfed.Emboss.ValAttr
				_cfadc.Emboss.ValAttr = &_cbec
			}
		}
		if rp._bfed.Imprint != nil {
			_cfadc.Imprint = &_deg.CT_OnOff{}
			if rp._bfed.Imprint.ValAttr != nil {
				_acbfc := *rp._bfed.Imprint.ValAttr
				_cfadc.Imprint.ValAttr = &_acbfc
			}
		}
		if rp._bfed.NoProof != nil {
			_cfadc.NoProof = &_deg.CT_OnOff{}
			if rp._bfed.NoProof.ValAttr != nil {
				_bbadce := *rp._bfed.NoProof.ValAttr
				_cfadc.NoProof.ValAttr = &_bbadce
			}
		}
		if rp._bfed.SnapToGrid != nil {
			_cfadc.SnapToGrid = &_deg.CT_OnOff{}
			if rp._bfed.SnapToGrid.ValAttr != nil {
				_ebfge := *rp._bfed.SnapToGrid.ValAttr
				_cfadc.SnapToGrid.ValAttr = &_ebfge
			}
		}
		if rp._bfed.Vanish != nil {
			_cfadc.Vanish = &_deg.CT_OnOff{}
			if rp._bfed.Vanish.ValAttr != nil {
				_cfcc := *rp._bfed.Vanish.ValAttr
				_cfadc.Vanish.ValAttr = &_cfcc
			}
		}
		if rp._bfed.WebHidden != nil {
			_cfadc.WebHidden = &_deg.CT_OnOff{}
			if rp._bfed.WebHidden.ValAttr != nil {
				_eccd := *rp._bfed.WebHidden.ValAttr
				_cfadc.WebHidden.ValAttr = &_eccd
			}
		}
		if rp._bfed.Color != nil {
			_cfadc.Color = &_deg.CT_Color{ValAttr: rp._bfed.Color.ValAttr, ThemeColorAttr: rp._bfed.Color.ThemeColorAttr, ThemeTintAttr: rp._bfed.Color.ThemeTintAttr, ThemeShadeAttr: rp._bfed.Color.ThemeShadeAttr}
		}
		if rp._bfed.Spacing != nil {
			_cfadc.Spacing = &_deg.CT_SignedTwipsMeasure{ValAttr: rp._bfed.Spacing.ValAttr}
		}
		if rp._bfed.W != nil {
			_cfadc.W = &_deg.CT_TextScale{ValAttr: rp._bfed.W.ValAttr}
		}
		if rp._bfed.Kern != nil {
			_cfadc.Kern = &_deg.CT_HpsMeasure{ValAttr: rp._bfed.Kern.ValAttr}
		}
		if rp._bfed.Position != nil {
			_cfadc.Position = &_deg.CT_SignedHpsMeasure{ValAttr: rp._bfed.Position.ValAttr}
		}
		if rp._bfed.Sz != nil {
			_cfadc.Sz = &_deg.CT_HpsMeasure{ValAttr: rp._bfed.Sz.ValAttr}
		}
		if rp._bfed.SzCs != nil {
			_cfadc.SzCs = &_deg.CT_HpsMeasure{ValAttr: rp._bfed.SzCs.ValAttr}
		}
		if rp._bfed.Highlight != nil {
			_cfadc.Highlight = &_deg.CT_Highlight{ValAttr: rp._bfed.Highlight.ValAttr}
		}
		if rp._bfed.U != nil {
			_cfadc.U = &_deg.CT_Underline{ValAttr: rp._bfed.U.ValAttr, ColorAttr: rp._bfed.U.ColorAttr, ThemeColorAttr: rp._bfed.U.ThemeColorAttr, ThemeTintAttr: rp._bfed.U.ThemeTintAttr, ThemeShadeAttr: rp._bfed.U.ThemeShadeAttr}
		}
		if rp._bfed.Effect != nil {
			_cfadc.Effect = &_deg.CT_TextEffect{ValAttr: rp._bfed.Effect.ValAttr}
		}
		if rp._bfed.Bdr != nil {
			_cfadc.Bdr = &_deg.CT_Border{ValAttr: rp._bfed.Bdr.ValAttr, ColorAttr: rp._bfed.Bdr.ColorAttr, ThemeColorAttr: rp._bfed.Bdr.ThemeColorAttr, ThemeTintAttr: rp._bfed.Bdr.ThemeTintAttr, ThemeShadeAttr: rp._bfed.Bdr.ThemeShadeAttr, SzAttr: rp._bfed.Bdr.SzAttr, SpaceAttr: rp._bfed.Bdr.SpaceAttr, ShadowAttr: rp._bfed.Bdr.ShadowAttr, FrameAttr: rp._bfed.Bdr.FrameAttr}
		}
		if rp._bfed.Shd != nil {
			_cfadc.Shd = &_deg.CT_Shd{ValAttr: rp._bfed.Shd.ValAttr, ColorAttr: rp._bfed.Shd.ColorAttr, ThemeColorAttr: rp._bfed.Shd.ThemeColorAttr, ThemeTintAttr: rp._bfed.Shd.ThemeTintAttr, ThemeShadeAttr: rp._bfed.Shd.ThemeShadeAttr, FillAttr: rp._bfed.Shd.FillAttr, ThemeFillAttr: rp._bfed.Shd.ThemeFillAttr, ThemeFillTintAttr: rp._bfed.Shd.ThemeFillTintAttr, ThemeFillShadeAttr: rp._bfed.Shd.ThemeFillShadeAttr}
		}
		if rp._bfed.FitText != nil {
			_cfadc.FitText = &_deg.CT_FitText{ValAttr: rp._bfed.FitText.ValAttr, IdAttr: rp._bfed.FitText.IdAttr}
		}
		if rp._bfed.VertAlign != nil {
			_cfadc.VertAlign = &_deg.CT_VerticalAlignRun{ValAttr: rp._bfed.VertAlign.ValAttr}
		}
		if rp._bfed.Rtl != nil {
			_cfadc.Rtl = &_deg.CT_OnOff{ValAttr: rp._bfed.Rtl.ValAttr}
		}
		if rp._bfed.Cs != nil {
			_cfadc.Cs = &_deg.CT_OnOff{ValAttr: rp._bfed.Cs.ValAttr}
		}
		if rp._bfed.Em != nil {
			_cfadc.Em = &_deg.CT_Em{ValAttr: rp._bfed.Em.ValAttr}
		}
		if rp._bfed.Lang != nil {
			_cfadc.Lang = &_deg.CT_Language{ValAttr: rp._bfed.Lang.ValAttr, EastAsiaAttr: rp._bfed.Lang.EastAsiaAttr, BidiAttr: rp._bfed.Lang.BidiAttr}
		}
		if rp._bfed.EastAsianLayout != nil {
			_cfadc.EastAsianLayout = &_deg.CT_EastAsianLayout{IdAttr: rp._bfed.EastAsianLayout.IdAttr, CombineAttr: rp._bfed.EastAsianLayout.CombineAttr, CombineBracketsAttr: rp._bfed.EastAsianLayout.CombineBracketsAttr, VertAttr: rp._bfed.EastAsianLayout.VertAttr, VertCompressAttr: rp._bfed.EastAsianLayout.VertCompressAttr}
		}
		if rp._bfed.SpecVanish != nil {
			_cfadc.SpecVanish = &_deg.CT_OnOff{ValAttr: rp._bfed.SpecVanish.ValAttr}
		}
		if rp._bfed.OMath != nil {
			_cfadc.OMath = &_deg.CT_OnOff{ValAttr: rp._bfed.OMath.ValAttr}
		}
		_fagca._gabc.RPr = _cfadc
	}
}

// Clear content of node element.
func (_dfgb *Node) Clear() { _dfgb._bbbg = nil }

// GetStyle returns string style of the text in watermark and format it to TextpathStyle.
func (_dcdf *WatermarkText) GetStyle() _bgg.TextpathStyle {
	_bedaa := _dcdf.getShape()
	if _dcdf._cfbf != nil {
		_gbefd := _dcdf._cfbf.ShapeChoice
		for _, _cgddc := range _gbefd {
			if _cgddc.ShapeElementsChoice.Textpath != nil {
				return _bgg.NewTextpathStyle(*_cgddc.ShapeElementsChoice.Textpath.StyleAttr)
			}
		}
	} else {
		_adbfg := _dcdf.findNode(_bedaa, "\u0074\u0065\u0078\u0074\u0070\u0061\u0074\u0068")
		for _, _aggg := range _adbfg.Attrs {
			if _aggg.Name.Local == "\u0073\u0074\u0079l\u0065" {
				return _bgg.NewTextpathStyle(_aggg.Value)
			}
		}
	}
	return _bgg.NewTextpathStyle("")
}

// Style is a style within the styles.xml file.
type Style struct{ _bageg *_deg.CT_Style }

// SetSize sets size attribute for a FormFieldTypeCheckBox in pt.
func (_aeaa FormField) SetSize(size uint64) {
	if len(_aeaa._bgcg.FFDataChoice) == 0 {
		return
	}
	size *= 2
	for _, _cfaaa := range _aeaa._bgcg.FFDataChoice {
		if _cfaaa.CheckBox != nil {
			_cfaaa.CheckBox.FFCheckBoxChoice = _deg.NewCT_FFCheckBoxChoice()
			_cfaaa.CheckBox.FFCheckBoxChoice.Size = _deg.NewCT_HpsMeasure()
			_cfaaa.CheckBox.FFCheckBoxChoice.Size.ValAttr = _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &size}
		}
	}
}

// SetInsideHorizontal sets the interior horizontal borders to a specified type, color and thickness.
func (_gfff CellBorders) SetInsideHorizontal(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_gfff._fba.InsideH = _deg.NewCT_Border()
	_bgdcd(_gfff._fba.InsideH, t, c, thickness)
}

// Paragraphs returns the paragraphs defined in a footer.
func (_geecg Footer) Paragraphs() []Paragraph {
	_cdab := []Paragraph{}
	for _, _aeda := range _geecg._aabd.EG_BlockLevelElts {
		for _, _fgea := range _aeda.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _, _ecef := range _fgea.ContentBlockContentChoice.P {
				_cdab = append(_cdab, Paragraph{_geecg._abba, _ecef})
			}
		}
	}
	for _, _cfged := range _geecg.Tables() {
		for _, _cfcgb := range _cfged.Rows() {
			for _, _dfg := range _cfcgb.Cells() {
				_cdab = append(_cdab, _dfg.Paragraphs()...)
			}
		}
	}
	return _cdab
}

// X returns the inner wrapped XML type.
func (_bfd Comment) X() *_deg.CT_Comment { return _bfd._bfbc }
func (_aagf Comment) id() int64          { return _aagf._bfbc.IdAttr }

// SetHeight allows controlling the height of a row within a table.
func (_abab RowProperties) SetHeight(ht _cdg.Distance, rule _deg.ST_HeightRule) {
	if rule == _deg.ST_HeightRuleUnset {
		_abab._ebdgc.TrPrBaseChoice = nil
	} else {
		_ebdgb := _deg.NewCT_Height()
		_ebdgb.HRuleAttr = rule
		_ebdgb.ValAttr = &_fae.ST_TwipsMeasure{}
		_ebdgb.ValAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(ht / _cdg.Twips))
		_abab._ebdgc.TrPrBaseChoice = []*_deg.CT_TrPrBaseChoice{&_deg.CT_TrPrBaseChoice{TrHeight: _ebdgb}}
	}
}

// AddEndnote will create a new endnote and attach it to the Paragraph in the
// location at the end of the previous run (endnotes create their own run within
// the paragraph. The text given to the function is simply a convenience helper,
// paragraphs and runs can always be added to the text of the endnote later.
func (_ffaeb Paragraph) AddEndnote(text string) Endnote {
	var _ebgg int64
	if _ffaeb._eaefb.HasEndnotes() {
		for _, _deaa := range _ffaeb._eaefb.Endnotes() {
			if _deaa.id() > _ebgg {
				_ebgg = _deaa.id()
			}
		}
		_ebgg++
	} else {
		_ffaeb._eaefb.addEndnotes()
		_ebgg = 1
	}
	_gegeb := _deg.NewCT_FtnEdn()
	_abfee := _deg.NewCT_FtnEdnRef()
	_abfee.IdAttr = _ebgg
	_ffaeb._eaefb._ebfb.CT_Endnotes.Endnote = append(_ffaeb._eaefb._ebfb.CT_Endnotes.Endnote, _gegeb)
	_fgbc := _ffaeb.AddRun()
	_caef := _fgbc.Properties()
	_caef.SetStyle(_fdb)
	_fgbc._gabc.EG_RunInnerContent = []*_deg.EG_RunInnerContent{_deg.NewEG_RunInnerContent()}
	_fgbc._gabc.EG_RunInnerContent[0].RunInnerContentChoice.EndnoteReference = _abfee
	_dcda := Endnote{_ffaeb._eaefb, _gegeb}
	_dcda._cfda.IdAttr = _ebgg
	_dcda._cfda.EG_BlockLevelElts = []*_deg.EG_BlockLevelElts{_deg.NewEG_BlockLevelElts()}
	_begac := _dcda.AddParagraph()
	_begac.Properties().SetStyle(EndnoteTextStyleId)
	_begac._bbff.PPr.RPr = _deg.NewCT_ParaRPr()
	_cgbf := _begac.AddRun()
	_dcagg := _cgbf.Properties()
	_dcagg.SetStyle(_fdb)
	_cgbf.AddEndnoteReference()
	_bbbeb := _begac.AddRun()
	_bbbeb.AddText("\u0020")
	_bbbeb = _begac.AddRun()
	_bbbeb.AddText(text)
	return _dcda
}
func _fgac() *_dc.Imagedata {
	_cffc := _dc.NewImagedata()
	_beec := "\u0072\u0049\u0064\u0031"
	_afac := "\u0057A\u0054\u0045\u0052\u004d\u0041\u0052K"
	_cffc.IdAttr = &_beec
	_cffc.TitleAttr = &_afac
	return _cffc
}

// SetGlowImageEffect sets the glow image effect.
func (_ggd AnchoredDrawing) SetGlowImageEffect(radius _cdg.Distance, c _bg.Color) {
	_gfa := _cdg.ToEMU(float64(radius))
	for _, _eag := range _ggd._bgc.Graphic.GraphicData.Any {
		if _bga, _dbee := _eag.(*_gg.Pic); _dbee {
			_ggd.initializeEffectList(_bga.SpPr)
			_bga.SpPr.EffectPropertiesChoice.EffectLst.Glow = _ad.NewCT_GlowEffect()
			_bga.SpPr.EffectPropertiesChoice.EffectLst.Glow.RadAttr = &_gfa
			_bga.SpPr.EffectPropertiesChoice.EffectLst.Glow.SrgbClr = _ad.NewCT_SRgbColor()
			_bga.SpPr.EffectPropertiesChoice.EffectLst.Glow.SrgbClr.ValAttr = *c.AsRGBString()
		}
	}
	_ggd.setEffectExtent(_gfa, _gfa, _gfa, _gfa)
}

// AddImage adds an image to the document package, returning a reference that
// can be used to add the image to a run and place it in the document contents.
func (_cabeb Header) AddImage(i _ee.Image) (_ee.ImageRef, error) {
	var _egggg _ee.Relationships
	for _bebga, _dcdcc := range _cabeb._efbf._aaad {
		if _dcdcc == _cabeb._efadbc {
			_egggg = _cabeb._efbf._dgea[_bebga]
		}
	}
	_gbbfc := _ee.MakeImageRef(i, &_cabeb._efbf.DocBase, _egggg)
	if i.Data == nil && i.Path == "" {
		return _gbbfc, _bea.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _gbbfc, _bea.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _gbbfc, _bea.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	_cabeb._efbf.Images = append(_cabeb._efbf.Images, _gbbfc)
	_ebgff := _dd.Sprintf("\u006d\u0065d\u0069\u0061\u002fi\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", len(_cabeb._efbf.Images), i.Format)
	_bdeeg := _egggg.AddRelationship(_ebgff, _e.ImageType)
	_gbbfc.SetRelID(_bdeeg.X().IdAttr)
	return _gbbfc, nil
}

// RowProperties are the properties for a row within a table
type RowProperties struct{ _ebdgc *_deg.CT_TrPr }

// Themes returns document's themes.
func (_agge *Document) Themes() []*_ad.Theme { return _agge._dgb }

// CloseComment will close the comment.
func (_efeee Paragraph) CloseComment(commentId int64) {
	_efeee.addEndComment(commentId)
	_cedbb := _efeee.AddRun()
	_cedbb.AddCommentReference(commentId)
	_eegba := _cedbb.Properties()
	_eegba.SetStyle(_dee)
}
func _dggg() *_dc.Textpath {
	_dbggc := _dc.NewTextpath()
	_dbggc.OnAttr = _fae.ST_TrueFalseTrue
	_dbggc.FitshapeAttr = _fae.ST_TrueFalseTrue
	return _dbggc
}

// SetTop sets the top border to a specified type, color and thickness.
func (_ggbdc TableBorders) SetTop(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_ggbdc._cadbb.Top = _deg.NewCT_Border()
	_bgdcd(_ggbdc._cadbb.Top, t, c, thickness)
}

// Styles returns all styles.
func (_ecaed Styles) Styles() []Style {
	_adaaa := []Style{}
	for _, _fcgfe := range _ecaed._cegfc.Style {
		_adaaa = append(_adaaa, Style{_fcgfe})
	}
	return _adaaa
}

// IsEndnote returns a bool based on whether the run has a
// footnote or not. Returns both a bool as to whether it has
// a footnote as well as the ID of the footnote.
func (_cefc Run) IsEndnote() (bool, int64) {
	if _cefc._gabc.EG_RunInnerContent != nil {
		if _cefc._gabc.EG_RunInnerContent[0].RunInnerContentChoice.EndnoteReference != nil {
			return true, _cefc._gabc.EG_RunInnerContent[0].RunInnerContentChoice.EndnoteReference.IdAttr
		}
	}
	return false, 0
}

// Spacing returns the paragraph spacing settings.
func (_eace ParagraphProperties) Spacing() ParagraphSpacing {
	if _eace._adegb.Spacing == nil {
		_eace._adegb.Spacing = _deg.NewCT_Spacing()
	}
	return ParagraphSpacing{_eace._adegb.Spacing}
}

// AddParagraph adds a paragraph to the header.
func (_abdcc Header) AddParagraph() Paragraph {
	_bedgc := _deg.NewEG_ContentBlockContent()
	_abdcc._efadbc.EG_BlockLevelElts = append(_abdcc._efadbc.EG_BlockLevelElts, &_deg.EG_BlockLevelElts{BlockLevelEltsChoice: &_deg.EG_BlockLevelEltsChoice{EG_ContentBlockContent: []*_deg.EG_ContentBlockContent{_bedgc}}})
	_ecgdb := _deg.NewCT_P()
	_bedgc.ContentBlockContentChoice.P = append(_bedgc.ContentBlockContentChoice.P, _ecgdb)
	return Paragraph{_abdcc._efbf, _ecgdb}
}

// MultiLevelType returns the multilevel type, or ST_MultiLevelTypeUnset if not set.
func (_bgdff NumberingDefinition) MultiLevelType() _deg.ST_MultiLevelType {
	if _bgdff._feab.MultiLevelType != nil {
		return _bgdff._feab.MultiLevelType.ValAttr
	} else {
		return _deg.ST_MultiLevelTypeUnset
	}
}

// SetUpdateFieldsOnOpen controls if fields are recalculated upon opening the
// document. This is useful for things like a table of contents as the library
// only adds the field code and relies on Word/LibreOffice to actually compute
// the content.
func (_babcg Settings) SetUpdateFieldsOnOpen(b bool) {
	if !b {
		_babcg._bbaeb.UpdateFields = nil
	} else {
		_babcg._bbaeb.UpdateFields = _deg.NewCT_OnOff()
	}
}

// AnchorDrawWrapOptions is options to set
// wrapPolygon for wrap text through and tight.
type AnchorDrawWrapOptions struct {
	_eagb bool
	_bad  *_ad.CT_Point2D
	_ddf  []*_ad.CT_Point2D
}

// InsertParagraphAfter adds a new empty paragraph after the relativeTo
// paragraph.
func (_abfe *Document) InsertParagraphAfter(relativeTo Paragraph) Paragraph {
	return _abfe.insertParagraph(relativeTo, false)
}

// InsertParagraphBefore adds a new empty paragraph before the relativeTo
// paragraph.
func (_egcef *Document) InsertParagraphBefore(relativeTo Paragraph) Paragraph {
	return _egcef.insertParagraph(relativeTo, true)
}

// X returns the inner wrapped XML type.
func (_ccc Color) X() *_deg.CT_Color { return _ccc._dbb }
func _bcdb(_dbag *_deg.CT_Tbl, _fcegd map[string]string) {
	for _, _fbgbe := range _dbag.EG_ContentRowContent {
		for _, _cefd := range _fbgbe.ContentRowContentChoice.Tr {
			for _, _caga := range _cefd.EG_ContentCellContent {
				for _, _bcbf := range _caga.ContentCellContentChoice.Tc {
					for _, _adeab := range _bcbf.EG_BlockLevelElts {
						for _, _fgga := range _adeab.BlockLevelEltsChoice.EG_ContentBlockContent {
							for _, _edfb := range _fgga.ContentBlockContentChoice.P {
								_ggga(_edfb, _fcegd)
							}
							for _, _cffa := range _fgga.ContentBlockContentChoice.Tbl {
								_bcdb(_cffa, _fcegd)
							}
						}
					}
				}
			}
		}
	}
}

// SetAlignment positions an anchored image via alignment.  Offset is
// incompatible with SetOffset, whichever is called last is applied.
func (_ead AnchoredDrawing) SetAlignment(h _deg.WdST_AlignH, v _deg.WdST_AlignV) {
	_ead.SetHAlignment(h)
	_ead.SetVAlignment(v)
}
func (_bgda *WatermarkText) getInnerElement(_dadae string) *_e.XSDAny {
	for _, _daac := range _bgda._deegd.Any {
		_egba, _bfcgb := _daac.(*_e.XSDAny)
		if _bfcgb && (_egba.XMLName.Local == _dadae || _egba.XMLName.Local == "\u0076\u003a"+_dadae) {
			return _egba
		}
	}
	return nil
}
func (_bdeb *Document) removeEndnote(_geb int64) {
	_ddga := _bdeb._ebfb
	var _ffc int
	for _bcg, _aeea := range _ddga.CT_Endnotes.Endnote {
		if _aeea.IdAttr == _geb {
			_ffc = _bcg
			break
		}
	}
	_ddga.CT_Endnotes.Endnote[_ffc] = nil
	_ddga.CT_Endnotes.Endnote[_ffc] = _ddga.CT_Endnotes.Endnote[len(_ddga.CT_Endnotes.Endnote)-1]
	_ddga.CT_Endnotes.Endnote = _ddga.CT_Endnotes.Endnote[:len(_ddga.CT_Endnotes.Endnote)-1]
	_bdeb.reorderEndnote()
	_bdeb.syncEndnoteSettings()
}

// Imprint returns true if run imprint is on.
func (_afcaa RunProperties) Imprint() bool { return _dabbe(_afcaa._bfed.Imprint) }

// AddImage adds an image to the document package, returning a reference that
// can be used to add the image to a run and place it in the document contents.
func (_fcfa *Document) AddImage(i _ee.Image) (_ee.ImageRef, error) {
	_bdcg := _ee.MakeImageRef(i, &_fcfa.DocBase, _fcfa._afff)
	if i.Data == nil && i.Path == "" {
		return _bdcg, _bea.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _bdcg, _bea.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _bdcg, _bea.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	if i.Path != "" {
		_gegf := _af.Add(i.Path)
		if _gegf != nil {
			return _bdcg, _gegf
		}
	}
	_fcfa.Images = append(_fcfa.Images, _bdcg)
	_geeb := _dd.Sprintf("\u006d\u0065d\u0069\u0061\u002fi\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", len(_fcfa.Images), i.Format)
	_bgec := _fcfa._afff.AddRelationship(_geeb, _e.ImageType)
	_fcfa.ContentTypes.EnsureDefault("\u0070\u006e\u0067", "\u0069m\u0061\u0067\u0065\u002f\u0070\u006eg")
	_fcfa.ContentTypes.EnsureDefault("\u006a\u0070\u0065\u0067", "\u0069\u006d\u0061\u0067\u0065\u002f\u006a\u0070\u0065\u0067")
	_fcfa.ContentTypes.EnsureDefault("\u006a\u0070\u0067", "\u0069\u006d\u0061\u0067\u0065\u002f\u006a\u0070\u0065\u0067")
	_fcfa.ContentTypes.EnsureDefault("\u0077\u006d\u0066", "i\u006d\u0061\u0067\u0065\u002f\u0078\u002d\u0077\u006d\u0066")
	_fcfa.ContentTypes.EnsureDefault(i.Format, "\u0069\u006d\u0061\u0067\u0065\u002f"+i.Format)
	_bdcg.SetRelID(_bgec.X().IdAttr)
	_bdcg.SetTarget(_geeb)
	return _bdcg, nil
}

// InsertStyle insert style to styles.
func (_fagdf Styles) InsertStyle(ss Style) { _fagdf._cegfc.Style = append(_fagdf._cegfc.Style, ss.X()) }

// SetAfterSpacing sets spacing below paragraph.
func (_ebbb Paragraph) SetAfterSpacing(d _cdg.Distance) {
	_ebbb.ensurePPr()
	if _ebbb._bbff.PPr.Spacing == nil {
		_ebbb._bbff.PPr.Spacing = _deg.NewCT_Spacing()
	}
	_gcfgc := _ebbb._bbff.PPr.Spacing
	_gcfgc.AfterAttr = &_fae.ST_TwipsMeasure{}
	_gcfgc.AfterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(d / _cdg.Twips))
}

// Text return node and its child text,
func (_ffcaa *Node) Text() string {
	_babcf := _ag.NewBuffer([]byte{})
	switch _bagb := _ffcaa.X().(type) {
	case *Paragraph:
		for _, _bggb := range _bagb.Runs() {
			if _bggb.Text() != "" {
				_babcf.WriteString(_bggb.Text())
				_babcf.WriteString("\u000a")
			}
		}
	}
	for _, _edfba := range _ffcaa.Children {
		_babcf.WriteString(_edfba.Text())
	}
	return _babcf.String()
}

// TableLook returns the table look, or conditional formatting applied to a table style.
func (_bfded TableProperties) TableLook() TableLook {
	if _bfded._gafba.TblLook == nil {
		_bfded._gafba.TblLook = _deg.NewCT_TblLook()
	}
	return TableLook{_bfded._gafba.TblLook}
}

// New constructs an empty document that content can be added to.
func New() *Document {
	_cdb := &Document{_effc: _deg.NewDocument()}
	_cdb.ContentTypes = _ee.NewContentTypes()
	_cdb._effc.Body = _deg.NewCT_Body()
	_cdb._effc.ConformanceAttr = _fae.ST_ConformanceClassTransitional
	_cdb._afff = _ee.NewRelationships()
	_cdb._gdcc = _ee.NewRelationships()
	_cdb.AppProperties = _ee.NewAppProperties()
	_cdb.CoreProperties = _ee.NewCoreProperties()
	_cdb.ContentTypes.AddOverride("\u002fw\u006fr\u0064\u002f\u0064\u006f\u0063u\u006d\u0065n\u0074\u002e\u0078\u006d\u006c", "\u0061p\u0070\u006c\u0069c\u0061\u0074\u0069o\u006e/v\u006e\u0064\u002e\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072dp\u0072o\u0063\u0065\u0073\u0073\u0069\u006eg\u006d\u006c\u002e\u0064\u006fc\u0075\u006d\u0065\u006e\u0074\u002e\u006d\u0061\u0069\u006e\u002bx\u006d\u006c")
	_cdb.Settings = NewSettings()
	_cdb._afff.AddRelationship("\u0073\u0065\u0074t\u0069\u006e\u0067\u0073\u002e\u0078\u006d\u006c", _e.SettingsType)
	_cdb.ContentTypes.AddOverride("\u002fw\u006fr\u0064\u002f\u0073\u0065\u0074t\u0069\u006eg\u0073\u002e\u0078\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0074\u0069o\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006e\u0078\u006dl\u0066\u006f\u0072\u006da\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c.\u0073\u0065\u0074\u0074\u0069\u006e\u0067\u0073\u002b\u0078\u006d\u006c")
	_cdb.Rels = _ee.NewRelationships()
	_cdb.Rels.AddRelationship(_e.RelativeFilename(_e.DocTypeDocument, "", _e.CorePropertiesType, 0), _e.CorePropertiesType)
	_cdb.Rels.AddRelationship("\u0064\u006fc\u0050\u0072\u006fp\u0073\u002f\u0061\u0070\u0070\u002e\u0078\u006d\u006c", _e.ExtendedPropertiesType)
	_cdb.Rels.AddRelationship("\u0077\u006f\u0072\u0064\u002f\u0064\u006f\u0063\u0075\u006d\u0065\u006et\u002e\u0078\u006d\u006c", _e.OfficeDocumentType)
	_cdb.Numbering = NewNumbering()
	_cdb.Numbering.InitializeDefault()
	_cdb.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072d/\u006e\u0075\u006d\u0062\u0065\u0072\u0069\u006e\u0067\u002e\u0078\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002f\u0076n\u0064\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063e\u0073\u0073\u0069\u006e\u0067\u006d\u006c\u002e\u006e\u0075\u006d\u0062e\u0072\u0069\u006e\u0067\u002b\u0078m\u006c")
	_cdb._afff.AddRelationship("\u006e\u0075\u006d\u0062\u0065\u0072\u0069\u006e\u0067\u002e\u0078\u006d\u006c", _e.NumberingType)
	_cdb.Styles = NewStyles()
	_cdb.Styles.InitializeDefault()
	_cdb.ContentTypes.AddOverride("\u002f\u0077o\u0072\u0064\u002fs\u0074\u0079\u006c\u0065\u0073\u002e\u0078\u006d\u006c", "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0076\u006e\u0064.\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c\u002e\u0073\u0074\u0079\u006ce\u0073\u002b\u0078\u006d\u006c")
	_cdb._afff.AddRelationship("\u0073\u0074\u0079\u006c\u0065\u0073\u002e\u0078\u006d\u006c", _e.StylesType)
	_cdb._effc.Body = _deg.NewCT_Body()
	return _cdb
}

// AddParagraph adds a paragraph to the footer.
func (_abce Footer) AddParagraph() Paragraph {
	_fgbg := _deg.NewEG_ContentBlockContent()
	_abce._aabd.EG_BlockLevelElts = append(_abce._aabd.EG_BlockLevelElts, &_deg.EG_BlockLevelElts{BlockLevelEltsChoice: &_deg.EG_BlockLevelEltsChoice{EG_ContentBlockContent: []*_deg.EG_ContentBlockContent{_fgbg}}})
	_cdbf := _deg.NewCT_P()
	_fgbg.ContentBlockContentChoice.P = append(_fgbg.ContentBlockContentChoice.P, _cdbf)
	return Paragraph{_abce._abba, _cdbf}
}

// Emboss returns true if paragraph emboss is on.
func (_eedc ParagraphProperties) Emboss() bool { return _dabbe(_eedc._adegb.RPr.Emboss) }

// AddLevel adds a new numbering level to a NumberingDefinition.
func (_fbabc NumberingDefinition) AddLevel() NumberingLevel {
	_bcdg := _deg.NewCT_Lvl()
	_bcdg.Start = &_deg.CT_DecimalNumber{ValAttr: 1}
	_bcdg.IlvlAttr = int64(len(_fbabc._feab.Lvl))
	_fbabc._feab.Lvl = append(_fbabc._feab.Lvl, _bcdg)
	return NumberingLevel{_bcdg}
}
func (_ccdf *Document) addFootnoteSeparator() {
	_cdffg := _deg.NewCT_FtnEdn()
	_cdffg.IdAttr = -1
	_cdffg.TypeAttr = _deg.ST_FtnEdnSeparator
	_eadb := Footnote{_ccdf, _cdffg}
	_eadb.X().EG_BlockLevelElts = []*_deg.EG_BlockLevelElts{_deg.NewEG_BlockLevelElts()}
	_gadg := _eadb.AddParagraph()
	_gadg.X().PPr = nil
	_bbda := _gadg.AddRun()
	_becf := _bbda.newIC()
	_becf.RunInnerContentChoice.Separator = _deg.NewCT_Empty()
	_ccdf._daaf.CT_Footnotes.Footnote = append(_ccdf._daaf.CT_Footnotes.Footnote, _cdffg)
	_cdffg = _deg.NewCT_FtnEdn()
	_cdffg.IdAttr = 0
	_cdffg.TypeAttr = _deg.ST_FtnEdnContinuationSeparator
	_eadb = Footnote{_ccdf, _cdffg}
	_eadb.X().EG_BlockLevelElts = []*_deg.EG_BlockLevelElts{_deg.NewEG_BlockLevelElts()}
	_gadg = _eadb.AddParagraph()
	_gadg.X().PPr = nil
	_bbda = _gadg.AddRun()
	_becf = _bbda.newIC()
	_becf.RunInnerContentChoice.ContinuationSeparator = _deg.NewCT_Empty()
	_ccdf._daaf.CT_Footnotes.Footnote = append(_ccdf._daaf.CT_Footnotes.Footnote, _cdffg)
}
func _cfgb(_babb *_deg.CT_TblWidth, _aae float64) {
	_babb.TypeAttr = _deg.ST_TblWidthPct
	_babb.WAttr = &_deg.ST_MeasurementOrPercent{}
	_babb.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_babb.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(_aae * 50))
}

// ComplexSizeValue returns the value of paragraph font size for complex fonts in points.
func (_fegea ParagraphProperties) ComplexSizeValue() float64 {
	if _gacf := _fegea._adegb.RPr.SzCs; _gacf != nil {
		_geag := _gacf.ValAttr
		if _geag.ST_UnsignedDecimalNumber != nil {
			return float64(*_geag.ST_UnsignedDecimalNumber) / 2
		}
	}
	return 0.0
}

// SetShadow sets the run to shadowed text.
func (_egffd RunProperties) SetShadow(b bool) {
	if !b {
		_egffd._bfed.Shadow = nil
	} else {
		_egffd._bfed.Shadow = _deg.NewCT_OnOff()
	}
}

// PossibleValues returns the possible values for a FormFieldTypeDropDown.
func (_fagb FormField) PossibleValues() []string {
	if len(_fagb._bgcg.FFDataChoice) == 0 {
		return nil
	}
	_aabgf := []string{}
	for _, _fdaf := range _fagb._bgcg.FFDataChoice {
		if _fdaf.DdList != nil {
			for _, _ddgf := range _fdaf.DdList.ListEntry {
				if _ddgf == nil {
					continue
				}
				_aabgf = append(_aabgf, _ddgf.ValAttr)
			}
		}
	}
	return _aabgf
}

// SetOutline sets the run to outlined text.
func (_dggd RunProperties) SetOutline(b bool) {
	if !b {
		_dggd._bfed.Outline = nil
	} else {
		_dggd._bfed.Outline = _deg.NewCT_OnOff()
	}
}

// X returns the inner wrapped type
func (_agea CellBorders) X() *_deg.CT_TcBorders { return _agea._fba }

// SetStyle sets the font size.
func (_badcd RunProperties) SetStyle(style string) {
	if style == "" {
		_badcd._bfed.RStyle = nil
	} else {
		_badcd._bfed.RStyle = _deg.NewCT_String()
		_badcd._bfed.RStyle.ValAttr = style
	}
}

// Clear clears all content within a footer
func (_fgdf Footer) Clear() { _fgdf._aabd.EG_BlockLevelElts = []*_deg.EG_BlockLevelElts{} }

// SetNextStyle sets the style that the next paragraph will use.
func (_dcgc Style) SetNextStyle(name string) {
	if name == "" {
		_dcgc._bageg.Next = nil
	} else {
		_dcgc._bageg.Next = _deg.NewCT_String()
		_dcgc._bageg.Next.ValAttr = name
	}
}

// SetOutlineLevel sets the outline level of this style.
func (_gceg ParagraphStyleProperties) SetOutlineLevel(lvl int) {
	_gceg._dgebc.OutlineLvl = _deg.NewCT_DecimalNumber()
	_gceg._dgebc.OutlineLvl.ValAttr = int64(lvl)
}
func (_daga *Document) addEndnotes() {
	_daga._ebfb = _deg.NewEndnotes()
	_daga.ContentTypes.AddOverride("\u002fw\u006fr\u0064\u002f\u0065\u006e\u0064n\u006f\u0074e\u0073\u002e\u0078\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0074\u0069o\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006e\u0078\u006dl\u0066\u006f\u0072\u006da\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c.\u0065\u006e\u0064\u006e\u006f\u0074\u0065\u0073\u002b\u0078\u006d\u006c")
	_daga._afff.AddRelationship("\u002fw\u006fr\u0064\u002f\u0065\u006e\u0064n\u006f\u0074e\u0073\u002e\u0078\u006d\u006c", _e.EndNotesType)
	_ccfd := _daga.Styles.AddStyle(EndnoteTextStyleId, _deg.ST_StyleTypeParagraph, false)
	_ccfd.SetName("\u0045\u006e\u0064n\u006f\u0074\u0065\u0020\u0054\u0065\u0078\u0074")
	_ccfd.SetBasedOn("\u004e\u006f\u0072\u006d\u0061\u006c")
	_dgca := _ccfd.ParagraphProperties()
	_dgca.X().SuppressLineNumbers = &_deg.CT_OnOff{}
	_ffeb := _ccfd.RunProperties()
	_ffeb.X().Sz = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_gda}}
	_ffeb.X().SzCs = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_gda}}
	_egad := _daga.Styles.AddStyle(_fdb, _deg.ST_StyleTypeCharacter, false)
	_egad.SetName("\u0045\u006e\u0064\u006e\u006f\u0074\u0065\u0020\u0052\u0065\u0066\u0065r\u0065\u006e\u0063\u0065")
	_gafb := _egad.RunProperties()
	_gafb.X().VertAlign = &_deg.CT_VerticalAlignRun{ValAttr: _fae.ST_VerticalAlignRunSuperscript}
	_daga.addEndnoteSeparator()
}
func _bcedg(_gcgb *_deg.CT_Tbl, _abff map[string]string) {
	for _, _edfc := range _gcgb.EG_ContentRowContent {
		for _, _eccg := range _edfc.ContentRowContentChoice.Tr {
			for _, _gcbg := range _eccg.EG_ContentCellContent {
				for _, _fegdb := range _gcbg.ContentCellContentChoice.Tc {
					for _, _ecge := range _fegdb.EG_BlockLevelElts {
						for _, _cfb := range _ecge.BlockLevelEltsChoice.EG_ContentBlockContent {
							for _, _beafb := range _cfb.ContentBlockContentChoice.P {
								_egeb(_beafb, _abff)
							}
							for _, _gdcd := range _cfb.ContentBlockContentChoice.Tbl {
								_bcedg(_gdcd, _abff)
							}
						}
					}
				}
			}
		}
	}
}

// Tables returns the tables defined in the document.
func (_cdf *Document) Tables() []Table {
	_dgfa := []Table{}
	if _cdf._effc.Body == nil {
		return nil
	}
	for _, _bag := range _cdf._effc.Body.EG_BlockLevelElts {
		for _, _gbf := range _bag.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _, _bddc := range _cdf.tables(_gbf) {
				_dgfa = append(_dgfa, _bddc)
			}
		}
	}
	return _dgfa
}

// Pict returns the pict object.
func (_bgfbba *WatermarkPicture) Pict() *_deg.CT_Picture { return _bgfbba._dbece }
func (_ccaf *WatermarkPicture) getShape() *_e.XSDAny {
	return _ccaf.getInnerElement("\u0073\u0068\u0061p\u0065")
}

// SetLastColumn controls the conditional formatting for the last column in a table.
func (_dcgd TableLook) SetLastColumn(on bool) {
	if !on {
		_dcgd._bfdc.LastColumnAttr = &_fae.ST_OnOff{}
		_dcgd._bfdc.LastColumnAttr.ST_OnOff1 = _fae.ST_OnOff1Off
	} else {
		_dcgd._bfdc.LastColumnAttr = &_fae.ST_OnOff{}
		_dcgd._bfdc.LastColumnAttr.ST_OnOff1 = _fae.ST_OnOff1On
	}
}
func (_daeg *Document) syncFootnoteSettings() {
	_aed := []int64{}
	_gefg := _daeg.Footnotes()
	for _, _fagg := range _gefg {
		if _fagg.X().TypeAttr != _deg.ST_FtnEdnUnset && _fagg.X().TypeAttr != _deg.ST_FtnEdnNormal {
			_aed = append(_aed, _fagg.X().IdAttr)
		}
	}
	_aadf := _daeg.Settings.X().CT_Settings.FootnotePr
	if _aadf == nil {
		_aadf = _deg.NewCT_FtnDocProps()
	}
	if len(_aed) == 0 {
		_aadf.Footnote = nil
		return
	}
	_aadf.Footnote = []*_deg.CT_FtnEdnSepRef{}
	for _, _edf := range _aed {
		_dgae := _deg.NewCT_FtnEdnSepRef()
		_dgae.IdAttr = _edf
		_aadf.Footnote = append(_aadf.Footnote, _dgae)
	}
}

// SizeValue returns the value of paragraph font size in points.
func (_gabgc ParagraphProperties) SizeValue() float64 {
	if _dgbd := _gabgc._adegb.RPr.Sz; _dgbd != nil {
		_beeec := _dgbd.ValAttr
		if _beeec.ST_UnsignedDecimalNumber != nil {
			return float64(*_beeec.ST_UnsignedDecimalNumber) / 2
		}
	}
	return 0.0
}
func (_fceec Paragraph) removeCommentRef(_fcbeb int64) bool {
	for _, _adff := range _fceec.X().EG_PContent {
		for _, _adge := range _adff.PContentChoice.EG_ContentRunContent {
			if _adge.ContentRunContentChoice.R != nil {
				for _, _faggga := range _adge.ContentRunContentChoice.R.EG_RunInnerContent {
					if _faggga.RunInnerContentChoice.CommentReference != nil && _faggga.RunInnerContentChoice.CommentReference.IdAttr == _fcbeb {
						_adge.ContentRunContentChoice.R = nil
						return true
					}
				}
			}
		}
	}
	return false
}

// GetHeaderFooterImageObjByRelId returns a common.Image with the associated relation ID in the
// document, its header or footer.
func (_cacdc *Document) GetHeaderFooterImageObjByRelId(relId string, isHeader, isFooter bool) (_ee.Image, error) {
	_cgge := ""
	if isHeader {
		for _, _bagg := range _cacdc._dgea {
			if _cgge != "" {
				break
			}
			_cgge = _bagg.GetTargetByRelIdAndType(relId, _e.ImageType)
		}
	}
	if isFooter && _cgge == "" {
		for _, _cfdcc := range _cacdc._fce {
			if _cgge != "" {
				break
			}
			_cgge = _cfdcc.GetTargetByRelIdAndType(relId, _e.ImageType)
		}
	}
	if _cgge == "" {
		_cgge = _cacdc._afff.GetTargetByRelIdAndType(relId, _e.ImageType)
	}
	return _cacdc.DocBase.GetImageBytesByTarget(_cgge)
}

// SizeValue returns the value of run font size in points.
func (_gcdg RunProperties) SizeValue() float64 {
	if _cbdg := _gcdg._bfed.Sz; _cbdg != nil {
		_cbaee := _cbdg.ValAttr
		if _cbaee.ST_UnsignedDecimalNumber != nil {
			return float64(*_cbaee.ST_UnsignedDecimalNumber) / 2
		}
	}
	return 0.0
}

// SetRightPct sets the cell right margin
func (_gcag CellMargins) SetRightPct(pct float64) {
	_gcag._fee.Right = _deg.NewCT_TblWidth()
	_cfgb(_gcag._fee.Right, pct)
}

// RemoveTable remove table element from document.
func (_aaga *Document) RemoveTable(tbl Table) {
	if _aaga._effc.Body == nil {
		return
	}
	for _, _cdff := range _aaga._effc.Body.EG_BlockLevelElts {
		for _, _bda := range _cdff.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _ded, _ddeb := range _bda.ContentBlockContentChoice.Tbl {
				if _ddeb == tbl._abbae {
					copy(_bda.ContentBlockContentChoice.Tbl[_ded:], _bda.ContentBlockContentChoice.Tbl[_ded+1:])
					_bda.ContentBlockContentChoice.Tbl = _bda.ContentBlockContentChoice.Tbl[0 : len(_bda.ContentBlockContentChoice.Tbl)-1]
					return
				}
			}
			if _bda.ContentBlockContentChoice.Sdt != nil && _bda.ContentBlockContentChoice.Sdt.SdtContent != nil {
				for _, _gbgd := range _bda.ContentBlockContentChoice.Sdt.SdtContent.EG_ContentBlockContent {
					if _gbgd.ContentBlockContentChoice.P != nil {
						for _fefg, _aad := range _gbgd.ContentBlockContentChoice.Tbl {
							if _aad == tbl._abbae {
								copy(_bda.ContentBlockContentChoice.Tbl[_fefg:], _bda.ContentBlockContentChoice.Tbl[_fefg+1:])
								_bda.ContentBlockContentChoice.Tbl = _bda.ContentBlockContentChoice.Tbl[0 : len(_bda.ContentBlockContentChoice.Tbl)-1]
								return
							}
						}
					}
				}
			}
		}
	}
}

// AddParagraph adds a paragraph to the footnote.
func (_bcee Footnote) AddParagraph() Paragraph {
	_afdbfb := _deg.NewEG_ContentBlockContent()
	_ceabc := len(_bcee._cfca.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent)
	_bcee._cfca.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent = append(_bcee._cfca.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent, _afdbfb)
	_cade := _deg.NewCT_P()
	var _bcffa *_deg.CT_String
	if _ceabc != 0 {
		_edcc := len(_bcee._cfca.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent[_ceabc-1].ContentBlockContentChoice.P)
		_bcffa = _bcee._cfca.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent[_ceabc-1].ContentBlockContentChoice.P[_edcc-1].PPr.PStyle
	} else {
		_bcffa = _deg.NewCT_String()
		_bcffa.ValAttr = FootnoteTextStyleId
	}
	_afdbfb.ContentBlockContentChoice.P = append(_afdbfb.ContentBlockContentChoice.P, _cade)
	_fbff := Paragraph{_bcee._dagad, _cade}
	_fbff._bbff.PPr = _deg.NewCT_PPr()
	_fbff._bbff.PPr.PStyle = _bcffa
	_fbff._bbff.PPr.RPr = _deg.NewCT_ParaRPr()
	return _fbff
}

// SetCalcOnExit marks if a FormField should be CalcOnExit or not.
func (_cbdd FormField) SetCalcOnExit(calcOnExit bool) {
	_abfec := _deg.NewCT_OnOff()
	_abfec.ValAttr = &_fae.ST_OnOff{Bool: &calcOnExit}
	_cbdd._bgcg.FFDataChoice = []*_deg.CT_FFDataChoice{{CalcOnExit: _abfec}}
}
func _gccec() *_dc.Formulas {
	_gbgf := _dc.NewFormulas()
	_gbgf.F = []*_dc.CT_F{_bgg.CreateFormula("\u0069\u0066 \u006c\u0069\u006e\u0065\u0044\u0072\u0061\u0077\u006e\u0020\u0070\u0069\u0078\u0065\u006c\u004c\u0069\u006e\u0065\u0057\u0069\u0064th\u0020\u0030"), _bgg.CreateFormula("\u0073\u0075\u006d\u0020\u0040\u0030\u0020\u0031\u0020\u0030"), _bgg.CreateFormula("\u0073\u0075\u006d\u0020\u0030\u0020\u0030\u0020\u0040\u0031"), _bgg.CreateFormula("p\u0072\u006f\u0064\u0020\u0040\u0032\u0020\u0031\u0020\u0032"), _bgg.CreateFormula("\u0070r\u006f\u0064\u0020\u0040\u0033\u0020\u0032\u0031\u0036\u0030\u0030 \u0070\u0069\u0078\u0065\u006c\u0057\u0069\u0064\u0074\u0068"), _bgg.CreateFormula("\u0070r\u006f\u0064\u0020\u00403\u0020\u0032\u0031\u0036\u00300\u0020p\u0069x\u0065\u006c\u0048\u0065\u0069\u0067\u0068t"), _bgg.CreateFormula("\u0073\u0075\u006d\u0020\u0040\u0030\u0020\u0030\u0020\u0031"), _bgg.CreateFormula("p\u0072\u006f\u0064\u0020\u0040\u0036\u0020\u0031\u0020\u0032"), _bgg.CreateFormula("\u0070r\u006f\u0064\u0020\u0040\u0037\u0020\u0032\u0031\u0036\u0030\u0030 \u0070\u0069\u0078\u0065\u006c\u0057\u0069\u0064\u0074\u0068"), _bgg.CreateFormula("\u0073\u0075\u006d\u0020\u0040\u0038\u0020\u0032\u00316\u0030\u0030\u0020\u0030"), _bgg.CreateFormula("\u0070r\u006f\u0064\u0020\u00407\u0020\u0032\u0031\u0036\u00300\u0020p\u0069x\u0065\u006c\u0048\u0065\u0069\u0067\u0068t"), _bgg.CreateFormula("\u0073u\u006d \u0040\u0031\u0030\u0020\u0032\u0031\u0036\u0030\u0030\u0020\u0030")}
	return _gbgf
}

// SetEffect sets a text effect on the run.
func (_bcge RunProperties) SetEffect(e _deg.ST_TextEffect) {
	if e == _deg.ST_TextEffectUnset {
		_bcge._bfed.Effect = nil
	} else {
		_bcge._bfed.Effect = _deg.NewCT_TextEffect()
		_bcge._bfed.Effect.ValAttr = e
	}
}

// SetAll sets all of the borders to a given value.
func (_afg CellBorders) SetAll(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_afg.SetBottom(t, c, thickness)
	_afg.SetLeft(t, c, thickness)
	_afg.SetRight(t, c, thickness)
	_afg.SetTop(t, c, thickness)
	_afg.SetInsideHorizontal(t, c, thickness)
	_afg.SetInsideVertical(t, c, thickness)
}

// Run is a run of text within a paragraph that shares the same formatting.
type Run struct {
	_fced *Document
	_gabc *_deg.CT_R
}

// SetWidth sets the table with to a specified width.
func (_bcaag TableProperties) SetWidth(d _cdg.Distance) {
	_bcaag._gafba.TblW = _deg.NewCT_TblWidth()
	_bcaag._gafba.TblW.TypeAttr = _deg.ST_TblWidthDxa
	_bcaag._gafba.TblW.WAttr = &_deg.ST_MeasurementOrPercent{}
	_bcaag._gafba.TblW.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_bcaag._gafba.TblW.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(d / _cdg.Twips))
}

// Rows returns the rows defined in the table.
func (_cbdf Table) Rows() []Row {
	_dabbec := []Row{}
	for _, _agfe := range _cbdf._abbae.EG_ContentRowContent {
		for _, _abeb := range _agfe.ContentRowContentChoice.Tr {
			_dabbec = append(_dabbec, Row{_cbdf._dafd, _abeb})
		}
		if _agfe.ContentRowContentChoice.Sdt != nil && _agfe.ContentRowContentChoice.Sdt.SdtContent != nil {
			for _, _facf := range _agfe.ContentRowContentChoice.Sdt.SdtContent.EG_ContentRowContent {
				for _, _dffbfd := range _facf.ContentRowContentChoice.Tr {
					_dabbec = append(_dabbec, Row{_cbdf._dafd, _dffbfd})
				}
			}
		}
	}
	return _dabbec
}
func (_ggcdf *Document) addComments() {
	_ggcdf._aeg = _deg.NewComments()
	_ggcdf._aeg.CT_Comments = *_deg.NewCT_Comments()
	_ggcdf._aeg.Comment = make([]*_deg.CT_Comment, 0)
	_ggcdf.ContentTypes.AddOverride("\u002fw\u006fr\u0064\u002f\u0063\u006f\u006dm\u0065\u006et\u0073\u002e\u0078\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069\u0063\u0061\u0074\u0069o\u006e\u002fv\u006e\u0064\u002e\u006f\u0070\u0065\u006e\u0078\u006dl\u0066\u006f\u0072\u006da\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c.\u0063\u006f\u006d\u006d\u0065\u006e\u0074\u0073\u002b\u0078\u006d\u006c")
	_ggcdf._afff.AddRelationship("\u0063\u006f\u006dm\u0065\u006e\u0074\u0073\u002e\u0078\u006d\u006c", _e.CommentsType)
	_bdbe := _ggcdf.Styles.AddStyle(_dee, _deg.ST_StyleTypeParagraph, false)
	_bdbe.SetName("\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0020\u0052\u0065\u0066\u0065r\u0065\u006e\u0063\u0065")
	_bdbe.SetBasedOn("D\u0065f\u0061\u0075\u006c\u0074\u0050\u0061\u0072\u0061g\u0072\u0061\u0070\u0068Fo\u006e\u0074")
	_gagb := _bdbe.RunProperties()
	_gagb.X().Sz = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_babd}}
	_gagb.X().SzCs = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_babd}}
	_gefgb := _ggcdf.Styles.AddStyle(_aec, _deg.ST_StyleTypeParagraph, false)
	_gefgb.SetName("\u0043\u006f\u006dm\u0065\u006e\u0074\u0020\u0054\u0065\u0078\u0074")
	_gefgb.SetBasedOn("\u004e\u006f\u0072\u006d\u0061\u006c")
	_gefgb.SetLinkedStyle(_cddb)
	_ffa := _gefgb.RunProperties()
	_ffa.X().Sz = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_aac}}
	_ffa.X().SzCs = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_aac}}
	_bfbb := _ggcdf.Styles.AddStyle(_aec, _deg.ST_StyleTypeParagraph, false)
	_bfbb.SetName("\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0020\u0054\u0065\u0078\u0074 \u0043\u0068\u0061\u0072")
	_bfbb.SetBasedOn("D\u0065f\u0061\u0075\u006c\u0074\u0050\u0061\u0072\u0061g\u0072\u0061\u0070\u0068Fo\u006e\u0074")
	_bfbb.SetLinkedStyle(_aec)
	_bdebf := _bfbb.RunProperties()
	_bdebf.X().Sz = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_aac}}
	_bdebf.X().SzCs = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_aac}}
	_gabd := _ggcdf.Styles.AddStyle(_aec, _deg.ST_StyleTypeParagraph, false)
	_gabd.SetName("\u0043o\u006dm\u0065\u006e\u0074\u0020\u0053\u0075\u0062\u006a\u0065\u0063\u0074")
	_gabd.SetBasedOn(_aec)
	_gabd.SetLinkedStyle(_bec)
	_gabd.SetNextStyle(_aec)
	_egec := _gabd.RunProperties()
	_egec.SetBold(true)
}
func (_aee *Document) tables(_gbef *_deg.EG_ContentBlockContent) []Table {
	_befc := []Table{}
	for _, _ggfd := range _gbef.ContentBlockContentChoice.Tbl {
		_befc = append(_befc, Table{_aee, _ggfd})
		for _, _eaf := range _ggfd.EG_ContentRowContent {
			for _, _gfed := range _eaf.ContentRowContentChoice.Tr {
				for _, _acfc := range _gfed.EG_ContentCellContent {
					for _, _agb := range _acfc.ContentCellContentChoice.Tc {
						for _, _ecca := range _agb.EG_BlockLevelElts {
							for _, _eadfg := range _ecca.BlockLevelEltsChoice.EG_ContentBlockContent {
								_befc = append(_befc, _aee.tables(_eadfg)...)
							}
						}
					}
				}
			}
		}
	}
	return _befc
}

// AddImageRef add ImageRef to header as relationship, returning ImageRef
// that can be used to be placed as header content.
func (_acga Header) AddImageRef(r _ee.ImageRef) (_ee.ImageRef, error) {
	var _eaee _ee.Relationships
	for _dgdf, _agcgd := range _acga._efbf._aaad {
		if _agcgd == _acga._efadbc {
			_eaee = _acga._efbf._dgea[_dgdf]
		}
	}
	_efedf := _eaee.AddRelationship(r.Target(), _e.ImageType)
	r.SetRelID(_efedf.X().IdAttr)
	return r, nil
}

// InsertRowAfter inserts a row after another row
func (_eebd Table) InsertRowAfter(r Row) Row {
	for _deac, _fddb := range _eebd._abbae.EG_ContentRowContent {
		if len(_fddb.ContentRowContentChoice.Tr) > 0 && r.X() == _fddb.ContentRowContentChoice.Tr[0] {
			_bcefa := _deg.NewEG_ContentRowContent()
			if len(_eebd._abbae.EG_ContentRowContent) < _deac+2 {
				return _eebd.AddRow()
			}
			_eebd._abbae.EG_ContentRowContent = append(_eebd._abbae.EG_ContentRowContent, nil)
			copy(_eebd._abbae.EG_ContentRowContent[_deac+2:], _eebd._abbae.EG_ContentRowContent[_deac+1:])
			_eebd._abbae.EG_ContentRowContent[_deac+1] = _bcefa
			_gbad := _deg.NewCT_Row()
			_bcefa.ContentRowContentChoice.Tr = append(_bcefa.ContentRowContentChoice.Tr, _gbad)
			return Row{_eebd._dafd, _gbad}
		}
	}
	return _eebd.AddRow()
}

// AnchoredDrawing is an absolutely positioned image within a document page.
type AnchoredDrawing struct {
	_gge *Document
	_bgc *_deg.WdAnchor
}

// Index returns the index of the header within the document.  This is used to
// form its zip packaged filename as well as to match it with its relationship
// ID.
func (_gbbbc Header) Index() int {
	for _bbcb, _bcfff := range _gbbbc._efbf._aaad {
		if _bcfff == _gbbbc._efadbc {
			return _bbcb
		}
	}
	return -1
}

const (
	OnOffValueUnset OnOffValue = iota
	OnOffValueOff
	OnOffValueOn
)

// SetStyle sets style to the text in watermark.
func (_eefcda *WatermarkText) SetStyle(style _bgg.TextpathStyle) {
	_affcb := _eefcda.getShape()
	if _eefcda._cfbf != nil {
		_acfb := _eefcda._cfbf.ShapeChoice
		for _, _ddfacf := range _acfb {
			if _ddfacf.ShapeElementsChoice.Textpath != nil {
				var _edbfe = style.String()
				_ddfacf.ShapeElementsChoice.Textpath.StyleAttr = &_edbfe
			}
		}
		return
	}
	_gbbgf := _eefcda.findNode(_affcb, "\u0074\u0065\u0078\u0074\u0070\u0061\u0074\u0068")
	for _edaf, _abaeg := range _gbbgf.Attrs {
		if _abaeg.Name.Local == "\u0073\u0074\u0079l\u0065" {
			_gbbgf.Attrs[_edaf].Value = style.String()
		}
	}
}
func _fde(_gcbb *_deg.CT_P, _aacb *_deg.CT_Hyperlink, _bdfd *TableInfo, _efed *DrawingInfo, _ageea []*_deg.EG_PContent) []TextItem {
	if len(_ageea) == 0 {
		return []TextItem{TextItem{Text: "", DrawingInfo: _efed, Paragraph: _gcbb, Hyperlink: _aacb, Run: nil, TableInfo: _bdfd}}
	}
	_eedfd := []TextItem{}
	for _, _gdaea := range _ageea {
		for _, _egeg := range _gdaea.PContentChoice.FldSimple {
			if _egeg != nil {
				_eedfd = append(_eedfd, _fde(_gcbb, _aacb, _bdfd, _efed, _egeg.EG_PContent)...)
			}
		}
		if _ffddg := _gdaea.PContentChoice.Hyperlink; _ffddg != nil {
			_eedfd = append(_eedfd, _bafb(_gcbb, _ffddg, _bdfd, _efed, _ffddg.PContentChoice.EG_ContentRunContent)...)
		}
		_eedfd = append(_eedfd, _bafb(_gcbb, nil, _bdfd, _efed, _gdaea.PContentChoice.EG_ContentRunContent)...)
	}
	return _eedfd
}

// ItalicValue returns the precise nature of the italic setting (unset, off or on).
func (_bacb RunProperties) ItalicValue() OnOffValue { return _fdfeb(_bacb._bfed.I) }

// X returns the inner wrapped XML type.
func (_fgde Numbering) X() *_deg.Numbering { return _fgde._gcfa }

// SizeMeasure returns font with its measure which can be mm, cm, in, pt, pc or pi.
func (_dfeab ParagraphProperties) SizeMeasure() string {
	if _adce := _dfeab._adegb.RPr.Sz; _adce != nil {
		_efgg := _adce.ValAttr
		if _efgg.ST_PositiveUniversalMeasure != nil {
			return *_efgg.ST_PositiveUniversalMeasure
		}
	}
	return ""
}

// TableConditionalFormatting controls the conditional formatting within a table
// style.
type TableConditionalFormatting struct{ _ccaae *_deg.CT_TblStylePr }

func _ebdf(_aage _ga.ReaderAt, _bbbe int64, _bdbb string) (*Document, error) {
	const _eceb = "\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0052\u0065\u0061\u0064"
	if !_de.GetLicenseKey().IsLicensed() && !_bed {
		_dd.Println("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065")
		_dd.Println("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
		return nil, _bea.New("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064")
	}
	_ccbe := "\u0075n\u006b\u006e\u006f\u0077\u006e"
	if _abggc, _eacdc := _aage.(*_ea.File); _eacdc {
		_ccbe = _abggc.Name()
	}
	_agff := New()
	_agff.Numbering._gcfa = nil
	if len(_bdbb) > 0 {
		_agff._cfgg = _bdbb
	} else {
		_ecgb, _befg := _de.GenRefId("\u0064\u0072")
		if _befg != nil {
			_gd.Log.Error("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _befg)
			return nil, _befg
		}
		_agff._cfgg = _ecgb
	}
	if _fdcg := _de.Track(_agff._cfgg, _eceb, _ccbe); _fdcg != nil {
		_gd.Log.Error("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _fdcg)
		return nil, _fdcg
	}
	_daba, _egce := _af.TempDir("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065-\u0064\u006f\u0063\u0078")
	if _egce != nil {
		return nil, _egce
	}
	_agff.TmpPath = _daba
	_dfcf, _egce := _fa.NewReader(_aage, _bbbe)
	if _egce != nil {
		return nil, _dd.Errorf("\u0070a\u0072s\u0069\u006e\u0067\u0020\u007a\u0069\u0070\u003a\u0020\u0025\u0073", _egce)
	}
	_cbbd := []*_fa.File{}
	_cbbd = append(_cbbd, _dfcf.File...)
	_gdacf := false
	for _, _aefe := range _cbbd {
		if _aefe.FileHeader.Name == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
			_gdacf = true
			break
		}
	}
	if _gdacf {
		_agff.CreateCustomProperties()
	}
	_eeed := _agff._effc.ConformanceAttr
	_cgcd := _db.DecodeMap{}
	_cgcd.SetOnNewRelationshipFunc(_agff.onNewRelationship)
	_cgcd.AddTarget(_e.ContentTypesFilename, _agff.ContentTypes.X(), "", 0)
	_cgcd.AddTarget(_e.BaseRelsFilename, _agff.Rels.X(), "", 0)
	if _gfbg := _cgcd.Decode(_cbbd); _gfbg != nil {
		return nil, _gfbg
	}
	_agff._effc.ConformanceAttr = _eeed
	for _, _bbdd := range _cbbd {
		if _bbdd == nil {
			continue
		}
		if _aecd := _agff.AddExtraFileFromZip(_bbdd); _aecd != nil {
			return nil, _aecd
		}
	}
	if _gdacf {
		_gggf := false
		for _, _eegc := range _agff.Rels.X().Relationship {
			if _eegc.TargetAttr == "\u0064\u006f\u0063\u0050ro\u0070\u0073\u002f\u0063\u0075\u0073\u0074\u006f\u006d\u002e\u0078\u006d\u006c" {
				_gggf = true
				break
			}
		}
		if !_gggf {
			_agff.AddCustomRelationships()
		}
	}
	return _agff, nil
}

// ComplexSizeMeasure returns font with its measure which can be mm, cm, in, pt, pc or pi.
func (_acgd ParagraphProperties) ComplexSizeMeasure() string {
	if _eeffe := _acgd._adegb.RPr.SzCs; _eeffe != nil {
		_acecc := _eeffe.ValAttr
		if _acecc.ST_PositiveUniversalMeasure != nil {
			return *_acecc.ST_PositiveUniversalMeasure
		}
	}
	return ""
}

// SetTextWrapBehindText sets the text wrap to behind text.
func (_bced AnchoredDrawing) SetTextWrapBehindText() {
	_bced._bgc.WrapTypeChoice = &_deg.WdEG_WrapTypeChoice{}
	_bced._bgc.WrapTypeChoice.WrapNone = _deg.NewWdCT_WrapNone()
	_bced._bgc.BehindDocAttr = true
	_bced._bgc.LayoutInCellAttr = true
	_bced._bgc.AllowOverlapAttr = true
}

// SetWindowControl controls if the first or last line of the paragraph is
// allowed to display on a separate page.
func (_cbgdg ParagraphProperties) SetWindowControl(b bool) {
	if !b {
		_cbgdg._adegb.WidowControl = nil
	} else {
		_cbgdg._adegb.WidowControl = _deg.NewCT_OnOff()
	}
}

// CharacterSpacingValue returns the value of characters spacing in twips (1/20 of point).
func (_bfef ParagraphProperties) CharacterSpacingValue() int64 {
	if _dffbf := _bfef._adegb.RPr.Spacing; _dffbf != nil {
		_agca := _dffbf.ValAttr
		if _agca.Int64 != nil {
			return *_agca.Int64
		}
	}
	return int64(0)
}

// Bookmark is a bookmarked location within a document that can be referenced
// with a hyperlink.
type Bookmark struct{ _ggfb *_deg.CT_Bookmark }

func _cfdc(_aaec *_deg.EG_ContentBlockContent) []Bookmark {
	_begd := []Bookmark{}
	for _, _fac := range _aaec.ContentBlockContentChoice.P {
		for _, _gfgef := range _fac.EG_PContent {
			for _, _eafe := range _gfgef.PContentChoice.EG_ContentRunContent {
				for _, _fdag := range _eafe.ContentRunContentChoice.EG_RunLevelElts {
					for _, _fcac := range _fdag.RunLevelEltsChoice.EG_RangeMarkupElements {
						if _fcac.RangeMarkupElementsChoice.BookmarkStart != nil {
							_begd = append(_begd, Bookmark{_fcac.RangeMarkupElementsChoice.BookmarkStart})
						}
					}
				}
			}
		}
	}
	for _, _cddf := range _aaec.ContentBlockContentChoice.EG_RunLevelElts {
		for _, _ddfac := range _cddf.RunLevelEltsChoice.EG_RangeMarkupElements {
			if _ddfac.RangeMarkupElementsChoice.BookmarkStart != nil {
				_begd = append(_begd, Bookmark{_ddfac.RangeMarkupElementsChoice.BookmarkStart})
			}
		}
	}
	for _, _gacef := range _aaec.ContentBlockContentChoice.Tbl {
		for _, _ebbc := range _gacef.EG_ContentRowContent {
			for _, _fege := range _ebbc.ContentRowContentChoice.Tr {
				for _, _bggfg := range _fege.EG_ContentCellContent {
					for _, _dgbe := range _bggfg.ContentCellContentChoice.Tc {
						for _, _fgad := range _dgbe.EG_BlockLevelElts {
							for _, _gdcfgf := range _fgad.BlockLevelEltsChoice.EG_ContentBlockContent {
								for _, _dfcc := range _cfdc(_gdcfgf) {
									_begd = append(_begd, _dfcc)
								}
							}
						}
					}
				}
			}
		}
	}
	return _begd
}

// AddHTML adds a text that contains HTML tags to a paragraph.
//
// The following tags are supported:
//   - <b> or <strong> for bold text
//   - <i> or <em> for italic text
//   - <u> for underlined text
//   - <strike> for strikethrough text
//   - <mark> for highlighted text
//   - <sub> for subscript text
//   - <sup> for superscript text
func (_ffdb Paragraph) AddHTML(s string) {
	var (
		_affg *htmlNode
		_ccac *Run
	)
	_ebge := _d.NewDecoder(_ag.NewReader([]byte(s)))
	for {
		_cefe, _gfgbb := _ebge.Token()
		if _gfgbb != nil {
			break
		}
		switch _ffaab := _cefe.(type) {
		case _d.StartElement:
			if _ccac != nil && _ccac.Text() != "" {
				if _affg != nil {
					_cfgba := _affg
					for {
						if _cfgba == nil {
							break
						}
						_ddfad(_ccac, _cfgba._gddb.Name.Local, _cfgba)
						_cfgba = _cfgba._aegce
					}
					_gdeb := _ccac.Copy()
					_ccac = &_gdeb
				} else {
					_ccac = nil
				}
			}
			_affg = &htmlNode{_gddb: _ffaab, _aegce: _affg}
		case _d.EndElement:
			if _affg != nil {
				_ddfad(_ccac, _ffaab.Name.Local, _affg)
				_affg = _affg._aegce
				if _affg == nil {
					_ccac = nil
				}
			}
		case _d.CharData:
			if _ccac == nil {
				_dcecf := _ffdb.AddRun()
				_ccac = &_dcecf
			} else if _affg != nil {
				_cdegb := _affg
				for {
					if _cdegb == nil {
						break
					}
					_ddfad(_ccac, _cdegb._gddb.Name.Local, _cdegb)
					_cdegb = _cdegb._aegce
				}
				_bdca := _ffdb.AddRun()
				_ccac = &_bdca
			}
			_ccac.AddText(string(_ffaab))
		}
	}
}

// AddTOC adds a table of contents to the document and customize it according to TOCOptions if necessary.
func (_ecae Run) AddTOC(options *TOCOptions) {
	_ceffa := ""
	if options != nil {
		if options.UseHyperlinks {
			_ceffa += "\u0020\u005c\u0068\u0020"
		}
		if options.OmitPageNumbers {
			_ceffa += "\u0020\u005c\u006e\u0020"
		}
		if options.HeadingLevel != "" {
			_ceffa += "\u0020\u005c\u006f \u0027" + options.HeadingLevel + "\u0027"
		}
	}
	_ecae.AddFieldWithFormatting(FieldTOC, _ceffa, true)
}
func (_efdg *Document) insertImageFromNode(_fcccd Node) {
	for _, _cdcgc := range _fcccd.AnchoredDrawings {
		if _addb, _ebfc := _cdcgc.GetImage(); _ebfc {
			_baca, _agfb := _ee.ImageFromFile(_addb.Path())
			if _agfb != nil {
				_gd.Log.Debug("\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0063r\u0065\u0061\u0074\u0065\u0020\u0069\u006d\u0061\u0067\u0065:\u0020\u0025\u0073", _agfb)
			}
			_dbade, _agfb := _efdg.AddImage(_baca)
			if _agfb != nil {
				_gd.Log.Debug("u\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0061\u0064\u0064\u0020i\u006d\u0061\u0067\u0065\u0020\u0074\u006f \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u003a\u0020%\u0073", _agfb)
			}
			_cada := _efdg._afff.GetByRelId(_dbade.RelID())
			_cada.SetID(_addb.RelID())
		}
	}
	for _, _bgde := range _fcccd.InlineDrawings {
		if _dddd, _feeg := _bgde.GetImage(); _feeg {
			_geacc, _caff := _ee.ImageFromFile(_dddd.Path())
			if _caff != nil {
				_gd.Log.Debug("\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0063r\u0065\u0061\u0074\u0065\u0020\u0069\u006d\u0061\u0067\u0065:\u0020\u0025\u0073", _caff)
			}
			_gbde, _caff := _efdg.AddImage(_geacc)
			if _caff != nil {
				_gd.Log.Debug("u\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0061\u0064\u0064\u0020i\u006d\u0061\u0067\u0065\u0020\u0074\u006f \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u003a\u0020%\u0073", _caff)
			}
			_ccebg := _efdg._afff.GetByRelId(_gbde.RelID())
			_ccebg.SetID(_dddd.RelID())
		}
	}
}

// EastAsiaFont returns the name of paragraph font family for East Asia.
func (_gdbfg ParagraphProperties) EastAsiaFont() string {
	if _eaad := _gdbfg._adegb.RPr.RFonts; _eaad != nil {
		if _eaad.EastAsiaAttr != nil {
			return *_eaad.EastAsiaAttr
		}
	}
	return ""
}

// SetFirstLineIndent controls the indentation of the first line in a paragraph.
func (_ggfa Paragraph) SetFirstLineIndent(m _cdg.Distance) {
	_ggfa.ensurePPr()
	_gggae := _ggfa._bbff.PPr
	if _gggae.Ind == nil {
		_gggae.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_gggae.Ind.FirstLineAttr = nil
	} else {
		_gggae.Ind.FirstLineAttr = &_fae.ST_TwipsMeasure{}
		_gggae.Ind.FirstLineAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _cdg.Twips))
	}
}

// Underline returns the type of paragraph underline.
func (_abbgg ParagraphProperties) Underline() _deg.ST_Underline {
	if _badb := _abbgg._adegb.RPr.U; _badb != nil {
		return _badb.ValAttr
	}
	return 0
}

// SetFirstRow controls the conditional formatting for the first row in a table.
func (_cfba TableLook) SetFirstRow(on bool) {
	if !on {
		_cfba._bfdc.FirstRowAttr = &_fae.ST_OnOff{}
		_cfba._bfdc.FirstRowAttr.ST_OnOff1 = _fae.ST_OnOff1Off
	} else {
		_cfba._bfdc.FirstRowAttr = &_fae.ST_OnOff{}
		_cfba._bfdc.FirstRowAttr.ST_OnOff1 = _fae.ST_OnOff1On
	}
}
func (_gbbbg *Document) getWatermarkHeaderInnerContentPictures() []*_deg.CT_Picture {
	var _fffd []*_deg.CT_Picture
	for _, _fbddc := range _gbbbg.Headers() {
		for _, _aadb := range _fbddc.X().EG_BlockLevelElts {
			for _, _dbeb := range _aadb.BlockLevelEltsChoice.EG_ContentBlockContent {
				for _, _acbe := range _dbeb.ContentBlockContentChoice.P {
					for _, _dagab := range _acbe.EG_PContent {
						for _, _cdgc := range _dagab.PContentChoice.EG_ContentRunContent {
							if _cdgc.ContentRunContentChoice.R == nil {
								continue
							}
							for _, _dcec := range _cdgc.ContentRunContentChoice.R.EG_RunInnerContent {
								if _dcec.RunInnerContentChoice.Pict == nil {
									continue
								}
								_gfedc := false
								for _, _edac := range _dcec.RunInnerContentChoice.Pict.Any {
									_dgdg, _bfabf := _edac.(*_e.XSDAny)
									if _bfabf && _dgdg.XMLName.Local == "\u0073\u0068\u0061p\u0065" {
										_gfedc = true
									}
								}
								if _gfedc {
									_fffd = append(_fffd, _dcec.RunInnerContentChoice.Pict)
								}
							}
						}
					}
				}
			}
		}
	}
	return _fffd
}

// GetText returns text in the watermark.
func (_gbgaa *WatermarkText) GetText() string {
	_eafbg := _gbgaa.getShape()
	if _gbgaa._cfbf != nil {
		_efbd := _gbgaa._cfbf.ShapeChoice
		for _, _gbbed := range _efbd {
			if _gbbed.ShapeElementsChoice.Textpath != nil {
				return *_gbbed.ShapeElementsChoice.Textpath.StringAttr
			}
		}
	} else {
		_ecebgf := _gbgaa.findNode(_eafbg, "\u0074\u0065\u0078\u0074\u0070\u0061\u0074\u0068")
		for _, _eaac := range _ecebgf.Attrs {
			if _eaac.Name.Local == "\u0073\u0074\u0072\u0069\u006e\u0067" {
				return _eaac.Value
			}
		}
	}
	return ""
}
func _fafae() *_dc.Handles {
	_cedgb := _dc.NewHandles()
	_acee := _dc.NewCT_H()
	_bcda := "\u0023\u0030\u002c\u0062\u006f\u0074\u0074\u006f\u006dR\u0069\u0067\u0068\u0074"
	_acee.PositionAttr = &_bcda
	_fgdfee := "\u0036\u0036\u0032\u0039\u002c\u0031\u0034\u0039\u0037\u0031"
	_acee.XrangeAttr = &_fgdfee
	_cedgb.H = []*_dc.CT_H{_acee}
	return _cedgb
}

// Underline returns the type of run underline.
func (_bdbc RunProperties) Underline() _deg.ST_Underline {
	if _fbfca := _bdbc._bfed.U; _fbfca != nil {
		return _fbfca.ValAttr
	}
	return 0
}

// Value returns the string value of a FormFieldTypeText or FormFieldTypeDropDown.
func (_bcfc FormField) Value() string {
	if len(_bcfc._bgcg.FFDataChoice) > 0 {
		for _, _abbb := range _bcfc._bgcg.FFDataChoice {
			if _abbb.TextInput != nil && _bcfc._edda.RunInnerContentChoice.T != nil {
				return _bcfc._edda.RunInnerContentChoice.T.Content
			} else if _abbb.DdList != nil && _abbb.DdList.Result != nil {
				_abaf := _bcfc.PossibleValues()
				_fgaf := int(_abbb.DdList.Result.ValAttr)
				if _fgaf < len(_abaf) {
					return _abaf[_fgaf]
				}
			} else if _abbb.CheckBox != nil {
				if _bcfc.IsChecked() {
					return "\u0074\u0072\u0075\u0065"
				}
				return "\u0066\u0061\u006cs\u0065"
			}
		}
	}
	return ""
}

// NewStyles constructs a new empty Styles
func NewStyles() Styles { return Styles{_deg.NewStyles()} }

// RightToLeft returns true if paragraph text goes from right to left.
func (_adeee ParagraphProperties) RightToLeft() bool { return _dabbe(_adeee._adegb.RPr.Rtl) }

// SetPossibleValues sets possible values for a FormFieldTypeDropDown.
func (_fadg FormField) SetPossibleValues(values []string) {
	if len(_fadg._bgcg.FFDataChoice) > 0 {
		for _, _dbdcd := range _fadg._bgcg.FFDataChoice {
			if _dbdcd.DdList != nil {
				for _, _ecgf := range values {
					_adcbbd := _deg.NewCT_String()
					_adcbbd.ValAttr = _ecgf
					_dbdcd.DdList.ListEntry = append(_dbdcd.DdList.ListEntry, _adcbbd)
				}
			}
		}
	}
}

// RunProperties returns the run style properties.
func (_aeca Style) RunProperties() RunProperties {
	if _aeca._bageg.RPr == nil {
		_aeca._bageg.RPr = _deg.NewCT_RPr()
	}
	return RunProperties{_aeca._bageg.RPr}
}

// Index returns the index of the footer within the document.  This is used to
// form its zip packaged filename as well as to match it with its relationship
// ID.
func (_dfdfe Footer) Index() int {
	for _aedgf, _gfbf := range _dfdfe._abba._bcf {
		if _gfbf == _dfdfe._aabd {
			return _aedgf
		}
	}
	return -1
}
func (_eabgc Document) mergeFields() []mergeFieldInfo {
	_dbcfa := []Paragraph{}
	_gfaee := []mergeFieldInfo{}
	for _, _cdfff := range _eabgc.Tables() {
		for _, _bccd := range _cdfff.Rows() {
			for _, _gabbb := range _bccd.Cells() {
				_dbcfa = append(_dbcfa, _gabbb.Paragraphs()...)
			}
		}
	}
	_dbcfa = append(_dbcfa, _eabgc.Paragraphs()...)
	for _, _bdcfge := range _eabgc.Headers() {
		_dbcfa = append(_dbcfa, _bdcfge.Paragraphs()...)
		for _, _becd := range _bdcfge.Tables() {
			for _, _eagaf := range _becd.Rows() {
				for _, _fecc := range _eagaf.Cells() {
					_dbcfa = append(_dbcfa, _fecc.Paragraphs()...)
				}
			}
		}
	}
	for _, _cfcfg := range _eabgc.Footers() {
		_dbcfa = append(_dbcfa, _cfcfg.Paragraphs()...)
		for _, _gdgfcb := range _cfcfg.Tables() {
			for _, _dcdb := range _gdgfcb.Rows() {
				for _, _cefb := range _dcdb.Cells() {
					_dbcfa = append(_dbcfa, _cefb.Paragraphs()...)
				}
			}
		}
	}
	for _, _bdbed := range _dbcfa {
		_cfdae := _bdbed.Runs()
		_gcgga := -1
		_adga := -1
		_gaff := -1
		_ceged := mergeFieldInfo{}
		for _, _fada := range _bdbed._bbff.EG_PContent {
			for _, _acgf := range _fada.PContentChoice.FldSimple {
				if _ac.Contains(_acgf.InstrAttr, "\u004d\u0045\u0052\u0047\u0045\u0046\u0049\u0045\u004c\u0044") {
					_gceeb := _aagbb(_acgf.InstrAttr)
					_gceeb._eefaee = true
					_gceeb._adeaa = _bdbed
					_gceeb._ffde = _fada
					_gfaee = append(_gfaee, _gceeb)
				}
			}
		}
		for _efgaa := 0; _efgaa < len(_cfdae); _efgaa++ {
			_dcfbb := _cfdae[_efgaa]
			for _, _dgdc := range _dcfbb.X().EG_RunInnerContent {
				if _dgdc.RunInnerContentChoice.FldChar != nil {
					switch _dgdc.RunInnerContentChoice.FldChar.FldCharTypeAttr {
					case _deg.ST_FldCharTypeBegin:
						_gcgga = _efgaa
					case _deg.ST_FldCharTypeSeparate:
						_adga = _efgaa
					case _deg.ST_FldCharTypeEnd:
						_gaff = _efgaa
						if _ceged._bbdde != "" {
							_ceged._adeaa = _bdbed
							_ceged._dcgf = _gcgga
							_ceged._efgf = _gaff
							_ceged._aeee = _adga
							_gfaee = append(_gfaee, _ceged)
						}
						_gcgga = -1
						_adga = -1
						_gaff = -1
						_ceged = mergeFieldInfo{}
					}
				} else if _dgdc.RunInnerContentChoice.InstrText != nil && _ac.Contains(_dgdc.RunInnerContentChoice.InstrText.Content, "\u004d\u0045\u0052\u0047\u0045\u0046\u0049\u0045\u004c\u0044") {
					if _gcgga != -1 && _gaff == -1 {
						_ceged = _aagbb(_dgdc.RunInnerContentChoice.InstrText.Content)
					}
				}
			}
		}
	}
	return _gfaee
}

// ParagraphProperties returns the paragraph properties controlling text formatting within the table.
func (_edccf TableConditionalFormatting) ParagraphProperties() ParagraphStyleProperties {
	if _edccf._ccaae.PPr == nil {
		_edccf._ccaae.PPr = _deg.NewCT_PPrGeneral()
	}
	return ParagraphStyleProperties{_edccf._ccaae.PPr}
}

// GetWrapPathLineTo return wrapPath lineTo value.
func (_cgf AnchorDrawWrapOptions) GetWrapPathLineTo() []*_ad.CT_Point2D { return _cgf._ddf }

// Type returns the type of the field.
func (_fbfde FormField) Type() FormFieldType {
	if len(_fbfde._bgcg.FFDataChoice) == 0 {
		return FormFieldTypeUnknown
	}
	for _, _aebc := range _fbfde._bgcg.FFDataChoice {
		switch {
		case _aebc.TextInput != nil:
			return FormFieldTypeText
		case _aebc.CheckBox != nil:
			return FormFieldTypeCheckBox
		case _aebc.DdList != nil:
			return FormFieldTypeDropDown
		}
	}
	return FormFieldTypeUnknown
}

// ParagraphBorders allows manipulation of borders on a paragraph.
type ParagraphBorders struct {
	_edae  *Document
	_gdbad *_deg.CT_PBdr
}

// X returns the inner wrapped XML type.
func (_afeb Header) X() *_deg.Hdr { return _afeb._efadbc }
func _aege(_eead []*_deg.EG_ContentBlockContent, _deeg *TableInfo) []TextItem {
	_bafdb := []TextItem{}
	for _, _abde := range _eead {
		if _aaacc := _abde.ContentBlockContentChoice.Sdt; _aaacc != nil {
			if _aadgc := _aaacc.SdtContent; _aadgc != nil {
				for _, _bdcd := range _aadgc.EG_ContentBlockContent {
					_bafdb = append(_bafdb, _eabf(_bdcd.ContentBlockContentChoice.P, _deeg, nil)...)
				}
			}
		}
		_bafdb = append(_bafdb, _eabf(_abde.ContentBlockContentChoice.P, _deeg, nil)...)
		for _, _egea := range _abde.ContentBlockContentChoice.Tbl {
			for _egbdc, _dbfgc := range _egea.EG_ContentRowContent {
				for _, _acfdd := range _dbfgc.ContentRowContentChoice.Tr {
					for _abcb, _cebf := range _acfdd.EG_ContentCellContent {
						for _, _cgec := range _cebf.ContentCellContentChoice.Tc {
							_bgfg := &TableInfo{Table: _egea, Row: _acfdd, Cell: _cgec, RowIndex: _egbdc, ColIndex: _abcb}
							for _, _efgdb := range _cgec.EG_BlockLevelElts {
								_bafdb = append(_bafdb, _aege(_efgdb.BlockLevelEltsChoice.EG_ContentBlockContent, _bgfg)...)
							}
						}
					}
				}
			}
		}
	}
	return _bafdb
}
func (_bggda *Document) GetFontBytesByRelId(relID string) ([]byte, error) {
	if relID == "" {
		return nil, nil
	}
	_abbg := _bggda._gdcc.GetTargetByRelId(relID)
	_abbg = "\u0077\u006f\u0072d\u002f" + _abbg
	for _, _bgdc := range _bggda.ExtraFiles {
		if _bgdc.ZipPath == _abbg {
			_ceaae, _efee := _ea.ReadFile(_bgdc.StoragePath)
			if _efee != nil {
				return nil, _dd.Errorf("e\u0072r\u006f\u0072\u0020\u0072\u0065\u0061\u0064\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", _bgdc.StoragePath, _efee)
			}
			return _ceaae, nil
		}
	}
	return nil, _dd.Errorf("\u0066\u006fn\u0074\u0020\u006e\u006f\u0074\u0020\u0066\u006f\u0075\u006e\u0064\u0020\u0069\u006e\u0020\u0073\u0074\u006f\u0072\u0061\u0067\u0065: \u0025\u0073", _abbg)
}
func _bedgd(_cbaf *Document, _gdbb []*_deg.EG_ContentBlockContent, _dbfgf *TableInfo) []Node {
	_ggec := []Node{}
	for _, _cfad := range _gdbb {
		if _ebad := _cfad.ContentBlockContentChoice.Sdt; _ebad != nil {
			if _dbdgf := _ebad.SdtContent; _dbdgf != nil {
				for _, _bede := range _dbdgf.EG_ContentBlockContent {
					_ggec = append(_ggec, _aaadg(_cbaf, _bede.ContentBlockContentChoice.P, _dbfgf, nil)...)
				}
			}
		}
		_ggec = append(_ggec, _aaadg(_cbaf, _cfad.ContentBlockContentChoice.P, _dbfgf, nil)...)
		for _, _eede := range _cfad.ContentBlockContentChoice.Tbl {
			_geaceb := Table{_cbaf, _eede}
			_faee, _ := _cbaf.Styles.SearchStyleById(_geaceb.Style())
			_cbbe := []Node{}
			for _efgdf, _eabfe := range _eede.EG_ContentRowContent {
				for _, _eebc := range _eabfe.ContentRowContentChoice.Tr {
					for _dbdd, _cagd := range _eebc.EG_ContentCellContent {
						for _, _dbfa := range _cagd.ContentCellContentChoice.Tc {
							_gfccc := &TableInfo{Table: _eede, Row: _eebc, Cell: _dbfa, RowIndex: _efgdf, ColIndex: _dbdd}
							for _, _gcbd := range _dbfa.EG_BlockLevelElts {
								_cbbe = append(_cbbe, _bedgd(_cbaf, _gcbd.BlockLevelEltsChoice.EG_ContentBlockContent, _gfccc)...)
							}
						}
					}
				}
			}
			_ggec = append(_ggec, Node{_cdfa: _cbaf, _bbbg: &_geaceb, Style: _faee, Children: _cbbe})
		}
	}
	return _ggec
}

// SetId sets the id of the image.
func (_df AnchoredDrawing) SetId(id uint32) {
	for _, _dab := range _df._bgc.Graphic.GraphicData.Any {
		if _aa, _bce := _dab.(*_gg.Pic); _bce {
			_aa.NvPicPr.CNvPr.IdAttr = id
		}
	}
}

// X returns the inner wrapped XML type.
func (_cgcf Footnote) X() *_deg.CT_FtnEdn { return _cgcf._cfca }
func _eabf(_gcfc []*_deg.CT_P, _fdbf *TableInfo, _ddfde *DrawingInfo) []TextItem {
	_cgdf := []TextItem{}
	for _, _gdgdc := range _gcfc {
		_cgdf = append(_cgdf, _fde(_gdgdc, nil, _fdbf, _ddfde, _gdgdc.EG_PContent)...)
	}
	return _cgdf
}

// SetInsideVertical sets the interior vertical borders to a specified type, color and thickness.
func (_gcdb TableBorders) SetInsideVertical(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_gcdb._cadbb.InsideV = _deg.NewCT_Border()
	_bgdcd(_gcdb._cadbb.InsideV, t, c, thickness)
}

// SetRight sets the right border to a specified type, color and thickness.
func (_dgg CellBorders) SetRight(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_dgg._fba.Right = _deg.NewCT_Border()
	_bgdcd(_dgg._fba.Right, t, c, thickness)
}

// X returns the inner wrapped XML type.
func (_acd Cell) X() *_deg.CT_Tc { return _acd._fdf }

// SetHangingIndent controls the indentation of the non-first lines in a paragraph.
func (_gcfce ParagraphProperties) SetHangingIndent(m _cdg.Distance) {
	if _gcfce._adegb.Ind == nil {
		_gcfce._adegb.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_gcfce._adegb.Ind.HangingAttr = nil
	} else {
		_gcfce._adegb.Ind.HangingAttr = &_fae.ST_TwipsMeasure{}
		_gcfce._adegb.Ind.HangingAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _cdg.Twips))
	}
}

// GetImage returns the ImageRef associated with an AnchoredDrawing.
func (_cg AnchoredDrawing) GetImage() (_ee.ImageRef, bool) {
	_bge := _cg._bgc.Graphic.GraphicData.Any
	if len(_bge) > 0 {
		_bc, _ff := _bge[0].(*_gg.Pic)
		if _ff {
			if _bc.BlipFill != nil && _bc.BlipFill.Blip != nil && _bc.BlipFill.Blip.EmbedAttr != nil {
				return _cg._gge.GetImageByRelID(*_bc.BlipFill.Blip.EmbedAttr)
			}
		}
	}
	return _ee.ImageRef{}, false
}

// BoldValue returns the precise nature of the bold setting (unset, off or on).
func (_gggc RunProperties) BoldValue() OnOffValue { return _fdfeb(_gggc._bfed.B) }
func (_efge Paragraph) addFldCharsForField(_egfa, _gbbgg string) FormField {
	_gagf := _efge.addBeginFldChar(_egfa)
	_cbefb := FormField{_bgcg: _gagf}
	_deege := _efge._eaefb.Bookmarks()
	_aecf := int64(len(_deege))
	if _egfa != "" {
		_efge.addStartBookmark(_aecf, _egfa)
	}
	_efge.addInstrText(_gbbgg)
	_efge.addSeparateFldChar()
	if _gbbgg == "\u0046\u004f\u0052\u004d\u0054\u0045\u0058\u0054" {
		_ebggg := _efge.AddRun()
		_cabd := _deg.NewEG_RunInnerContent()
		_ebggg._gabc.EG_RunInnerContent = []*_deg.EG_RunInnerContent{_cabd}
		_cbefb._edda = _cabd
	}
	_efge.addEndFldChar()
	if _egfa != "" {
		_efge.addEndBookmark(_aecf)
	}
	return _cbefb
}

// DrawingInfo is used for keep information about a drawing wrapping a textbox where the text is located.
type DrawingInfo struct {
	Drawing *_deg.CT_Drawing
	Width   int64
	Height  int64
}

// SetText sets the watermark text.
func (_abcdc *WatermarkText) SetText(text string) {
	_dgab := _abcdc.getShape()
	if _abcdc._cfbf != nil {
		_gfddd := _abcdc._cfbf.ShapeChoice
		for _, _bbefd := range _gfddd {
			if _bbefd.ShapeElementsChoice.Textpath != nil {
				_bbefd.ShapeElementsChoice.Textpath.StringAttr = &text
			}
		}
	} else {
		_affff := _abcdc.findNode(_dgab, "\u0074\u0065\u0078\u0074\u0070\u0061\u0074\u0068")
		for _faaa, _dbcg := range _affff.Attrs {
			if _dbcg.Name.Local == "\u0073\u0074\u0072\u0069\u006e\u0067" {
				_affff.Attrs[_faaa].Value = text
			}
		}
	}
}
func _ddfad(_afce *Run, _ggcb string, _dbfd *htmlNode) {
	switch _ggcb {
	case "\u0062", "\u0073\u0074\u0072\u006f\u006e\u0067":
		_afce.Properties().SetBold(true)
	case "\u0069", "\u0065\u006d":
		_afce.Properties().SetItalic(true)
	case "\u0075":
		_addbf := _bg.Black
		for _, _gcfd := range _dbfd._gddb.Attr {
			if _gcfd.Name.Local == "\u0063\u006f\u006co\u0072" {
				if _dbgdg, _ebaa := _bg.ColorMap[_gcfd.Value]; _ebaa {
					_addbf = _dbgdg
				}
			}
		}
		_afce.Properties().SetUnderline(_deg.ST_UnderlineSingle, _addbf)
	case "\u0073\u0074\u0072\u0069\u006b\u0065":
		_afce.Properties().SetStrikeThrough(true)
	case "\u006d\u0061\u0072\u006b":
		_feef := _deg.ST_HighlightColorYellow
		for _, _afcdeg := range _dbfd._gddb.Attr {
			if _afcdeg.Name.Local == "\u0063\u006f\u006co\u0072" {
				if _defea, _feccg := _bg.HighlightColorMap[_afcdeg.Value]; _feccg {
					_feef = _defea
				}
			}
		}
		_afce.Properties().SetHighlight(_feef)
	case "\u0073\u0075\u0062":
		_afce.Properties().SetVerticalAlignment(_fae.ST_VerticalAlignRunSubscript)
	case "\u0073\u0075\u0070":
		_afce.Properties().SetVerticalAlignment(_fae.ST_VerticalAlignRunSuperscript)
	}
}

// SetName marks sets a name attribute for a FormField.
func (_bbdb FormField) SetName(name string) {
	_fdddg := _deg.NewCT_FFName()
	_fdddg.ValAttr = &name
	_bbdb._bgcg.FFDataChoice = []*_deg.CT_FFDataChoice{{Name: _fdddg}}
}

// SetHighlight highlights text in a specified color.
func (_egbdg RunProperties) SetHighlight(c _deg.ST_HighlightColor) {
	_egbdg._bfed.Highlight = _deg.NewCT_Highlight()
	_egbdg._bfed.Highlight.ValAttr = c
}
func (_ccb *Document) reorderEndnote() {
	_gbaa := int64(1)
	_degfe := map[int64]int64{}
	for _, _efb := range _ccb._ebfb.Endnote {
		switch _efb.TypeAttr {
		case _deg.ST_FtnEdnSeparator:
			_efb.IdAttr = -1
			break
		case _deg.ST_FtnEdnContinuationSeparator:
			_efb.IdAttr = 0
			break
		default:
			_degfe[_efb.IdAttr] = _gbaa
			_efb.IdAttr = _gbaa
			_gbaa++
		}
	}
	for _, _aede := range _ccb.Paragraphs() {
		for _, _fbfd := range _aede.Runs() {
			if _ccba, _agdad := _fbfd.IsEndnote(); _ccba {
				_fbfd.X().EG_RunInnerContent[0].RunInnerContentChoice.EndnoteReference.IdAttr = _degfe[_agdad]
			}
		}
	}
}

// Borders returns the ParagraphBorders for setting-up border on paragraph.
func (_agcfg Paragraph) Borders() ParagraphBorders {
	_agcfg.ensurePPr()
	if _agcfg._bbff.PPr.PBdr == nil {
		_agcfg._bbff.PPr.PBdr = _deg.NewCT_PBdr()
	}
	return ParagraphBorders{_agcfg._eaefb, _agcfg._bbff.PPr.PBdr}
}

// SetBevelImageEffect sets the glow image effect.
func (_ce AnchoredDrawing) SetBevelImageEffect() {
	for _, _bcb := range _ce._bgc.Graphic.GraphicData.Any {
		if _fe, _afe := _bcb.(*_gg.Pic); _afe {
			_fe.SpPr.Sp3d = _ad.NewCT_Shape3D()
			_fe.SpPr.Sp3d.BevelT = _ad.NewCT_Bevel()
			_fe.SpPr.Sp3d.BevelT.PrstAttr = _ad.ST_BevelPresetTypeConvex
			_fe.SpPr.Scene3d = _ad.NewCT_Scene3D()
			_fe.SpPr.Scene3d.Camera = _ad.NewCT_Camera()
			_fe.SpPr.Scene3d.Camera.PrstAttr = _ad.ST_PresetCameraTypeOrthographicFront
			_fe.SpPr.Scene3d.LightRig = _ad.NewCT_LightRig()
			_fe.SpPr.Scene3d.LightRig.RigAttr = _ad.ST_LightRigTypeThreePt
			_fe.SpPr.Scene3d.LightRig.DirAttr = _ad.ST_LightRigDirectionT
		}
	}
}

// UnderlineColor returns the hex color value of paragraph underline.
func (_cgfaa ParagraphProperties) UnderlineColor() string {
	if _dbebd := _cgfaa._adegb.RPr.U; _dbebd != nil {
		_cacg := _dbebd.ColorAttr
		if _cacg != nil && _cacg.ST_HexColorRGB != nil {
			return *_cacg.ST_HexColorRGB
		}
	}
	return ""
}

// Clear clears all content within a header
func (_bgeeg Header) Clear() { _bgeeg._efadbc.EG_BlockLevelElts = []*_deg.EG_BlockLevelElts{} }

const (
	FieldCurrentPage   = "\u0050\u0041\u0047\u0045"
	FieldNumberOfPages = "\u004e\u0055\u004d\u0050\u0041\u0047\u0045\u0053"
	FieldDate          = "\u0044\u0041\u0054\u0045"
	FieldCreateDate    = "\u0043\u0052\u0045\u0041\u0054\u0045\u0044\u0041\u0054\u0045"
	FieldEditTime      = "\u0045\u0044\u0049\u0054\u0054\u0049\u004d\u0045"
	FieldPrintDate     = "\u0050R\u0049\u004e\u0054\u0044\u0041\u0054E"
	FieldSaveDate      = "\u0053\u0041\u0056\u0045\u0044\u0041\u0054\u0045"
	FieldTIme          = "\u0054\u0049\u004d\u0045"
	FieldTOC           = "\u0054\u004f\u0043"
)

// Tables returns the tables defined in the header.
func (_ecdf Header) Tables() []Table {
	_fbfc := []Table{}
	if _ecdf._efadbc == nil {
		return nil
	}
	for _, _fbea := range _ecdf._efadbc.EG_BlockLevelElts {
		for _, _gdgbd := range _fbea.BlockLevelEltsChoice.EG_ContentBlockContent {
			_fbfc = append(_fbfc, _ecdf._efbf.tables(_gdgbd)...)
		}
	}
	return _fbfc
}

// StructuredDocumentTags returns the structured document tags in the document
// which are commonly used in document templates.
func (_eca *Document) StructuredDocumentTags() []StructuredDocumentTag {
	_dbfg := []StructuredDocumentTag{}
	for _, _ecg := range _eca._effc.Body.EG_BlockLevelElts {
		for _, _acaa := range _ecg.BlockLevelEltsChoice.EG_ContentBlockContent {
			if _acaa.ContentBlockContentChoice.Sdt != nil {
				_dbfg = append(_dbfg, StructuredDocumentTag{_eca, _acaa.ContentBlockContentChoice.Sdt})
			}
		}
	}
	return _dbfg
}
func (_fcgf Footnote) content() []*_deg.EG_ContentBlockContent {
	var _ebba []*_deg.EG_ContentBlockContent
	for _, _ecff := range _fcgf._cfca.EG_BlockLevelElts {
		_ebba = append(_ebba, _ecff.BlockLevelEltsChoice.EG_ContentBlockContent...)
	}
	return _ebba
}

// Properties returns the paragraph properties.
func (_efedd Paragraph) Properties() ParagraphProperties {
	_efedd.ensurePPr()
	return ParagraphProperties{_efedd._eaefb, _efedd._bbff.PPr}
}

// SetStyle sets the style of a paragraph and is identical to setting it on the
// paragraph's Properties()
func (_bega Paragraph) SetStyle(s string) {
	_bega.ensurePPr()
	if s == "" {
		_bega._bbff.PPr.PStyle = nil
	} else {
		_bega._bbff.PPr.PStyle = _deg.NewCT_String()
		_bega._bbff.PPr.PStyle.ValAttr = s
	}
}
func (_bagd *Document) putNode(_ecbbba, _gccg Node, _gffb bool) bool {
	_bagd.insertImageFromNode(_gccg)
	_bagd.insertStyleFromNode(_gccg)
	switch _ggdga := _gccg._bbbg.(type) {
	case *Paragraph:
		if _aggc, _ddbdb := _ecbbba.X().(*Paragraph); _ddbdb {
			_bagd.appendParagraph(_aggc, *_ggdga, _gffb)
			return true
		} else {
			for _, _bagfg := range _ecbbba.Children {
				if _gdfd := _bagd.putNode(_bagfg, _gccg, _gffb); _gdfd {
					break
				}
			}
		}
	case *Table:
		if _gbae, _fefe := _ecbbba.X().(*Paragraph); _fefe {
			_fgedd := _bagd.appendTable(_gbae, *_ggdga, _gffb)
			_fgedd._abbae = _ggdga._abbae
			return true
		} else {
			for _, _defe := range _ecbbba.Children {
				if _bbgd := _bagd.putNode(_defe, _gccg, _gffb); _bbgd {
					break
				}
			}
		}
	}
	return false
}
func _egeb(_cbgc *_deg.CT_P, _daeb map[string]string) {
	for _, _egffa := range _cbgc.EG_PContent {
		for _, _aabc := range _egffa.PContentChoice.EG_ContentRunContent {
			if _aabc.ContentRunContentChoice.R != nil {
				for _, _dafg := range _aabc.ContentRunContentChoice.R.EG_RunInnerContent {
					_eeaaf := _dafg.RunInnerContentChoice.Drawing
					if _eeaaf != nil {
						for _, _dafb := range _eeaaf.DrawingChoice {
							if _dafb.Anchor != nil {
								_ffca := _dafb.Anchor
								for _, _bcaac := range _ffca.Graphic.GraphicData.Any {
									switch _becc := _bcaac.(type) {
									case *_gg.Pic:
										if _becc.BlipFill != nil && _becc.BlipFill.Blip != nil {
											_befca(_becc.BlipFill.Blip, _daeb)
										}
									default:
									}
								}
							}
							if _dafb.Inline != nil {
								_agdg := _dafb.Inline
								for _, _ddadc := range _agdg.Graphic.GraphicData.Any {
									switch _abfc := _ddadc.(type) {
									case *_gg.Pic:
										if _abfc.BlipFill != nil && _abfc.BlipFill.Blip != nil {
											_befca(_abfc.BlipFill.Blip, _daeb)
										}
									default:
									}
								}
							}
						}
					}
				}
			}
		}
	}
}

// SetTextWrapNone unsets text wrapping so the image can float on top of the
// text. When used in conjunction with X/Y Offset relative to the page it can be
// used to place a logo at the top of a page at an absolute position that
// doesn't interfere with text.
func (_efe AnchoredDrawing) SetTextWrapNone() {
	_efe._bgc.WrapTypeChoice = &_deg.WdEG_WrapTypeChoice{}
	_efe._bgc.WrapTypeChoice.WrapNone = _deg.NewWdCT_WrapNone()
}

// SetTextStyleBold sets text style of watermark to bold.
func (_bbdg *WatermarkText) SetTextStyleBold(value bool) {
	_gece := _bbdg.GetStyle()
	_gece.SetBold(value)
	_bbdg.SetStyle(_gece)
}

// SetInsideVertical sets the interior vertical borders to a specified type, color and thickness.
func (_eba CellBorders) SetInsideVertical(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_eba._fba.InsideV = _deg.NewCT_Border()
	_bgdcd(_eba._fba.InsideV, t, c, thickness)
}

// Fonts allows manipulating a style or run's fonts.
type Fonts struct{ _gddaa *_deg.CT_Fonts }

// X return slice of node.
func (_fadca *Nodes) X() []Node { return _fadca._aebcgc }
func _aagbb(_cbeba string) mergeFieldInfo {
	_afbg := []string{}
	_dccb := _ag.Buffer{}
	_cegdd := -1
	for _cggc, _baeb := range _cbeba {
		switch _baeb {
		case ' ':
			if _dccb.Len() != 0 {
				_afbg = append(_afbg, _dccb.String())
			}
			_dccb.Reset()
		case '"':
			if _cegdd != -1 {
				_afbg = append(_afbg, _cbeba[_cegdd+1:_cggc])
				_cegdd = -1
			} else {
				_cegdd = _cggc
			}
		default:
			_dccb.WriteRune(_baeb)
		}
	}
	if _dccb.Len() != 0 {
		_afbg = append(_afbg, _dccb.String())
	}
	_adbd := mergeFieldInfo{}
	for _edfdf := 0; _edfdf < len(_afbg)-1; _edfdf++ {
		_gedbd := _afbg[_edfdf]
		switch _gedbd {
		case "\u004d\u0045\u0052\u0047\u0045\u0046\u0049\u0045\u004c\u0044":
			_adbd._bbdde = _afbg[_edfdf+1]
			_edfdf++
		case "\u005c\u0066":
			_adbd._dgfff = _afbg[_edfdf+1]
			_edfdf++
		case "\u005c\u0062":
			_adbd._daff = _afbg[_edfdf+1]
			_edfdf++
		case "\u005c\u002a":
			switch _afbg[_edfdf+1] {
			case "\u0055\u0070\u0070e\u0072":
				_adbd._fbfcg = true
			case "\u004c\u006f\u0077e\u0072":
				_adbd._acge = true
			case "\u0043\u0061\u0070\u0073":
				_adbd._gcce = true
			case "\u0046\u0069\u0072\u0073\u0074\u0043\u0061\u0070":
				_adbd._aagab = true
			}
			_edfdf++
		}
	}
	return _adbd
}

// Strike returns true if paragraph is striked.
func (_abad ParagraphProperties) Strike() bool { return _dabbe(_abad._adegb.RPr.Strike) }

// SetThemeColor sets the color from the theme.
func (_bdeg Color) SetThemeColor(t _deg.ST_ThemeColor) { _bdeg._dbb.ThemeColorAttr = t }

// SetWrapPathStart sets wrapPath start value.
func (_bfb AnchorDrawWrapOptions) SetWrapPathStart(coordinate *_ad.CT_Point2D) {
	_bfb._bad = coordinate
}
func (_gcfg *chart) Target() string { return _gcfg._bgag }

// ExtractTextOptions extraction text options.
type ExtractTextOptions struct {

	// WithNumbering extract numbering elements if set to `true`.
	WithNumbering bool

	// NumberingIndent default value of numbering indent.
	NumberingIndent string

	// RunsOnNewLine write each of runs text on new line if set to `true`.
	RunsOnNewLine bool
}

func (_gddca *Document) insertStyleFromNode(_fgbad Node) {
	if _fgbad.Style.X() != nil {
		if _, _gcec := _gddca.Styles.SearchStyleById(_fgbad.Style.StyleID()); !_gcec {
			_gddca.Styles.InsertStyle(_fgbad.Style)
			_fagd := _fgbad.Style.ParagraphProperties()
			_gddca.insertNumberingFromStyleProperties(_fgbad._cdfa.Numbering, _fagd)
		}
	}
}

// AddDrawingInline adds an inline drawing from an ImageRef.
func (_cefbb Run) AddDrawingInline(img _ee.ImageRef) (InlineDrawing, error) {
	_bfaef := _cefbb.newIC()
	_bfaef.RunInnerContentChoice.Drawing = _deg.NewCT_Drawing()
	_dagaec := _deg.NewWdInline()
	_decc := InlineDrawing{_cefbb._fced, _dagaec}
	_dagaec.CNvGraphicFramePr = _ad.NewCT_NonVisualGraphicFrameProperties()
	_bfaef.RunInnerContentChoice.Drawing.DrawingChoice = append(_bfaef.RunInnerContentChoice.Drawing.DrawingChoice, &_deg.CT_DrawingChoice{Inline: _dagaec})
	_dagaec.Graphic = _ad.NewGraphic()
	_dagaec.Graphic.GraphicData = _ad.NewCT_GraphicalObjectData()
	_dagaec.Graphic.GraphicData.UriAttr = "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006frg\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006d\u006c\u002f\u0032\u0030\u0030\u0036\u002f\u0070\u0069\u0063\u0074\u0075\u0072\u0065"
	_dagaec.DistTAttr = _e.Uint32(0)
	_dagaec.DistLAttr = _e.Uint32(0)
	_dagaec.DistBAttr = _e.Uint32(0)
	_dagaec.DistRAttr = _e.Uint32(0)
	_dagaec.Extent.CxAttr = int64(float64(img.Size().X*_cdg.Pixel72) / _cdg.EMU)
	_dagaec.Extent.CyAttr = int64(float64(img.Size().Y*_cdg.Pixel72) / _cdg.EMU)
	_agde := 0x7FFFFFFF & _gc.Uint32()
	_dagaec.DocPr.IdAttr = _agde
	_cbcf := _gg.NewPic()
	_cbcf.NvPicPr.CNvPr.IdAttr = _agde
	_ggbed := img.RelID()
	if _ggbed == "" {
		return _decc, _bea.New("\u0063\u006f\u0075\u006c\u0064\u006e\u0027\u0074\u0020\u0066\u0069\u006e\u0064\u0020\u0072\u0065\u0066\u0065\u0072\u0065n\u0063\u0065\u0020\u0074\u006f\u0020\u0069\u006d\u0061g\u0065\u0020\u0077\u0069\u0074\u0068\u0069\u006e\u0020\u0064\u006f\u0063\u0075m\u0065\u006e\u0074\u0020\u0072\u0065l\u0061\u0074\u0069o\u006e\u0073")
	}
	_dagaec.Graphic.GraphicData.Any = append(_dagaec.Graphic.GraphicData.Any, _cbcf)
	_cbcf.BlipFill = _ad.NewCT_BlipFillProperties()
	_cbcf.BlipFill.Blip = _ad.NewCT_Blip()
	_cbcf.BlipFill.Blip.EmbedAttr = &_ggbed
	_cbcf.BlipFill.FillModePropertiesChoice.Stretch = _ad.NewCT_StretchInfoProperties()
	_cbcf.BlipFill.FillModePropertiesChoice.Stretch.FillRect = _ad.NewCT_RelativeRect()
	_cbcf.SpPr = _ad.NewCT_ShapeProperties()
	_cbcf.SpPr.Xfrm = _ad.NewCT_Transform2D()
	_cbcf.SpPr.Xfrm.Off = _ad.NewCT_Point2D()
	_cbcf.SpPr.Xfrm.Off.XAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_cbcf.SpPr.Xfrm.Off.YAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_cbcf.SpPr.Xfrm.Ext = _ad.NewCT_PositiveSize2D()
	_cbcf.SpPr.Xfrm.Ext.CxAttr = int64(img.Size().X * _cdg.Point)
	_cbcf.SpPr.Xfrm.Ext.CyAttr = int64(img.Size().Y * _cdg.Point)
	_cbcf.SpPr.GeometryChoice.PrstGeom = _ad.NewCT_PresetGeometry2D()
	_cbcf.SpPr.GeometryChoice.PrstGeom.PrstAttr = _ad.ST_ShapeTypeRect
	return _decc, nil
}

// Copy returns a copy of the run.
func (_ceeb Run) Copy() Run {
	_fcgd := _deg.NewCT_R()
	_eecef := *_ceeb._gabc.RPr
	_fcgd.RPr = &_eecef
	for _, _eefb := range _ceeb._gabc.EG_RunInnerContent {
		_egecg := _deg.NewEG_RunInnerContent()
		if _eefb.RunInnerContentChoice.T != nil {
			_egecg.RunInnerContentChoice.T = &_deg.CT_Text{Content: _eefb.RunInnerContentChoice.T.Content, SpaceAttr: _eefb.RunInnerContentChoice.T.SpaceAttr}
		}
		_fcgd.EG_RunInnerContent = append(_fcgd.EG_RunInnerContent, _egecg)
	}
	return Run{_fced: _ceeb._fced, _gabc: _fcgd}
}
func (_ffe AnchoredDrawing) setEffectExtent(_bcc, _gaf, _agg, _bdd int64) {
	if _ffe._bgc.EffectExtent == nil {
		_ffe._bgc.EffectExtent = _deg.NewWdCT_EffectExtent()
	} else {
		_bcc += *_ffe._bgc.EffectExtent.BAttr.ST_CoordinateUnqualified
		_gaf += *_ffe._bgc.EffectExtent.TAttr.ST_CoordinateUnqualified
		_agg += *_ffe._bgc.EffectExtent.LAttr.ST_CoordinateUnqualified
		_bdd += *_ffe._bgc.EffectExtent.RAttr.ST_CoordinateUnqualified
	}
	_ffe._bgc.EffectExtent.BAttr = _ad.ST_Coordinate{ST_CoordinateUnqualified: &_bcc}
	_ffe._bgc.EffectExtent.TAttr = _ad.ST_Coordinate{ST_CoordinateUnqualified: &_gaf}
	_ffe._bgc.EffectExtent.LAttr = _ad.ST_Coordinate{ST_CoordinateUnqualified: &_agg}
	_ffe._bgc.EffectExtent.RAttr = _ad.ST_Coordinate{ST_CoordinateUnqualified: &_bdd}
}

// Properties returns the row properties.
func (_egeca Row) Properties() RowProperties {
	if _egeca._ebcb.TrPr == nil {
		_egeca._ebcb.TrPr = _deg.NewCT_TrPr()
	}
	return RowProperties{_egeca._ebcb.TrPr}
}
func (_ccge *Document) validateBookmarks() error {
	_aedg := make(map[string]struct{})
	for _, _beda := range _ccge.Bookmarks() {
		if _, _affc := _aedg[_beda.Name()]; _affc {
			return _dd.Errorf("d\u0075\u0070\u006c\u0069\u0063\u0061t\u0065\u0020\u0062\u006f\u006f\u006b\u006d\u0061\u0072k\u0020\u0025\u0073 \u0066o\u0075\u006e\u0064", _beda.Name())
		}
		_aedg[_beda.Name()] = struct{}{}
	}
	return nil
}
func (_eefa AnchoredDrawing) initializeEffectList(_cfg *_ad.CT_ShapeProperties) {
	if _cfg.EffectPropertiesChoice == nil {
		_cfg.EffectPropertiesChoice = _ad.NewEG_EffectPropertiesChoice()
	}
	if _cfg.EffectPropertiesChoice.EffectLst == nil {
		_cfg.EffectPropertiesChoice.EffectLst = _ad.NewCT_EffectList()
	}
}

// InitializeDefault constructs the default styles.
func (_eegcc Styles) InitializeDefault() {
	_eegcc.initializeDocDefaults()
	_eegcc.initializeStyleDefaults()
}

// RemoveParagraph removes a paragraph from a footer.
func (_fgfb Footer) RemoveParagraph(p Paragraph) {
	for _, _dgcb := range _fgfb._aabd.EG_BlockLevelElts {
		for _, _cdeg := range _dgcb.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _ffae, _cdgaf := range _cdeg.ContentBlockContentChoice.P {
				if _cdgaf == p._bbff {
					copy(_cdeg.ContentBlockContentChoice.P[_ffae:], _cdeg.ContentBlockContentChoice.P[_ffae+1:])
					_cdeg.ContentBlockContentChoice.P = _cdeg.ContentBlockContentChoice.P[0 : len(_cdeg.ContentBlockContentChoice.P)-1]
					return
				}
			}
		}
	}
}

// SetAlignment sets the paragraph alignment
func (_gaef NumberingLevel) SetAlignment(j _deg.ST_Jc) {
	if j == _deg.ST_JcUnset {
		_gaef._cdgg.LvlJc = nil
	} else {
		_gaef._cdgg.LvlJc = _deg.NewCT_Jc()
		_gaef._cdgg.LvlJc.ValAttr = j
	}
}
func (_aeed *Document) reorderFootnote() {
	_cffed := int64(1)
	_bbaf := map[int64]int64{}
	for _, _gabg := range _aeed._daaf.Footnote {
		switch _gabg.TypeAttr {
		case _deg.ST_FtnEdnSeparator:
			_gabg.IdAttr = -1
			break
		case _deg.ST_FtnEdnContinuationSeparator:
			_gabg.IdAttr = 0
			break
		default:
			_bbaf[_gabg.IdAttr] = _cffed
			_gabg.IdAttr = _cffed
			_cffed++
		}
	}
	for _, _eafb := range _aeed.Paragraphs() {
		for _, _gdd := range _eafb.Runs() {
			if _cad, _abg := _gdd.IsFootnote(); _cad {
				_gdd.X().EG_RunInnerContent[0].RunInnerContentChoice.FootnoteReference.IdAttr = _bbaf[_abg]
			}
		}
	}
}

// SetBorder sets the border of anchor.
func (_acb AnchoredDrawing) SetBorder(borderType _ad.ST_PresetLineDashVal, c _bg.Color, thickness _cdg.Distance) {
	_bac := _cdg.ToEMU(float64(thickness))
	for _, _ebf := range _acb._bgc.Graphic.GraphicData.Any {
		if _eac, _fca := _ebf.(*_gg.Pic); _fca {
			_eac.SpPr.Ln = _ad.NewCT_LineProperties()
			_eac.SpPr.Ln.WAttr = _e.Int32(int32(_bac))
			_eac.SpPr.Ln.LineDashPropertiesChoice = _ad.NewEG_LineDashPropertiesChoice()
			_eac.SpPr.Ln.LineDashPropertiesChoice.PrstDash = _ad.NewCT_PresetLineDashProperties()
			_eac.SpPr.Ln.LineDashPropertiesChoice.PrstDash.ValAttr = borderType
			_eac.SpPr.Ln.LineFillPropertiesChoice = _ad.NewEG_LineFillPropertiesChoice()
			_eac.SpPr.Ln.LineFillPropertiesChoice.SolidFill = _ad.NewCT_SolidColorFillProperties()
			_eac.SpPr.Ln.LineFillPropertiesChoice.SolidFill.SrgbClr = _ad.NewCT_SRgbColor()
			_eac.SpPr.Ln.LineFillPropertiesChoice.SolidFill.SrgbClr.ValAttr = *c.AsRGBString()
		}
	}
	_acb.setEffectExtent(_bac, _bac, _bac, _bac)
}

// DoubleStrike returns true if run is double striked.
func (_cebb RunProperties) DoubleStrike() bool { return _dabbe(_cebb._bfed.Dstrike) }

// SetFirstLineIndent controls the indentation of the first line in a paragraph.
func (_feec ParagraphProperties) SetFirstLineIndent(m _cdg.Distance) {
	if _feec._adegb.Ind == nil {
		_feec._adegb.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_feec._adegb.Ind.FirstLineAttr = nil
	} else {
		_feec._adegb.Ind.FirstLineAttr = &_fae.ST_TwipsMeasure{}
		_feec._adegb.Ind.FirstLineAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _cdg.Twips))
	}
}

// AppendNode append node to document element.
func (_cbbaa *Document) AppendNode(node Node) {
	_cbbaa.insertImageFromNode(node)
	_cbbaa.insertStyleFromNode(node)
	for _, _ggda := range node.Children {
		_cbbaa.insertImageFromNode(_ggda)
		_cbbaa.insertStyleFromNode(_ggda)
	}
	switch _eedgd := node.X().(type) {
	case *Paragraph:
		_cbbaa.appendParagraph(nil, *_eedgd, false)
	case *Table:
		_cbbaa.appendTable(nil, *_eedgd, false)
	}
	if node._cdfa != nil {
		if node._cdfa._dgb != nil {
			if _aeeab := _cbbaa._afff.FindRIDForN(0, _e.ThemeType); _aeeab == "" {
				if _gagg := node._cdfa._afff.FindRIDForN(0, _e.ThemeType); _gagg != "" {
					_cbbaa._dgb = append(_cbbaa._dgb, node._cdfa._dgb...)
					_gaec := node._cdfa._afff.GetTargetByRelId(_gagg)
					_cbbaa.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072\u0064\u002f"+_gaec, "\u0061\u0070\u0070\u006c\u0069\u0063\u0061t\u0069\u006f\u006e/\u0076\u006e\u0064.\u006f\u0070e\u006e\u0078\u006d\u006c\u0066\u006fr\u006dat\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0074\u0068\u0065\u006d\u0065\u002b\u0078\u006d\u006c")
					_cbbaa._afff.AddRelationship(_gaec, _e.ThemeType)
				}
			}
		}
		_fbbd := _cbbaa._ffea
		_ceded := node._cdfa._ffea
		if _fbbd != nil {
			if _ceded != nil {
				if _fbbd.Font != nil {
					if _ceded.Font != nil {
						for _, _bbab := range _ceded.Font {
							_geede := true
							for _, _egcee := range _fbbd.Font {
								if _egcee.NameAttr == _bbab.NameAttr {
									_geede = false
									break
								}
							}
							if _geede {
								_fbbd.Font = append(_fbbd.Font, _bbab)
							}
						}
					}
				} else {
					_fbbd.Font = _ceded.Font
				}
			}
		} else if _ceded != nil {
			_fbbd = _ceded
		}
		_cbbaa._ffea = _fbbd
		if _gdbc := _cbbaa._afff.FindRIDForN(0, _e.FontTableType); _gdbc == "" {
			_cbbaa.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072d/\u0066\u006f\u006e\u0074\u0054\u0061\u0062\u006c\u0065\u002e\u0078\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002f\u0076n\u0064\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063e\u0073\u0073\u0069\u006e\u0067\u006d\u006c\u002e\u0066\u006f\u006e\u0074T\u0061\u0062\u006c\u0065\u002b\u0078m\u006c")
			_cbbaa._afff.AddRelationship("\u0066\u006f\u006e\u0074\u0054\u0061\u0062\u006c\u0065\u002e\u0078\u006d\u006c", _e.FontTableType)
		}
	}
}

// AddTabStop adds a tab stop to the paragraph.
func (_ecdb ParagraphStyleProperties) AddTabStop(position _cdg.Distance, justificaton _deg.ST_TabJc, leader _deg.ST_TabTlc) {
	if _ecdb._dgebc.Tabs == nil {
		_ecdb._dgebc.Tabs = _deg.NewCT_Tabs()
	}
	_bddg := _deg.NewCT_TabStop()
	_bddg.LeaderAttr = leader
	_bddg.ValAttr = justificaton
	_bddg.PosAttr.Int64 = _e.Int64(int64(position / _cdg.Twips))
	_ecdb._dgebc.Tabs.Tab = append(_ecdb._dgebc.Tabs.Tab, _bddg)
}

// ParagraphProperties are the properties for a paragraph.
type ParagraphProperties struct {
	_agcfge *Document
	_adegb  *_deg.CT_PPr
}

// SetName sets the name of the image, visible in the properties of the image
// within Word.
func (_dbe AnchoredDrawing) SetName(name string) {
	_dbe._bgc.DocPr.NameAttr = name
	for _, _adc := range _dbe._bgc.Graphic.GraphicData.Any {
		if _eb, _dbf := _adc.(*_gg.Pic); _dbf {
			_eb.NvPicPr.CNvPr.DescrAttr = _e.String(name)
		}
	}
}

// Pict returns the pict object.
func (_ffcde *WatermarkText) Pict() *_deg.CT_Picture { return _ffcde._deegd }

// AddCell adds a cell to a row and returns it
func (_cgaf Row) AddCell() Cell {
	_afbaa := _deg.NewEG_ContentCellContent()
	_cgaf._ebcb.EG_ContentCellContent = append(_cgaf._ebcb.EG_ContentCellContent, _afbaa)
	_fece := _deg.NewCT_Tc()
	_afbaa.ContentCellContentChoice.Tc = append(_afbaa.ContentCellContentChoice.Tc, _fece)
	return Cell{_cgaf._bace, _fece}
}

// Validate validates the structure and in cases where it't possible, the ranges
// of elements within a document. A validation error dones't mean that the
// document won't work in MS Word or LibreOffice, but it's worth checking into.
func (_ccgf *Document) Validate() error {
	if _ccgf == nil || _ccgf._effc == nil {
		return _bea.New("\u0064o\u0063\u0075m\u0065\u006e\u0074\u0020n\u006f\u0074\u0020i\u006e\u0069\u0074\u0069\u0061\u006c\u0069\u007a\u0065d \u0063\u006f\u0072r\u0065\u0063t\u006c\u0079\u002c\u0020\u006e\u0069l\u0020\u0062a\u0073\u0065")
	}
	for _, _dfe := range []func() error{_ccgf.validateTableCells, _ccgf.validateBookmarks} {
		if _gcee := _dfe(); _gcee != nil {
			return _gcee
		}
	}
	if _egcg := _ccgf._effc.Validate(); _egcg != nil {
		return _egcg
	}
	return nil
}

// SetCellSpacingAuto sets the cell spacing within a table to automatic.
func (_efcb TableProperties) SetCellSpacingAuto() {
	_efcb._gafba.TblCellSpacing = _deg.NewCT_TblWidth()
	_efcb._gafba.TblCellSpacing.TypeAttr = _deg.ST_TblWidthAuto
}

// Font returns the name of run font family.
func (_dagd RunProperties) Font() string {
	if _cece := _dagd._bfed.RFonts; _cece != nil {
		if _cece.AsciiAttr != nil {
			return *_cece.AsciiAttr
		} else if _cece.HAnsiAttr != nil {
			return *_cece.HAnsiAttr
		} else if _cece.CsAttr != nil {
			return *_cece.CsAttr
		}
	}
	return ""
}

// AddWatermarkPicture adds new watermark picture to document.
func (_aaab *Document) AddWatermarkPicture(imageRef _ee.ImageRef) WatermarkPicture {
	var _ccgc []Header
	if _aagb, _bfabb := _aaab.BodySection().GetHeader(_deg.ST_HdrFtrDefault); _bfabb {
		_ccgc = append(_ccgc, _aagb)
	}
	if _beea, _dfaf := _aaab.BodySection().GetHeader(_deg.ST_HdrFtrEven); _dfaf {
		_ccgc = append(_ccgc, _beea)
	}
	if _cbgg, _aafb := _aaab.BodySection().GetHeader(_deg.ST_HdrFtrFirst); _aafb {
		_ccgc = append(_ccgc, _cbgg)
	}
	if len(_ccgc) < 1 {
		_gaga := _aaab.AddHeader()
		_aaab.BodySection().SetHeader(_gaga, _deg.ST_HdrFtrDefault)
		_ccgc = append(_ccgc, _gaga)
	}
	var _ccced error
	_ddcb := NewWatermarkPicture()
	for _, _bggd := range _ccgc {
		imageRef, _ccced = _bggd.AddImageRef(imageRef)
		if _ccced != nil {
			return WatermarkPicture{}
		}
		_cede := _bggd.Paragraphs()
		if len(_cede) < 1 {
			_efbc := _bggd.AddParagraph()
			_efbc.AddRun().AddText("")
		}
		for _, _gbbb := range _bggd.X().EG_BlockLevelElts {
			for _, _bagf := range _gbbb.BlockLevelEltsChoice.EG_ContentBlockContent {
				for _, _cgdb := range _bagf.ContentBlockContentChoice.P {
					for _, _bfgb := range _cgdb.EG_PContent {
						for _, _gfffb := range _bfgb.PContentChoice.EG_ContentRunContent {
							if _gfffb.ContentRunContentChoice.R == nil {
								continue
							}
							_gfffb.ContentRunContentChoice.R.EG_RunInnerContent = append(_gfffb.ContentRunContentChoice.R.EG_RunInnerContent, &_deg.EG_RunInnerContent{RunInnerContentChoice: &_deg.EG_RunInnerContentChoice{Pict: _ddcb._dbece}})
						}
					}
				}
			}
		}
	}
	_ddcb.SetPicture(imageRef)
	return _ddcb
}

// GetSize return the size of anchor on the page.
func (_gb AnchoredDrawing) GetSize() (_gcg, _daa int64) {
	return _gb._bgc.Extent.CxAttr, _gb._bgc.Extent.CyAttr
}

// IsItalic returns true if the run has been set to italics.
func (_aaef RunProperties) IsItalic() bool { return _aaef.ItalicValue() == OnOffValueOn }

// Strike returns true if run is striked.
func (_aecc RunProperties) Strike() bool { return _dabbe(_aecc._bfed.Strike) }

// SetAlignment sets the alignment of a table within the page.
func (_eeefb TableProperties) SetAlignment(align _deg.ST_JcTable) {
	if align == _deg.ST_JcTableUnset {
		_eeefb._gafba.Jc = nil
	} else {
		_eeefb._gafba.Jc = _deg.NewCT_JcTable()
		_eeefb._gafba.Jc.ValAttr = align
	}
}

// X returns the inner wrapped XML type.
func (_dcefb Footer) X() *_deg.Ftr { return _dcefb._aabd }

// SetPageBreakBefore controls if there is a page break before this paragraph.
func (_affd ParagraphProperties) SetPageBreakBefore(b bool) {
	if !b {
		_affd._adegb.PageBreakBefore = nil
	} else {
		_affd._adegb.PageBreakBefore = _deg.NewCT_OnOff()
	}
}

// Text returns the underlying text in the run.
func (_caab Run) Text() string {
	if len(_caab._gabc.EG_RunInnerContent) == 0 {
		return ""
	}
	_ccfcf := _ag.Buffer{}
	for _, _cecdf := range _caab._gabc.EG_RunInnerContent {
		if _cecdf.RunInnerContentChoice.T != nil {
			_ccfcf.WriteString(_cecdf.RunInnerContentChoice.T.Content)
		}
		if _cecdf.RunInnerContentChoice.Tab != nil {
			_ccfcf.WriteByte('\t')
		}
	}
	return _ccfcf.String()
}

// AddDrawingAnchored adds an anchored (floating) drawing from an ImageRef.
func (_cedc Run) AddDrawingAnchored(img _ee.ImageRef) (AnchoredDrawing, error) {
	_effd := _cedc.newIC()
	_effd.RunInnerContentChoice.Drawing = _deg.NewCT_Drawing()
	_dage := _deg.NewWdAnchor()
	_afcc := AnchoredDrawing{_cedc._fced, _dage}
	_dage.SimplePosAttr = _e.Bool(false)
	_dage.AllowOverlapAttr = true
	_dage.CNvGraphicFramePr = _ad.NewCT_NonVisualGraphicFrameProperties()
	_effd.RunInnerContentChoice.Drawing.DrawingChoice = append(_effd.RunInnerContentChoice.Drawing.DrawingChoice, &_deg.CT_DrawingChoice{Anchor: _dage})
	_dage.Graphic = _ad.NewGraphic()
	_dage.Graphic.GraphicData = _ad.NewCT_GraphicalObjectData()
	_dage.Graphic.GraphicData.UriAttr = "\u0068\u0074\u0074\u0070\u003a\u002f/\u0073\u0063\u0068e\u006d\u0061\u0073.\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002e\u006frg\u002f\u0064\u0072\u0061\u0077\u0069\u006e\u0067\u006d\u006c\u002f\u0032\u0030\u0030\u0036\u002f\u0070\u0069\u0063\u0074\u0075\u0072\u0065"
	_dage.SimplePos.XAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_dage.SimplePos.YAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_dage.PositionH.RelativeFromAttr = _deg.WdST_RelFromHPage
	_dage.PositionH.PosHChoice = &_deg.WdCT_PosHChoice{}
	_dage.PositionH.PosHChoice.PosOffset = _e.Int32(0)
	_dage.PositionV.RelativeFromAttr = _deg.WdST_RelFromVPage
	_dage.PositionV.PosVChoice = &_deg.WdCT_PosVChoice{}
	_dage.PositionV.PosVChoice.PosOffset = _e.Int32(0)
	_dage.Extent.CxAttr = int64(float64(img.Size().X*_cdg.Pixel72) / _cdg.EMU)
	_dage.Extent.CyAttr = int64(float64(img.Size().Y*_cdg.Pixel72) / _cdg.EMU)
	_dage.WrapTypeChoice = &_deg.WdEG_WrapTypeChoice{}
	_dage.WrapTypeChoice.WrapSquare = _deg.NewWdCT_WrapSquare()
	_dage.WrapTypeChoice.WrapSquare.WrapTextAttr = _deg.WdST_WrapTextBothSides
	_dgafd := 0x7FFFFFFF & _gc.Uint32()
	_dage.DocPr.IdAttr = _dgafd
	_fcecd := _gg.NewPic()
	_fcecd.NvPicPr.CNvPr.IdAttr = _dgafd
	_fafab := img.RelID()
	if _fafab == "" {
		return _afcc, _bea.New("\u0063\u006f\u0075\u006c\u0064\u006e\u0027\u0074\u0020\u0066\u0069\u006e\u0064\u0020\u0072\u0065\u0066\u0065\u0072\u0065n\u0063\u0065\u0020\u0074\u006f\u0020\u0069\u006d\u0061g\u0065\u0020\u0077\u0069\u0074\u0068\u0069\u006e\u0020\u0064\u006f\u0063\u0075m\u0065\u006e\u0074\u0020\u0072\u0065l\u0061\u0074\u0069o\u006e\u0073")
	}
	_dage.Graphic.GraphicData.Any = append(_dage.Graphic.GraphicData.Any, _fcecd)
	_fcecd.BlipFill = _ad.NewCT_BlipFillProperties()
	_fcecd.BlipFill.Blip = _ad.NewCT_Blip()
	_fcecd.BlipFill.Blip.EmbedAttr = &_fafab
	_fcecd.BlipFill.FillModePropertiesChoice.Stretch = _ad.NewCT_StretchInfoProperties()
	_fcecd.BlipFill.FillModePropertiesChoice.Stretch.FillRect = _ad.NewCT_RelativeRect()
	_fcecd.SpPr = _ad.NewCT_ShapeProperties()
	_fcecd.SpPr.Xfrm = _ad.NewCT_Transform2D()
	_fcecd.SpPr.Xfrm.Off = _ad.NewCT_Point2D()
	_fcecd.SpPr.Xfrm.Off.XAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_fcecd.SpPr.Xfrm.Off.YAttr.ST_CoordinateUnqualified = _e.Int64(0)
	_fcecd.SpPr.Xfrm.Ext = _ad.NewCT_PositiveSize2D()
	_fcecd.SpPr.Xfrm.Ext.CxAttr = int64(img.Size().X * _cdg.Point)
	_fcecd.SpPr.Xfrm.Ext.CyAttr = int64(img.Size().Y * _cdg.Point)
	_fcecd.SpPr.GeometryChoice.PrstGeom = _ad.NewCT_PresetGeometry2D()
	_fcecd.SpPr.GeometryChoice.PrstGeom.PrstAttr = _ad.ST_ShapeTypeRect
	return _afcc, nil
}

const _fcd = "\u0046\u006f\u0072\u006d\u0046\u0069\u0065l\u0064\u0054\u0079\u0070\u0065\u0055\u006e\u006b\u006e\u006f\u0077\u006e\u0046\u006fr\u006dF\u0069\u0065\u006c\u0064\u0054\u0079p\u0065\u0054\u0065\u0078\u0074\u0046\u006fr\u006d\u0046\u0069\u0065\u006c\u0064\u0054\u0079\u0070\u0065\u0043\u0068\u0065\u0063\u006b\u0042\u006f\u0078\u0046\u006f\u0072\u006d\u0046i\u0065\u006c\u0064\u0054\u0079\u0070\u0065\u0044\u0072\u006f\u0070\u0044\u006fw\u006e"

// SetTop sets the cell top margin
func (_cef CellMargins) SetTop(d _cdg.Distance) {
	_cef._fee.Top = _deg.NewCT_TblWidth()
	_gecb(_cef._fee.Top, d)
}

// TextItem is used for keeping text with references to a paragraph and run or a table, a row and a cell where it is located.
type TextItem struct {
	Text        string
	DrawingInfo *DrawingInfo
	Paragraph   *_deg.CT_P
	Hyperlink   *_deg.CT_Hyperlink
	Run         *_deg.CT_R
	TableInfo   *TableInfo
}

// SetStartPct sets the cell start margin
func (_bba CellMargins) SetStartPct(pct float64) {
	_bba._fee.Start = _deg.NewCT_TblWidth()
	_cfgb(_bba._fee.Start, pct)
}

// SetStyle sets the style of a paragraph.
func (_gdec ParagraphProperties) SetStyle(s string) {
	if s == "" {
		_gdec._adegb.PStyle = nil
	} else {
		_gdec._adegb.PStyle = _deg.NewCT_String()
		_gdec._adegb.PStyle.ValAttr = s
	}
}

// Restart restarts the numbering
func (_cadd *Numbering) Restart(nd *NumberingDefinition) {
	_dfdb := nd._feab.Lvl
	_efac := _cadd.AddDefinition()
	nd._feab = _efac._feab
	nd._feab.Lvl = _dfdb
}

// X returns the inner wrapped XML type.
func (_fgfc Table) X() *_deg.CT_Tbl { return _fgfc._abbae }

// ExtractFromFooter returns text from the document footer as an array of TextItems.
func ExtractFromFooter(footer *_deg.Ftr) []TextItem {
	var _bbddd []TextItem
	for _, _cgaba := range footer.EG_BlockLevelElts {
		_bbddd = append(_bbddd, _aege(_cgaba.BlockLevelEltsChoice.EG_ContentBlockContent, nil)...)
	}
	return _bbddd
}

// SetUISortOrder controls the order the style is displayed in the UI.
func (_fgded Style) SetUISortOrder(order int) {
	_fgded._bageg.UiPriority = _deg.NewCT_DecimalNumber()
	_fgded._bageg.UiPriority.ValAttr = int64(order)
}

// StructuredDocumentTag are a tagged bit of content in a document.
type StructuredDocumentTag struct {
	_gddd  *Document
	_dbbdc *_deg.CT_SdtBlock
}

// AddComment add comment to the paragraph.
func (_feedg Paragraph) AddComment(author, commentText string) int64 {
	var _aafa int64
	if _feedg._eaefb.HasComments() {
		for _, _cdggd := range _feedg._eaefb.Comments() {
			if _cdggd.id() > _aafa {
				_aafa = _cdggd.id()
			}
		}
		_aafa++
	} else {
		_feedg._eaefb.addComments()
		_aafa = 1
	}
	_efbe := _deg.NewCT_Comment()
	_afeba := _deg.NewCT_Markup()
	_acad := _ec.Initials(author)
	_effbc := _bf.Now()
	_efbe.IdAttr = _aafa
	_efbe.AuthorAttr = author
	_efbe.InitialsAttr = &_acad
	_efbe.DateAttr = &_effbc
	_afeba.IdAttr = _aafa
	_efbe.EG_BlockLevelElts = append(_efbe.EG_BlockLevelElts, _deg.NewEG_BlockLevelElts())
	_dbde := Comment{_feedg._eaefb, _efbe}
	_gbdb := _dbde.AddParagraph()
	_gbdb.SetStyle(_aec)
	_dbae := _gbdb.AddRun()
	_dbae.AddAnnotationReference()
	_bddcf := _dbae.Properties()
	_bddcf.SetStyle(_dee)
	_acgfc := _gbdb.AddRun()
	_acgfc.AddText(commentText)
	_eaed := _acgfc.Properties()
	_eaed.SetSize(_cdg.Distance(_babd))
	_feedg._eaefb._aeg.CT_Comments.Comment = append(_feedg._eaefb._aeg.CT_Comments.Comment, _efbe)
	_feedg.addStartComment(_aafa)
	return _aafa
}
func (_ddaa *Document) insertTable(_cbca Paragraph, _ebc bool) Table {
	_cff := _ddaa._effc.Body
	if _cff == nil {
		return _ddaa.AddTable()
	}
	_bfeg := _cbca.X()
	for _fbd, _efga := range _cff.EG_BlockLevelElts {
		for _, _befe := range _efga.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _fea, _fcg := range _befe.ContentBlockContentChoice.P {
				if _fcg == _bfeg {
					_agee := _deg.NewCT_Tbl()
					_eeg := _deg.NewEG_BlockLevelElts()
					_ceba := _deg.NewEG_ContentBlockContent()
					_eeg.BlockLevelEltsChoice.EG_ContentBlockContent = append(_eeg.BlockLevelEltsChoice.EG_ContentBlockContent, _ceba)
					_ceba.ContentBlockContentChoice.Tbl = append(_ceba.ContentBlockContentChoice.Tbl, _agee)
					_cff.EG_BlockLevelElts = append(_cff.EG_BlockLevelElts, nil)
					if _ebc {
						copy(_cff.EG_BlockLevelElts[_fbd+1:], _cff.EG_BlockLevelElts[_fbd:])
						_cff.EG_BlockLevelElts[_fbd] = _eeg
						if _fea != 0 {
							_dag := _deg.NewEG_BlockLevelElts()
							_aca := _deg.NewEG_ContentBlockContent()
							_dag.BlockLevelEltsChoice.EG_ContentBlockContent = append(_dag.BlockLevelEltsChoice.EG_ContentBlockContent, _aca)
							_aca.ContentBlockContentChoice.P = _befe.ContentBlockContentChoice.P[:_fea]
							_cff.EG_BlockLevelElts = append(_cff.EG_BlockLevelElts, nil)
							copy(_cff.EG_BlockLevelElts[_fbd+1:], _cff.EG_BlockLevelElts[_fbd:])
							_cff.EG_BlockLevelElts[_fbd] = _dag
						}
						_befe.ContentBlockContentChoice.P = _befe.ContentBlockContentChoice.P[_fea:]
					} else {
						copy(_cff.EG_BlockLevelElts[_fbd+2:], _cff.EG_BlockLevelElts[_fbd+1:])
						_cff.EG_BlockLevelElts[_fbd+1] = _eeg
						if _fea != len(_befe.ContentBlockContentChoice.P)-1 {
							_cdee := _deg.NewEG_BlockLevelElts()
							_degf := _deg.NewEG_ContentBlockContent()
							_cdee.BlockLevelEltsChoice.EG_ContentBlockContent = append(_cdee.BlockLevelEltsChoice.EG_ContentBlockContent, _degf)
							_degf.ContentBlockContentChoice.P = _befe.ContentBlockContentChoice.P[_fea+1:]
							_cff.EG_BlockLevelElts = append(_cff.EG_BlockLevelElts, nil)
							copy(_cff.EG_BlockLevelElts[_fbd+3:], _cff.EG_BlockLevelElts[_fbd+2:])
							_cff.EG_BlockLevelElts[_fbd+2] = _cdee
						}
						_befe.ContentBlockContentChoice.P = _befe.ContentBlockContentChoice.P[:_fea+1]
					}
					return Table{_ddaa, _agee}
				}
			}
			for _, _bfg := range _befe.ContentBlockContentChoice.Tbl {
				_ecb := _ageec(_bfg, _bfeg, _ebc)
				if _ecb != nil {
					return Table{_ddaa, _ecb}
				}
			}
		}
	}
	return _ddaa.AddTable()
}

// SizeMeasure returns font with its measure which can be mm, cm, in, pt, pc or pi.
func (_dedf RunProperties) SizeMeasure() string {
	if _cbcaa := _dedf._bfed.Sz; _cbcaa != nil {
		_fgae := _cbcaa.ValAttr
		if _fgae.ST_PositiveUniversalMeasure != nil {
			return *_fgae.ST_PositiveUniversalMeasure
		}
	}
	return ""
}

// SetFormat sets the numbering format.
func (_cabcg NumberingLevel) SetFormat(f _deg.ST_NumberFormat) {
	if _cabcg._cdgg.NumFmt == nil {
		_cabcg._cdgg.NumFmt = _deg.NewCT_NumFmt()
	}
	_cabcg._cdgg.NumFmt.ValAttr = f
}

// SetTop sets the top border to a specified type, color and thickness.
func (_gfef CellBorders) SetTop(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_gfef._fba.Top = _deg.NewCT_Border()
	_bgdcd(_gfef._fba.Top, t, c, thickness)
}

// RStyle returns the name of character style.
// It is defined here http://officeopenxml.com/WPstyleCharStyles.php
func (_effca RunProperties) RStyle() string {
	if _effca._bfed.RStyle != nil {
		return _effca._bfed.RStyle.ValAttr
	}
	return ""
}

// SetWidth sets the cell width to a specified width.
func (_beb CellProperties) SetWidth(d _cdg.Distance) {
	_beb._cbb.TcW = _deg.NewCT_TblWidth()
	_beb._cbb.TcW.TypeAttr = _deg.ST_TblWidthDxa
	_beb._cbb.TcW.WAttr = &_deg.ST_MeasurementOrPercent{}
	_beb._cbb.TcW.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_beb._cbb.TcW.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(d / _cdg.Twips))
}

// RunProperties returns the RunProperties controlling numbering level font, etc.
func (_gaggd NumberingLevel) RunProperties() RunProperties {
	if _gaggd._cdgg.RPr == nil {
		_gaggd._cdgg.RPr = _deg.NewCT_RPr()
	}
	return RunProperties{_gaggd._cdgg.RPr}
}

// SetShading controls the cell shading.
func (_ecea CellProperties) SetShading(shd _deg.ST_Shd, foreground, fill _bg.Color) {
	if shd == _deg.ST_ShdUnset {
		_ecea._cbb.Shd = nil
	} else {
		_ecea._cbb.Shd = _deg.NewCT_Shd()
		_ecea._cbb.Shd.ValAttr = shd
		_ecea._cbb.Shd.ColorAttr = &_deg.ST_HexColor{}
		if foreground.IsAuto() {
			_ecea._cbb.Shd.ColorAttr.ST_HexColorAuto = _deg.ST_HexColorAutoAuto
		} else {
			_ecea._cbb.Shd.ColorAttr.ST_HexColorRGB = foreground.AsRGBString()
		}
		_ecea._cbb.Shd.FillAttr = &_deg.ST_HexColor{}
		if fill.IsAuto() {
			_ecea._cbb.Shd.FillAttr.ST_HexColorAuto = _deg.ST_HexColorAutoAuto
		} else {
			_ecea._cbb.Shd.FillAttr.ST_HexColorRGB = fill.AsRGBString()
		}
	}
}

// SetWidthPercent sets the cell to a width percentage.
func (_ab CellProperties) SetWidthPercent(pct float64) {
	_ab._cbb.TcW = _deg.NewCT_TblWidth()
	_ab._cbb.TcW.TypeAttr = _deg.ST_TblWidthPct
	_ab._cbb.TcW.WAttr = &_deg.ST_MeasurementOrPercent{}
	_ab._cbb.TcW.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_ab._cbb.TcW.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(pct * 50))
}

// TableInfo is used for keep information about a table, a row and a cell where the text is located.
type TableInfo struct {
	Table    *_deg.CT_Tbl
	Row      *_deg.CT_Row
	Cell     *_deg.CT_Tc
	RowIndex int
	ColIndex int
}

// IgnoreSpaceBetweenParagraphOfSameStyle sets contextual spacing.
func (_fccb Paragraph) IgnoreSpaceBetweenParagraphOfSameStyle() {
	_fccb.ensurePPr()
	if _fccb._bbff.PPr.ContextualSpacing == nil {
		_fccb._bbff.PPr.ContextualSpacing = _deg.NewCT_OnOff()
	}
	_fccb._bbff.PPr.ContextualSpacing.ValAttr = &_fae.ST_OnOff{ST_OnOff1: _fae.ST_OnOff1On}
}

// SetTargetBookmark sets the bookmark target of the hyperlink.
func (_bdagb HyperLink) SetTargetBookmark(bm Bookmark) {
	_bdagb._babce.AnchorAttr = _e.String(bm.Name())
	_bdagb._babce.IdAttr = nil
}

// SetRight sets the right border to a specified type, color and thickness.
func (_cfff ParagraphBorders) SetRight(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_cfff._gdbad.Right = _deg.NewCT_Border()
	_dcfaff(_cfff._gdbad.Right, t, c, thickness)
}

type htmlNode struct {
	_gddb  _d.StartElement
	_aegce *htmlNode
}

// SetBold sets the run to bold.
func (_abaea RunProperties) SetBold(b bool) {
	if !b {
		_abaea._bfed.B = nil
		_abaea._bfed.BCs = nil
	} else {
		_abaea._bfed.B = _deg.NewCT_OnOff()
		_abaea._bfed.BCs = _deg.NewCT_OnOff()
	}
}

type listItemInfo struct {
	FromStyle      *Style
	FromParagraph  *Paragraph
	AbstractNumId  *int64
	NumberingLevel *NumberingLevel
}

// InitializeDefault constructs a default numbering.
func (_dedd Numbering) InitializeDefault() {
	_bddbd := _deg.NewCT_AbstractNum()
	_bddbd.MultiLevelType = _deg.NewCT_MultiLevelType()
	_bddbd.MultiLevelType.ValAttr = _deg.ST_MultiLevelTypeHybridMultilevel
	_dedd._gcfa.AbstractNum = append(_dedd._gcfa.AbstractNum, _bddbd)
	_bddbd.AbstractNumIdAttr = 1
	const _efeff = 720
	const _dabcb = 720
	const _fdfbc = 360
	for _ddbgd := 0; _ddbgd < 9; _ddbgd++ {
		_edebe := _deg.NewCT_Lvl()
		_edebe.IlvlAttr = int64(_ddbgd)
		_edebe.Start = _deg.NewCT_DecimalNumber()
		_edebe.Start.ValAttr = 1
		_edebe.NumFmt = _deg.NewCT_NumFmt()
		_edebe.NumFmt.ValAttr = _deg.ST_NumberFormatBullet
		_edebe.Suff = _deg.NewCT_LevelSuffix()
		_edebe.Suff.ValAttr = _deg.ST_LevelSuffixNothing
		_edebe.LvlText = _deg.NewCT_LevelText()
		_edebe.LvlText.ValAttr = _e.String("\uf0b7")
		_edebe.LvlJc = _deg.NewCT_Jc()
		_edebe.LvlJc.ValAttr = _deg.ST_JcLeft
		_edebe.RPr = _deg.NewCT_RPr()
		_edebe.RPr.RFonts = _deg.NewCT_Fonts()
		_edebe.RPr.RFonts.AsciiAttr = _e.String("\u0053\u0079\u006d\u0062\u006f\u006c")
		_edebe.RPr.RFonts.HAnsiAttr = _e.String("\u0053\u0079\u006d\u0062\u006f\u006c")
		_edebe.RPr.RFonts.HintAttr = _deg.ST_HintDefault
		_edebe.PPr = _deg.NewCT_PPrGeneral()
		_dbebc := int64(_ddbgd*_dabcb + _efeff)
		_edebe.PPr.Ind = _deg.NewCT_Ind()
		_edebe.PPr.Ind.LeftAttr = &_deg.ST_SignedTwipsMeasure{}
		_edebe.PPr.Ind.LeftAttr.Int64 = _e.Int64(_dbebc)
		_edebe.PPr.Ind.HangingAttr = &_fae.ST_TwipsMeasure{}
		_edebe.PPr.Ind.HangingAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(_fdfbc))
		_bddbd.Lvl = append(_bddbd.Lvl, _edebe)
	}
	_adecf := _deg.NewCT_Num()
	_adecf.NumIdAttr = 1
	_adecf.AbstractNumId = _deg.NewCT_DecimalNumber()
	_adecf.AbstractNumId.ValAttr = 1
	_dedd._gcfa.Num = append(_dedd._gcfa.Num, _adecf)
}

// Cells returns the cells defined in the table.
func (_fbdfa Row) Cells() []Cell {
	_cabg := []Cell{}
	for _, _ggaef := range _fbdfa._ebcb.EG_ContentCellContent {
		for _, _beegb := range _ggaef.ContentCellContentChoice.Tc {
			_cabg = append(_cabg, Cell{_fbdfa._bace, _beegb})
		}
		if _ggaef.ContentCellContentChoice.Sdt != nil && _ggaef.ContentCellContentChoice.Sdt.SdtContent != nil {
			for _, _ccddf := range _ggaef.ContentCellContentChoice.Sdt.SdtContent.EG_ContentCellContent {
				for _, _bbfc := range _ccddf.ContentCellContentChoice.Tc {
					_cabg = append(_cabg, Cell{_fbdfa._bace, _bbfc})
				}
			}
		}
	}
	return _cabg
}
func (_beeg FormFieldType) String() string {
	if _beeg >= FormFieldType(len(_gfcb)-1) {
		return _dd.Sprintf("\u0046\u006f\u0072\u006d\u0046\u0069\u0065\u006c\u0064\u0054\u0079\u0070e\u0028\u0025\u0064\u0029", _beeg)
	}
	return _fcd[_gfcb[_beeg]:_gfcb[_beeg+1]]
}

// DrawingAnchored returns a slice of AnchoredDrawings.
func (_eced Run) DrawingAnchored() []AnchoredDrawing {
	_dcgbe := []AnchoredDrawing{}
	for _, _ebcd := range _eced._gabc.EG_RunInnerContent {
		if _ebcd.RunInnerContentChoice.Drawing == nil {
			continue
		}
		for _, _adebb := range _ebcd.RunInnerContentChoice.Drawing.DrawingChoice {
			if _adebb.Anchor == nil {
				continue
			}
			_dcgbe = append(_dcgbe, AnchoredDrawing{_eced._fced, _adebb.Anchor})
		}
	}
	return _dcgbe
}

// SetAlignment controls the paragraph alignment
func (_eaab ParagraphProperties) SetAlignment(align _deg.ST_Jc) {
	if align == _deg.ST_JcUnset {
		_eaab._adegb.Jc = nil
	} else {
		_eaab._adegb.Jc = _deg.NewCT_Jc()
		_eaab._adegb.Jc.ValAttr = align
	}
}

// SetLineSpacing sets the spacing between lines in a paragraph.
func (_aeacb ParagraphSpacing) SetLineSpacing(d _cdg.Distance, rule _deg.ST_LineSpacingRule) {
	if rule == _deg.ST_LineSpacingRuleUnset {
		_aeacb._gdfc.LineRuleAttr = _deg.ST_LineSpacingRuleUnset
		_aeacb._gdfc.LineAttr = nil
	} else {
		_aeacb._gdfc.LineRuleAttr = rule
		_aeacb._gdfc.LineAttr = &_deg.ST_SignedTwipsMeasure{}
		_aeacb._gdfc.LineAttr.Int64 = _e.Int64(int64(d / _cdg.Twips))
	}
}

// AddField adds a field (automatically computed text) to the document.
func (_gbdba Run) AddField(code string) { _gbdba.AddFieldWithFormatting(code, "", true) }
func _dcfaff(_bcefb *_deg.CT_Border, _ccaa _deg.ST_Border, _aecff _bg.Color, _feaed _cdg.Distance) {
	_bcefb.ValAttr = _ccaa
	_bcefb.ColorAttr = &_deg.ST_HexColor{}
	if _aecff.IsAuto() {
		_bcefb.ColorAttr.ST_HexColorAuto = _deg.ST_HexColorAutoAuto
	} else {
		_bcefb.ColorAttr.ST_HexColorRGB = _aecff.AsRGBString()
	}
	if _feaed != _cdg.Zero {
		_bcefb.SzAttr = _e.Uint64(uint64(_feaed / _cdg.Point * 8))
	}
}

// TextWithOptions extract text with options.
func (_abdda *DocText) TextWithOptions(options ExtractTextOptions) string {
	_fbabd := make(map[int64]map[int64]int64, 0)
	_gdgc := _ag.NewBuffer([]byte{})
	_gccgf := int64(0)
	_efca := int64(0)
	_fdbeb := int64(0)
	for _debgc, _bebg := range _abdda.Items {
		_gegcc := false
		if _bebg.Text != "" {
			if _debgc > 0 {
				if _bebg.Paragraph != _abdda.Items[_debgc-1].Paragraph {
					_gegcc = true
				}
				if !options.RunsOnNewLine && _gegcc {
					_gdgc.WriteString("\u000a")
				} else if options.RunsOnNewLine {
					_gdgc.WriteString("\u000a")
				}
			} else {
				_gegcc = true
			}
			if options.WithNumbering {
				if _gegcc {
					for _, _gcaa := range _abdda._cedag {
						if _gcaa.FromParagraph == nil {
							continue
						}
						if _gcaa.FromParagraph.X() == _bebg.Paragraph {
							if _bcfe := _gcaa.NumberingLevel.X(); _bcfe != nil {
								if _gcaa.AbstractNumId != nil && _abdda._facbe[*_gcaa.AbstractNumId][_bcfe.IlvlAttr] > 0 {
									if _, _abcd := _fbabd[*_gcaa.AbstractNumId]; _abcd {
										if _, _agcg := _fbabd[*_gcaa.AbstractNumId][_bcfe.IlvlAttr]; _agcg {
											_fbabd[*_gcaa.AbstractNumId][_bcfe.IlvlAttr]++
										} else {
											_fbabd[*_gcaa.AbstractNumId][_bcfe.IlvlAttr] = 1
										}
									} else {
										_fbabd[*_gcaa.AbstractNumId] = map[int64]int64{_bcfe.IlvlAttr: 1}
									}
									if _gccgf == _gcaa.NumberingLevel.X().IlvlAttr && _bcfe.IlvlAttr > 0 {
										_efca++
									} else {
										_efca = _fbabd[*_gcaa.AbstractNumId][_bcfe.IlvlAttr]
										if _bcfe.IlvlAttr > _gccgf && _fdbeb == *_gcaa.AbstractNumId {
											_efca = 1
										}
									}
									_fadc := ""
									if _bcfe.LvlText.ValAttr != nil {
										_fadc = *_bcfe.LvlText.ValAttr
									}
									_ccgb := _ec.FormatNumberingText(_efca, _bcfe.IlvlAttr, _fadc, _bcfe.NumFmt, _fbabd[*_gcaa.AbstractNumId])
									_gdgc.WriteString(_ccgb)
									_abdda._facbe[*_gcaa.AbstractNumId][_bcfe.IlvlAttr]--
									_gccgf = _bcfe.IlvlAttr
									_fdbeb = *_gcaa.AbstractNumId
									if options.NumberingIndent != "" {
										_gdgc.WriteString(options.NumberingIndent)
									}
								}
							}
							break
						}
					}
				}
			}
			_gdgc.WriteString(_bebg.Text)
		}
	}
	return _gdgc.String()
}

// SetXOffset sets the X offset for an image relative to the origin.
func (_bb AnchoredDrawing) SetXOffset(x _cdg.Distance) {
	_bb._bgc.PositionH.PosHChoice = &_deg.WdCT_PosHChoice{}
	_bb._bgc.PositionH.PosHChoice.PosOffset = _e.Int32(int32(x / _cdg.EMU))
}

// Properties returns the run properties.
func (_eegae Run) Properties() RunProperties {
	if _eegae._gabc.RPr == nil {
		_eegae._gabc.RPr = _deg.NewCT_RPr()
	}
	return RunProperties{_eegae._gabc.RPr}
}

// FindNodeByStyleId return slice of node base on style id.
func (_ddcg *Nodes) FindNodeByStyleId(styleId string) []Node {
	_dead := []Node{}
	for _, _adgaf := range _ddcg._aebcgc {
		switch _ddgff := _adgaf._bbbg.(type) {
		case *Paragraph:
			if _ddgff != nil && _ddgff.Style() == styleId {
				_dead = append(_dead, _adgaf)
			}
		case *Table:
			if _ddgff != nil && _ddgff.Style() == styleId {
				_dead = append(_dead, _adgaf)
			}
		}
		_ggdd := Nodes{_aebcgc: _adgaf.Children}
		_dead = append(_dead, _ggdd.FindNodeByStyleId(styleId)...)
	}
	return _dead
}

// SetBottomPct sets the cell bottom margin
func (_eee CellMargins) SetBottomPct(pct float64) {
	_eee._fee.Bottom = _deg.NewCT_TblWidth()
	_cfgb(_eee._fee.Bottom, pct)
}

// AddRun adds a run of text to a hyperlink. This is the text that will be linked.
func (_gacee HyperLink) AddRun() Run {
	_efeb := _deg.NewEG_ContentRunContent()
	_gacee._babce.PContentChoice.EG_ContentRunContent = append(_gacee._babce.PContentChoice.EG_ContentRunContent, _efeb)
	_geace := _deg.NewCT_R()
	_efeb.ContentRunContentChoice.R = _geace
	return Run{_gacee._babe, _geace}
}

// RemoveEndnote removes a endnote from both the paragraph and the document
// the requested endnote must be anchored on the paragraph being referenced.
//
// After each removal, the rest of the endnote ids would be reordered.
func (_dffaf Paragraph) RemoveEndnote(id int64) {
	for _, _dccbg := range _dffaf.Runs() {
		if _bfaf, _gegff := _dccbg.IsEndnote(); _bfaf {
			if _gegff == id {
				_dffaf.RemoveRun(_dccbg)
				break
			}
		}
	}
	_dffaf._eaefb.removeEndnote(id)
}

// SetTableIndent sets the Table Indent from the Leading Margin
func (_dbcfg TableStyleProperties) SetTableIndent(ind _cdg.Distance) {
	_dbcfg._daffa.TblInd = _deg.NewCT_TblWidth()
	_dbcfg._daffa.TblInd.TypeAttr = _deg.ST_TblWidthDxa
	_dbcfg._daffa.TblInd.WAttr = &_deg.ST_MeasurementOrPercent{}
	_dbcfg._daffa.TblInd.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_dbcfg._daffa.TblInd.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(ind / _cdg.Dxa))
}

// // SetBeforeLineSpacing sets spacing above paragraph in line units.
func (_aeac Paragraph) SetBeforeLineSpacing(d _cdg.Distance) {
	_aeac.ensurePPr()
	if _aeac._bbff.PPr.Spacing == nil {
		_aeac._bbff.PPr.Spacing = _deg.NewCT_Spacing()
	}
	_dcfad := _aeac._bbff.PPr.Spacing
	_dcfad.BeforeLinesAttr = _e.Int64(int64(d / _cdg.Twips))
}

// AddFieldWithFormatting adds a field (automatically computed text) to the
// document with field specifc formatting.
func (_fefd Run) AddFieldWithFormatting(code string, fmt string, isDirty bool) {
	_agad := _fefd.newIC()
	_agad.RunInnerContentChoice.FldChar = _deg.NewCT_FldChar()
	_agad.RunInnerContentChoice.FldChar.FldCharTypeAttr = _deg.ST_FldCharTypeBegin
	if isDirty {
		_agad.RunInnerContentChoice.FldChar.DirtyAttr = &_fae.ST_OnOff{}
		_agad.RunInnerContentChoice.FldChar.DirtyAttr.Bool = _e.Bool(true)
	}
	_agad = _fefd.newIC()
	_agad.RunInnerContentChoice.InstrText = _deg.NewCT_Text()
	if fmt != "" {
		_agad.RunInnerContentChoice.InstrText.Content = code + "\u0020" + fmt
	} else {
		_agad.RunInnerContentChoice.InstrText.Content = code
	}
	_agad = _fefd.newIC()
	_agad.RunInnerContentChoice.FldChar = _deg.NewCT_FldChar()
	_agad.RunInnerContentChoice.FldChar.FldCharTypeAttr = _deg.ST_FldCharTypeEnd
}

// IsBold returns true if the run has been set to bold.
func (_gbeee RunProperties) IsBold() bool { return _gbeee.BoldValue() == OnOffValueOn }

// SetKerning sets the run's font kerning.
func (_fdcfg RunProperties) SetKerning(size _cdg.Distance) {
	_fdcfg._bfed.Kern = _deg.NewCT_HpsMeasure()
	_fdcfg._bfed.Kern.ValAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(size / _cdg.HalfPoint))
}

// GetHeader gets a section Header for given type t [ST_HdrFtrDefault, ST_HdrFtrEven, ST_HdrFtrFirst]
func (_efff Section) GetHeader(t _deg.ST_HdrFtr) (Header, bool) {
	for _, _ffab := range _efff._eegag.EG_HdrFtrReferences {
		if _ffab.HdrFtrReferencesChoice.HeaderReference == nil {
			continue
		}
		if _ffab.HdrFtrReferencesChoice.HeaderReference.TypeAttr == t {
			for _, _acfg := range _efff._bbbea.Headers() {
				_dcgbc := _efff._bbbea._afff.FindRIDForN(_acfg.Index(), _e.HeaderType)
				if _dcgbc == _ffab.HdrFtrReferencesChoice.HeaderReference.IdAttr {
					return _acfg, true
				}
			}
		}
	}
	return Header{}, false
}

// AddHTML adds HTML text to a run.
func (_ebdb Run) AddHTML(s string) {
	_cdeb := _deg.NewEG_RunInnerContent()
	_ebdb._gabc.EG_RunInnerContent = append(_ebdb._gabc.EG_RunInnerContent, _cdeb)
	_cdeb.RunInnerContentChoice.T = _deg.NewCT_Text()
	if _e.NeedsSpacePreserve(s) {
		_cbafg := "\u0070\u0072\u0065\u0073\u0065\u0072\u0076\u0065"
		_cdeb.RunInnerContentChoice.T.SpaceAttr = &_cbafg
	}
	_efdd := _ebdb.parseHTMLTag(s)
	_cdeb.RunInnerContentChoice.T.Content = _efdd
}

// Text returns text from the document as one string separated with line breaks.
func (_fgfa *DocText) Text() string {
	_cafdf := _ag.NewBuffer([]byte{})
	for _, _agcb := range _fgfa.Items {
		if _agcb.Text != "" {
			_cafdf.WriteString(_agcb.Text)
			_cafdf.WriteString("\u000a")
		}
	}
	return _cafdf.String()
}

// X returns the inner wrapped XML type.
func (_bgba NumberingDefinition) X() *_deg.CT_AbstractNum { return _bgba._feab }

// SetHeadingLevel sets a heading level and style based on the level to a
// paragraph.  The default styles for a new unioffice document support headings
// from level 1 to 8.
func (_dbecg ParagraphProperties) SetHeadingLevel(idx int) {
	_dbecg.SetStyle(_dd.Sprintf("\u0048e\u0061\u0064\u0069\u006e\u0067\u0025d", idx))
	if _dbecg._adegb.NumPr == nil {
		_dbecg._adegb.NumPr = _deg.NewCT_NumPr()
	}
	_dbecg._adegb.NumPr.Ilvl = _deg.NewCT_DecimalNumber()
	_dbecg._adegb.NumPr.Ilvl.ValAttr = int64(idx)
}
func _fdad() *_dc.OfcLock {
	_gcdgg := _dc.NewOfcLock()
	_gcdgg.ExtAttr = _dc.ST_ExtEdit
	_gcdgg.TextAttr = _fae.ST_TrueFalseTrue
	_gcdgg.ShapetypeAttr = _fae.ST_TrueFalseTrue
	return _gcdgg
}

// SetPrimaryStyle marks the style as a primary style.
func (_efddg Style) SetPrimaryStyle(b bool) {
	if b {
		_efddg._bageg.QFormat = _deg.NewCT_OnOff()
	} else {
		_efddg._bageg.QFormat = nil
	}
}

// GetWrapPathStart return wrapPath start value.
func (_dfa AnchorDrawWrapOptions) GetWrapPathStart() *_ad.CT_Point2D { return _dfa._bad }

// Paragraphs returns the paragraphs defined in an endnote.
func (_dcca Endnote) Paragraphs() []Paragraph {
	_cadgg := []Paragraph{}
	for _, _debg := range _dcca.content() {
		for _, _ecfa := range _debg.ContentBlockContentChoice.P {
			_cadgg = append(_cadgg, Paragraph{_dcca._eecgf, _ecfa})
		}
	}
	return _cadgg
}

// SetColor sets color of watermark text.
func (_cfdaa *WatermarkText) SetColor(value string) {
	if _cfdaa._cfbf != nil {
		_cfdaa._cfbf.FillcolorAttr = &value
	}
}

// AddHyperlink adds a hyperlink to a document. Adding the hyperlink to a document
// and setting it on a cell is more efficient than setting hyperlinks directly
// on a cell.
func (_gbac Document) AddHyperlink(url string) _ee.Hyperlink { return _gbac._afff.AddHyperlink(url) }

// SetOrigin sets the origin of the image.  It defaults to ST_RelFromHPage and
// ST_RelFromVPage
func (_fc AnchoredDrawing) SetOrigin(h _deg.WdST_RelFromH, v _deg.WdST_RelFromV) {
	_fc._bgc.PositionH.RelativeFromAttr = h
	_fc._bgc.PositionV.RelativeFromAttr = v
}

// SetColor sets a specific color or auto.
func (_aeba Color) SetColor(v _bg.Color) {
	if v.IsAuto() {
		_aeba._dbb.ValAttr.ST_HexColorAuto = _deg.ST_HexColorAutoAuto
		_aeba._dbb.ValAttr.ST_HexColorRGB = nil
	} else {
		_aeba._dbb.ValAttr.ST_HexColorAuto = _deg.ST_HexColorAutoUnset
		_aeba._dbb.ValAttr.ST_HexColorRGB = v.AsRGBString()
	}
}

// Footnotes returns the footnotes defined in the document.
func (_aaeag *Document) Footnotes() []Footnote {
	_efad := []Footnote{}
	for _, _cabf := range _aaeag._daaf.CT_Footnotes.Footnote {
		_efad = append(_efad, Footnote{_aaeag, _cabf})
	}
	return _efad
}

// Paragraphs returns the paragraphs defined in a header.
func (_fceef Header) Paragraphs() []Paragraph {
	_gbbeb := []Paragraph{}
	for _, _bafcd := range _fceef._efadbc.EG_BlockLevelElts {
		for _, _bcfb := range _bafcd.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _, _fadf := range _bcfb.ContentBlockContentChoice.P {
				_gbbeb = append(_gbbeb, Paragraph{_fceef._efbf, _fadf})
			}
		}
	}
	for _, _bcdec := range _fceef.Tables() {
		for _, _ecebg := range _bcdec.Rows() {
			for _, _ebgf := range _ecebg.Cells() {
				_gbbeb = append(_gbbeb, _ebgf.Paragraphs()...)
			}
		}
	}
	return _gbbeb
}

// Runs returns all of the runs in a paragraph.
func (_bfcc Paragraph) Runs() []Run {
	_cbgfd := []Run{}
	for _, _daeba := range _bfcc._bbff.EG_PContent {
		if _daeba.PContentChoice.Hyperlink != nil && _daeba.PContentChoice.Hyperlink.PContentChoice.EG_ContentRunContent != nil {
			for _, _edaad := range _daeba.PContentChoice.Hyperlink.PContentChoice.EG_ContentRunContent {
				if _edaad.ContentRunContentChoice.R != nil {
					_cbgfd = append(_cbgfd, Run{_bfcc._eaefb, _edaad.ContentRunContentChoice.R})
				}
			}
		}
		for _, _gcab := range _daeba.PContentChoice.EG_ContentRunContent {
			if _gcab.ContentRunContentChoice.R != nil {
				_cbgfd = append(_cbgfd, Run{_bfcc._eaefb, _gcab.ContentRunContentChoice.R})
			}
			if _gcab.ContentRunContentChoice.Sdt != nil && _gcab.ContentRunContentChoice.Sdt.SdtContent != nil {
				for _, _fcbg := range _gcab.ContentRunContentChoice.Sdt.SdtContent.EG_PContent {
					for _, _ddabdb := range _fcbg.PContentChoice.EG_ContentRunContent {
						if _ddabdb.ContentRunContentChoice.R != nil {
							_cbgfd = append(_cbgfd, Run{_bfcc._eaefb, _ddabdb.ContentRunContentChoice.R})
						}
					}
				}
			}
		}
	}
	return _cbgfd
}

// ReplaceText replace text inside node.
func (_ecbfb *Nodes) ReplaceText(oldText, newText string) {
	for _, _gcagb := range _ecbfb._aebcgc {
		_gcagb.ReplaceText(oldText, newText)
	}
}

// Read reads a document from an io.Reader.
func Read(r _ga.ReaderAt, size int64) (*Document, error) { return _ebdf(r, size, "") }

var (
	FootnoteTextStyleId = "\u0046\u006f\u006ft\u006e\u006f\u0074\u0065\u0054\u0065\u0078\u0074"
	_adb                = "\u0046\u006f\u006f\u0074\u006e\u006f\u0074\u0065\u0052\u0065\u0066\u0065r\u0065\u006e\u0063\u0065"
	EndnoteTextStyleId  = "E\u006e\u0064\u006e\u006f\u0074\u0065\u0054\u0065\u0078\u0074"
	_fdb                = "\u0045\u006ed\u006e\u006f\u0074e\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065"
	_gda                = uint64(20)
	_dee                = "\u0043\u006fm\u006d\u0065\u006et\u0052\u0065\u0066\u0065\u0072\u0065\u006e\u0063\u0065"
	_aec                = "C\u006f\u006d\u006d\u0065\u006e\u0074\u0054\u0065\u0078\u0074"
	_cddb               = "\u0043o\u006dm\u0065\u006e\u0074\u0054\u0065\u0078\u0074\u0043\u0068\u0061\u0072"
	_dbea               = "\u0043\u006f\u006d\u006d\u0065\u006e\u0074\u0053\u0075b\u006a\u0065\u0063\u0074"
	_bec                = "\u0043o\u006dm\u0065\u006e\u0074\u0053\u0075b\u006a\u0065c\u0074\u0043\u0068\u0061\u0072"
	_aac                = uint64(20)
	_babd               = uint64(16)
)

// SetLayoutInCell sets the layoutInCell attribute of anchor.
func (_fb AnchoredDrawing) SetLayoutInCell(val bool) { _fb._bgc.LayoutInCellAttr = val }
func (_fbgc *Document) save(_efa _ga.Writer, _dceg string) error {
	const _ggcd = "\u0064o\u0063u\u006d\u0065\u006e\u0074\u003a\u0064\u002e\u0053\u0061\u0076\u0065"
	if _bbag := _fbgc._effc.Validate(); _bbag != nil {
		_gd.Log.Warning("\u0076\u0061\u006c\u0069\u0064\u0061\u0074\u0069\u006f\u006e\u0020\u0065\u0072\u0072\u006fr\u0020i\u006e\u0020\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u003a\u0020\u0025\u0073", _bbag)
	}
	_ceb := _e.DocTypeDocument
	if !_de.GetLicenseKey().IsLicensed() && !_bed {
		_dd.Println("\u0055\u006e\u006ci\u0063\u0065\u006e\u0073e\u0064\u0020\u0076\u0065\u0072\u0073\u0069o\u006e\u0020\u006f\u0066\u0020\u0055\u006e\u0069\u004f\u0066\u0066\u0069\u0063\u0065")
		_dd.Println("\u002d\u0020\u0047e\u0074\u0020\u0061\u0020\u0074\u0072\u0069\u0061\u006c\u0020\u006c\u0069\u0063\u0065\u006e\u0073\u0065\u0020\u006f\u006e\u0020\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fu\u006e\u0069\u0064\u006f\u0063\u002e\u0069\u006f")
		return _bea.New("\u0075\u006e\u0069\u006f\u0066\u0066\u0069\u0063\u0065\u0020\u006ci\u0063\u0065\u006e\u0073\u0065\u0020\u0072\u0065\u0071\u0075i\u0072\u0065\u0064")
	}
	_dgd := "\u0075n\u006b\u006e\u006f\u0077\u006e"
	if _dbg, _eacb := _efa.(*_ea.File); _eacb {
		_dgd = _dbg.Name()
	}
	if len(_fbgc._cfgg) == 0 {
		if len(_dceg) > 0 {
			_fbgc._cfgg = _dceg
		} else {
			_ggg, _badc := _de.GenRefId("\u0064\u0077")
			if _badc != nil {
				_gd.Log.Error("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _badc)
				return _badc
			}
			_fbgc._cfgg = _ggg
		}
	}
	if _gde := _de.Track(_fbgc._cfgg, _ggcd, _dgd); _gde != nil {
		_gd.Log.Error("\u0045R\u0052\u004f\u0052\u003a\u0020\u0025v", _gde)
		return _gde
	}
	_baac := _fa.NewWriter(_efa)
	defer _baac.Close()
	if _cbc := _db.MarshalXML(_baac, _e.BaseRelsFilename, _fbgc.Rels.X()); _cbc != nil {
		return _cbc
	}
	if _dded := _db.MarshalXMLByType(_baac, _ceb, _e.ExtendedPropertiesType, _fbgc.AppProperties.X()); _dded != nil {
		return _dded
	}
	if _dfb := _db.MarshalXMLByType(_baac, _ceb, _e.CorePropertiesType, _fbgc.CoreProperties.X()); _dfb != nil {
		return _dfb
	}
	if _fbgc.CustomProperties.X() != nil {
		if _dgf := _db.MarshalXMLByType(_baac, _ceb, _e.CustomPropertiesType, _fbgc.CustomProperties.X()); _dgf != nil {
			return _dgf
		}
	}
	if _fbgc.Thumbnail != nil {
		_dcfb, _bfe := _baac.Create("\u0064\u006f\u0063Pr\u006f\u0070\u0073\u002f\u0074\u0068\u0075\u006d\u0062\u006e\u0061\u0069\u006c\u002e\u006a\u0070\u0065\u0067")
		if _bfe != nil {
			return _bfe
		}
		if _bdea := _c.Encode(_dcfb, _fbgc.Thumbnail, nil); _bdea != nil {
			return _bdea
		}
	}
	if _gfg := _db.MarshalXMLByType(_baac, _ceb, _e.SettingsType, _fbgc.Settings.X()); _gfg != nil {
		return _gfg
	}
	_abdc := _e.AbsoluteFilename(_ceb, _e.OfficeDocumentType, 0)
	if _gecbc := _db.MarshalXML(_baac, _abdc, _fbgc._effc); _gecbc != nil {
		return _gecbc
	}
	if _ccce := _db.MarshalXML(_baac, _db.RelationsPathFor(_abdc), _fbgc._afff.X()); _ccce != nil {
		return _ccce
	}
	if _fbgc.Numbering.X() != nil {
		if _fff := _db.MarshalXMLByType(_baac, _ceb, _e.NumberingType, _fbgc.Numbering.X()); _fff != nil {
			return _fff
		}
	}
	if _cgb := _db.MarshalXMLByType(_baac, _ceb, _e.StylesType, _fbgc.Styles.X()); _cgb != nil {
		return _cgb
	}
	if _fbgc._egb != nil {
		if _dda := _db.MarshalXMLByType(_baac, _ceb, _e.WebSettingsType, _fbgc._egb); _dda != nil {
			return _dda
		}
	}
	if _fbgc._ffea != nil {
		if _ffdf := _db.MarshalXMLByType(_baac, _ceb, _e.FontTableType, _fbgc._ffea); _ffdf != nil {
			return _ffdf
		}
	}
	if _fbgc._ebfb != nil {
		if _fgb := _db.MarshalXMLByType(_baac, _ceb, _e.EndNotesType, _fbgc._ebfb); _fgb != nil {
			return _fgb
		}
	}
	if _fbgc._daaf != nil {
		if _bgee := _db.MarshalXMLByType(_baac, _ceb, _e.FootNotesType, _fbgc._daaf); _bgee != nil {
			return _bgee
		}
	}
	if _fbgc._aeg != nil {
		if _fcca := _db.MarshalXMLByType(_baac, _ceb, _e.CommentsContentType, _fbgc._aeg); _fcca != nil {
			return _fcca
		}
	}
	for _cde, _cee := range _fbgc._dgb {
		if _ggdf := _db.MarshalXMLByTypeIndex(_baac, _ceb, _e.ThemeType, _cde+1, _cee); _ggdf != nil {
			return _ggdf
		}
	}
	for _eebe, _ddad := range _fbgc._gdcf {
		_acbcf, _eaga := _ddad.ExportToByteArray()
		if _eaga != nil {
			return _eaga
		}
		_cfc := "\u0077\u006f\u0072d\u002f" + _ddad.TargetAttr[:len(_ddad.TargetAttr)-4] + "\u002e\u0062\u0069\u006e"
		if _bgfe := _db.AddFileFromBytes(_baac, _cfc, _acbcf); _bgfe != nil {
			return _bgfe
		}
		if _ceda := _db.MarshalXMLByTypeIndex(_baac, _ceb, _e.ControlType, _eebe+1, _ddad.Ocx); _ceda != nil {
			return _ceda
		}
	}
	for _dgc, _dged := range _fbgc._aaad {
		_bbae := _e.AbsoluteFilename(_ceb, _e.HeaderType, _dgc+1)
		if _dgeaf := _db.MarshalXML(_baac, _bbae, _dged); _dgeaf != nil {
			return _dgeaf
		}
		if !_fbgc._dgea[_dgc].IsEmpty() {
			_db.MarshalXML(_baac, _db.RelationsPathFor(_bbae), _fbgc._dgea[_dgc].X())
		}
	}
	for _eae, _cgba := range _fbgc._bcf {
		_cgd := _e.AbsoluteFilename(_ceb, _e.FooterType, _eae+1)
		if _aaea := _db.MarshalXMLByTypeIndex(_baac, _ceb, _e.FooterType, _eae+1, _cgba); _aaea != nil {
			return _aaea
		}
		if !_fbgc._fce[_eae].IsEmpty() {
			_db.MarshalXML(_baac, _db.RelationsPathFor(_cgd), _fbgc._fce[_eae].X())
		}
	}
	for _ecd, _gfc := range _fbgc.Images {
		if _ffdad := _ee.AddImageToZip(_baac, _gfc, _ecd+1, _e.DocTypeDocument); _ffdad != nil {
			return _ffdad
		}
	}
	for _dba, _def := range _fbgc._gbg {
		_bebe := _e.AbsoluteFilename(_ceb, _e.ChartType, _dba+1)
		_db.MarshalXML(_baac, _bebe, _def._cfga)
	}
	if _badg := _db.MarshalXML(_baac, _e.ContentTypesFilename, _fbgc.ContentTypes.X()); _badg != nil {
		return _badg
	}
	if _efg := _fbgc.WriteExtraFiles(_baac); _efg != nil {
		return _efg
	}
	return _baac.Close()
}

// Paragraph is a paragraph within a document.
type Paragraph struct {
	_eaefb *Document
	_bbff  *_deg.CT_P
}

// SetKeepNext controls if the paragraph is kept with the next paragraph.
func (_gbeb ParagraphStyleProperties) SetKeepNext(b bool) {
	if !b {
		_gbeb._dgebc.KeepNext = nil
	} else {
		_gbeb._dgebc.KeepNext = _deg.NewCT_OnOff()
	}
}

// SetVerticalMerge controls the vertical merging of cells.
func (_eda CellProperties) SetVerticalMerge(mergeVal _deg.ST_Merge) {
	if mergeVal == _deg.ST_MergeUnset {
		_eda._cbb.VMerge = nil
	} else {
		_eda._cbb.VMerge = _deg.NewCT_VMerge()
		_eda._cbb.VMerge.ValAttr = mergeVal
	}
}

// SetASCIITheme sets the font ASCII Theme.
func (_fefc Fonts) SetASCIITheme(t _deg.ST_Theme) { _fefc._gddaa.AsciiThemeAttr = t }
func (_bdce *Document) appendTable(_fbbe *Paragraph, _ggeg Table, _gffc bool) Table {
	_geecc := _bdce._effc.Body
	_cab := _deg.NewEG_BlockLevelElts()
	_bdce._effc.Body.EG_BlockLevelElts = append(_bdce._effc.Body.EG_BlockLevelElts, _cab)
	_afd := _deg.NewEG_ContentBlockContent()
	_cab.BlockLevelEltsChoice.EG_ContentBlockContent = append(_cab.BlockLevelEltsChoice.EG_ContentBlockContent, _afd)
	if _fbbe != nil {
		_bdbd := _fbbe.X()
		for _afbdb, _edef := range _geecc.EG_BlockLevelElts {
			for _, _dbbe := range _edef.BlockLevelEltsChoice.EG_ContentBlockContent {
				for _addd, _aaac := range _afd.ContentBlockContentChoice.P {
					if _aaac == _bdbd {
						_bbac := _ggeg.X()
						_fbab := _deg.NewEG_BlockLevelElts()
						_gef := _deg.NewEG_ContentBlockContent()
						_fbab.BlockLevelEltsChoice.EG_ContentBlockContent = append(_fbab.BlockLevelEltsChoice.EG_ContentBlockContent, _gef)
						_gef.ContentBlockContentChoice.Tbl = append(_gef.ContentBlockContentChoice.Tbl, _bbac)
						_geecc.EG_BlockLevelElts = append(_geecc.EG_BlockLevelElts, nil)
						if _gffc {
							copy(_geecc.EG_BlockLevelElts[_afbdb+1:], _geecc.EG_BlockLevelElts[_afbdb:])
							_geecc.EG_BlockLevelElts[_afbdb] = _fbab
							if _addd != 0 {
								_gac := _deg.NewEG_BlockLevelElts()
								_bcce := _deg.NewEG_ContentBlockContent()
								_gac.BlockLevelEltsChoice.EG_ContentBlockContent = append(_gac.BlockLevelEltsChoice.EG_ContentBlockContent, _bcce)
								_bcce.ContentBlockContentChoice.P = _dbbe.ContentBlockContentChoice.P[:_addd]
								_geecc.EG_BlockLevelElts = append(_geecc.EG_BlockLevelElts, nil)
								copy(_geecc.EG_BlockLevelElts[_afbdb+1:], _geecc.EG_BlockLevelElts[_afbdb:])
								_geecc.EG_BlockLevelElts[_afbdb] = _gac
							}
							_dbbe.ContentBlockContentChoice.P = _dbbe.ContentBlockContentChoice.P[_addd:]
						} else {
							copy(_geecc.EG_BlockLevelElts[_afbdb+2:], _geecc.EG_BlockLevelElts[_afbdb+1:])
							_geecc.EG_BlockLevelElts[_afbdb+1] = _fbab
							if _addd != len(_dbbe.ContentBlockContentChoice.P)-1 {
								_aef := _deg.NewEG_BlockLevelElts()
								_egc := _deg.NewEG_ContentBlockContent()
								_aef.BlockLevelEltsChoice.EG_ContentBlockContent = append(_aef.BlockLevelEltsChoice.EG_ContentBlockContent, _egc)
								_egc.ContentBlockContentChoice.P = _dbbe.ContentBlockContentChoice.P[_addd+1:]
								_geecc.EG_BlockLevelElts = append(_geecc.EG_BlockLevelElts, nil)
								copy(_geecc.EG_BlockLevelElts[_afbdb+3:], _geecc.EG_BlockLevelElts[_afbdb+2:])
								_geecc.EG_BlockLevelElts[_afbdb+2] = _aef
							}
							_dbbe.ContentBlockContentChoice.P = _dbbe.ContentBlockContentChoice.P[:_addd+1]
						}
						break
					}
				}
				for _, _fgc := range _dbbe.ContentBlockContentChoice.Tbl {
					_cce := _ageec(_fgc, _bdbd, _gffc)
					if _cce != nil {
						break
					}
				}
			}
		}
	} else {
		_afd.ContentBlockContentChoice.Tbl = append(_afd.ContentBlockContentChoice.Tbl, _ggeg.X())
	}
	return Table{_bdce, _ggeg.X()}
}

var _gfcb = [...]uint8{0, 20, 37, 58, 79}

// GetImageObjByRelId returns a common.Image with the associated relation ID in the
// document.
func (_dfcb *Document) GetImageObjByRelId(relId string) (_ee.Image, error) {
	_bcec := _dfcb._afff.GetTargetByRelIdAndType(relId, _e.ImageType)
	if _bcec == "" {
		for _, _dcc := range _dfcb._dgea {
			if _bcec != "" {
				break
			}
			_bcec = _dcc.GetTargetByRelIdAndType(relId, _e.ImageType)
		}
	}
	if _bcec == "" {
		for _, _bafc := range _dfcb._fce {
			if _bcec != "" {
				break
			}
			_bcec = _bafc.GetTargetByRelIdAndType(relId, _e.ImageType)
		}
	}
	return _dfcb.DocBase.GetImageBytesByTarget(_bcec)
}

// AddFootnote will create a new footnote and attach it to the Paragraph in the
// location at the end of the previous run (footnotes create their own run within
// the paragraph). The text given to the function is simply a convenience helper,
// paragraphs and runs can always be added to the text of the footnote later.
func (_bebcd Paragraph) AddFootnote(text string) Footnote {
	var _cdaf int64
	if _bebcd._eaefb.HasFootnotes() {
		for _, _eaafc := range _bebcd._eaefb.Footnotes() {
			if _eaafc.id() > _cdaf {
				_cdaf = _eaafc.id()
			}
		}
		_cdaf++
	} else {
		_bebcd._eaefb.addFootnotes()
		_cdaf = 1
	}
	_beed := _deg.NewCT_FtnEdn()
	_acdc := _deg.NewCT_FtnEdnRef()
	_acdc.IdAttr = _cdaf
	_bebcd._eaefb._daaf.CT_Footnotes.Footnote = append(_bebcd._eaefb._daaf.CT_Footnotes.Footnote, _beed)
	_bfff := _bebcd.AddRun()
	_dagae := _bfff.Properties()
	_dagae.SetStyle(_adb)
	_bfff._gabc.EG_RunInnerContent = []*_deg.EG_RunInnerContent{_deg.NewEG_RunInnerContent()}
	_bfff._gabc.EG_RunInnerContent[0].RunInnerContentChoice.FootnoteReference = _acdc
	_cggeb := Footnote{_bebcd._eaefb, _beed}
	_cggeb._cfca.IdAttr = _cdaf
	_cggeb._cfca.EG_BlockLevelElts = []*_deg.EG_BlockLevelElts{_deg.NewEG_BlockLevelElts()}
	_bcbe := _cggeb.AddParagraph()
	_bcbe.Properties().SetStyle(FootnoteTextStyleId)
	_bcbe._bbff.PPr.RPr = _deg.NewCT_ParaRPr()
	_dfea := _bcbe.AddRun()
	_cegc := _dfea.Properties()
	_cegc.SetStyle(_adb)
	_dfea.AddFootnoteReference()
	_egeaa := _bcbe.AddRun()
	_egeaa.AddText("\u0020")
	_egeaa = _bcbe.AddRun()
	_egeaa.AddText(text)
	return _cggeb
}

// ComplexSizeMeasure returns font with its measure which can be mm, cm, in, pt, pc or pi.
func (_eddf RunProperties) ComplexSizeMeasure() string {
	if _eecab := _eddf._bfed.SzCs; _eecab != nil {
		_abdag := _eecab.ValAttr
		if _abdag.ST_PositiveUniversalMeasure != nil {
			return *_abdag.ST_PositiveUniversalMeasure
		}
	}
	return ""
}

// SetBasedOn sets the style that this style is based on.
func (_ddae Style) SetBasedOn(name string) {
	if name == "" {
		_ddae._bageg.BasedOn = nil
	} else {
		_ddae._bageg.BasedOn = _deg.NewCT_String()
		_ddae._bageg.BasedOn.ValAttr = name
	}
}
func _efegf() *_dc.OfcLock {
	_baee := _dc.NewOfcLock()
	_baee.ExtAttr = _dc.ST_ExtEdit
	_baee.AspectratioAttr = _fae.ST_TrueFalseTrue
	return _baee
}

// SetChecked marks a FormFieldTypeCheckBox as checked or unchecked.
func (_ffbcf FormField) SetChecked(b bool) {
	if len(_ffbcf._bgcg.FFDataChoice) == 0 {
		return
	}
	for _, _fgeb := range _ffbcf._bgcg.FFDataChoice {
		if _fgeb.CheckBox != nil {
			if !b {
				_fgeb.CheckBox.Checked = nil
			} else {
				_fgeb.CheckBox.Checked = _deg.NewCT_OnOff()
			}
		}
	}
}

// X returns the inner wrapped XML type.
func (_fbgec Run) X() *_deg.CT_R { return _fbgec._gabc }

// SetBetween sets the between border to a specified type, color and thickness between paragraph.
func (_febb ParagraphBorders) SetBetween(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_febb._gdbad.Between = _deg.NewCT_Border()
	_dcfaff(_febb._gdbad.Between, t, c, thickness)
}

// SetInsideHorizontal sets the interior horizontal borders to a specified type, color and thickness.
func (_aefc TableBorders) SetInsideHorizontal(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_aefc._cadbb.InsideH = _deg.NewCT_Border()
	_bgdcd(_aefc._cadbb.InsideH, t, c, thickness)
}

// Paragraphs returns the paragraphs defined in the cell.
func (_eff Cell) Paragraphs() []Paragraph {
	_eg := []Paragraph{}
	for _, _dga := range _eff._fdf.EG_BlockLevelElts {
		for _, _bdedc := range _dga.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _, _dbeeg := range _bdedc.ContentBlockContentChoice.P {
				_eg = append(_eg, Paragraph{_eff._dff, _dbeeg})
			}
		}
	}
	return _eg
}

// GetChartSpaceByRelId returns a *crt.ChartSpace with the associated relation ID in the
// document.
func (_bdgc *Document) GetChartSpaceByRelId(relId string) *_bd.ChartSpace {
	_gaeb := _bdgc._afff.GetTargetByRelId(relId)
	for _, _bfdfb := range _bdgc._gbg {
		if _gaeb == _bfdfb.Target() {
			return _bfdfb._cfga
		}
	}
	return nil
}

// Save writes the document to an io.Writer in the Zip package format.
func (_eeb *Document) Save(w _ga.Writer) error { return _eeb.save(w, _eeb._cfgg) }

// Endnote returns the endnote based on the ID; this can be used nicely with
// the run.IsEndnote() functionality.
func (_fbcf *Document) Endnote(id int64) Endnote {
	for _, _cfa := range _fbcf.Endnotes() {
		if _cfa.id() == id {
			return _cfa
		}
	}
	return Endnote{}
}

// RemoveParagraph removes a paragraph from a document.
func (_bgdf *Document) RemoveParagraph(p Paragraph) {
	if _bgdf._effc.Body == nil {
		return
	}
	for _, _gbfa := range _bgdf._effc.Body.EG_BlockLevelElts {
		for _, _ddfd := range _gbfa.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _bbd, _gfgg := range _ddfd.ContentBlockContentChoice.P {
				if _gfgg == p._bbff {
					copy(_ddfd.ContentBlockContentChoice.P[_bbd:], _ddfd.ContentBlockContentChoice.P[_bbd+1:])
					_ddfd.ContentBlockContentChoice.P = _ddfd.ContentBlockContentChoice.P[0 : len(_ddfd.ContentBlockContentChoice.P)-1]
					return
				}
			}
			if _ddfd.ContentBlockContentChoice.Sdt != nil && _ddfd.ContentBlockContentChoice.Sdt.SdtContent != nil {
				for _, _fdcd := range _ddfd.ContentBlockContentChoice.Sdt.SdtContent.EG_ContentBlockContent {
					for _gbbe, _geed := range _fdcd.ContentBlockContentChoice.P {
						if _geed == p._bbff {
							copy(_ddfd.ContentBlockContentChoice.P[_gbbe:], _ddfd.ContentBlockContentChoice.P[_gbbe+1:])
							_ddfd.ContentBlockContentChoice.P = _ddfd.ContentBlockContentChoice.P[0 : len(_ddfd.ContentBlockContentChoice.P)-1]
							return
						}
					}
				}
			}
		}
	}
	for _, _ffeaa := range _bgdf.Tables() {
		for _, _bdcc := range _ffeaa.Rows() {
			for _, _dbdc := range _bdcc.Cells() {
				for _, _dcfa := range _dbdc._fdf.EG_BlockLevelElts {
					for _, _aaee := range _dcfa.BlockLevelEltsChoice.EG_ContentBlockContent {
						for _gbbg, _aabg := range _aaee.ContentBlockContentChoice.P {
							if _aabg == p._bbff {
								copy(_aaee.ContentBlockContentChoice.P[_gbbg:], _aaee.ContentBlockContentChoice.P[_gbbg+1:])
								_aaee.ContentBlockContentChoice.P = _aaee.ContentBlockContentChoice.P[0 : len(_aaee.ContentBlockContentChoice.P)-1]
								return
							}
						}
					}
				}
			}
		}
	}
	for _, _fgca := range _bgdf.Headers() {
		_fgca.RemoveParagraph(p)
	}
	for _, _bfddd := range _bgdf.Footers() {
		_bfddd.RemoveParagraph(p)
	}
}
func (_bgfgb Footnote) id() int64 { return _bgfgb._cfca.IdAttr }

// SetBottom sets the cell bottom margin
func (_cbg CellMargins) SetBottom(d _cdg.Distance) {
	_cbg._fee.Bottom = _deg.NewCT_TblWidth()
	_gecb(_cbg._fee.Bottom, d)
}

// SetSpacing sets the spacing that comes before and after the paragraph.
// Deprecated: See Spacing() instead which allows finer control.
func (_edea ParagraphProperties) SetSpacing(before, after _cdg.Distance) {
	if _edea._adegb.Spacing == nil {
		_edea._adegb.Spacing = _deg.NewCT_Spacing()
	}
	_edea._adegb.Spacing.BeforeAttr = &_fae.ST_TwipsMeasure{}
	_edea._adegb.Spacing.BeforeAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(before / _cdg.Twips))
	_edea._adegb.Spacing.AfterAttr = &_fae.ST_TwipsMeasure{}
	_edea._adegb.Spacing.AfterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(after / _cdg.Twips))
}

// X return element of Node as interface, can be either *Paragraph, *Table and Run.
func (_bdfg *Node) X() interface{} { return _bdfg._bbbg }
func _dfbe(_dbcd Paragraph) *_deg.CT_NumPr {
	_dbcd.ensurePPr()
	if _dbcd._bbff.PPr.NumPr == nil {
		return nil
	}
	return _dbcd._bbff.PPr.NumPr
}

// RemoveRun removes a child run from a paragraph.
func (_eecac Paragraph) RemoveRun(r Run) {
	for _, _bbgb := range _eecac._bbff.EG_PContent {
		for _cfce, _eefgb := range _bbgb.PContentChoice.EG_ContentRunContent {
			if _eefgb.ContentRunContentChoice.R == r._gabc {
				copy(_bbgb.PContentChoice.EG_ContentRunContent[_cfce:], _bbgb.PContentChoice.EG_ContentRunContent[_cfce+1:])
				_bbgb.PContentChoice.EG_ContentRunContent = _bbgb.PContentChoice.EG_ContentRunContent[0 : len(_bbgb.PContentChoice.EG_ContentRunContent)-1]
			}
			if _eefgb.ContentRunContentChoice.Sdt != nil && _eefgb.ContentRunContentChoice.Sdt.SdtContent != nil {
				for _, _eaaa := range _eefgb.ContentRunContentChoice.Sdt.SdtContent.EG_PContent {
					for _baagc, _accda := range _eaaa.PContentChoice.EG_ContentRunContent {
						if _accda.ContentRunContentChoice.R == r._gabc {
							copy(_eaaa.PContentChoice.EG_ContentRunContent[_baagc:], _eaaa.PContentChoice.EG_ContentRunContent[_baagc+1:])
							_eaaa.PContentChoice.EG_ContentRunContent = _eaaa.PContentChoice.EG_ContentRunContent[0 : len(_eaaa.PContentChoice.EG_ContentRunContent)-1]
						}
					}
				}
			}
		}
	}
}

// BodySection returns the default body section used for all preceding
// paragraphs until the previous Section. If there is no previous sections, the
// body section applies to the entire document.
func (_bgd *Document) BodySection() Section {
	if _bgd._effc.Body.SectPr == nil {
		_bgd._effc.Body.SectPr = _deg.NewCT_SectPr()
	}
	return Section{_bgd, _bgd._effc.Body.SectPr}
}

// SetReflectionImageEffect sets the reflection image effect.
func (_dcf AnchoredDrawing) SetReflectionImageEffect(radius _cdg.Distance, opacity, size float64) {
	_ddg := _cdg.ToEMU(float64(radius))
	_bff := "\u002d1\u0030\u0030\u0030\u0030\u0030"
	for _, _ca := range _dcf._bgc.Graphic.GraphicData.Any {
		if _ddd, _cga := _ca.(*_gg.Pic); _cga {
			_dcf.initializeEffectList(_ddd.SpPr)
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection = _ad.NewCT_ReflectionEffect()
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.BlurRadAttr = &_ddg
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.AlgnAttr = _ad.ST_RectAlignmentBl
			_eef := false
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.RotWithShapeAttr = &_eef
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.StAAttr = &_ad.ST_PositiveFixedPercentage{}
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.StAAttr.ST_PositiveFixedPercentageDecimal = _e.Int32(int32(opacity * 1000))
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.EndPosAttr = &_ad.ST_PositiveFixedPercentage{}
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.EndPosAttr.ST_PositiveFixedPercentageDecimal = _e.Int32(int32(size * 1000))
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.SyAttr = &_ad.ST_Percentage{}
			_ddd.SpPr.EffectPropertiesChoice.EffectLst.Reflection.SyAttr.ST_Percentage = &_bff
		}
	}
	_, _dg := _dcf.GetSize()
	_dg = _dg * int64(size) / 100
	_dcf.setEffectExtent(_dg, _ddg, _ddg, _ddg)
}

// SetTop sets the top border to a specified type, color and thickness.
func (_ebag ParagraphBorders) SetTop(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_ebag._gdbad.Top = _deg.NewCT_Border()
	_dcfaff(_ebag._gdbad.Top, t, c, thickness)
}

// SetTopPct sets the cell top margin
func (_ffda CellMargins) SetTopPct(pct float64) {
	_ffda._fee.Top = _deg.NewCT_TblWidth()
	_cfgb(_ffda._fee.Top, pct)
}

// Definitions returns the defined numbering definitions.
func (_fdeb Numbering) Definitions() []NumberingDefinition {
	_ebdg := []NumberingDefinition{}
	if _fdeb._gcfa != nil {
		for _, _fbbab := range _fdeb._gcfa.AbstractNum {
			_ebdg = append(_ebdg, NumberingDefinition{_fbbab})
		}
	}
	return _ebdg
}

// SetNumberingDefinition sets the numbering definition ID via a NumberingDefinition
// defined in numbering.xml
func (_abdef Paragraph) SetNumberingDefinition(nd NumberingDefinition) {
	_abdef.ensurePPr()
	if _abdef._bbff.PPr.NumPr == nil {
		_abdef._bbff.PPr.NumPr = _deg.NewCT_NumPr()
	}
	_bbdeb := _deg.NewCT_DecimalNumber()
	_aaebg := int64(-1)
	for _, _dfce := range _abdef._eaefb.Numbering._gcfa.Num {
		if _dfce.AbstractNumId != nil && _dfce.AbstractNumId.ValAttr == nd.AbstractNumberID() {
			_aaebg = _dfce.NumIdAttr
		}
	}
	if _aaebg == -1 {
		_bcbaa := _deg.NewCT_Num()
		_abdef._eaefb.Numbering._gcfa.Num = append(_abdef._eaefb.Numbering._gcfa.Num, _bcbaa)
		_bcbaa.NumIdAttr = int64(len(_abdef._eaefb.Numbering._gcfa.Num))
		_bcbaa.AbstractNumId = _deg.NewCT_DecimalNumber()
		_bcbaa.AbstractNumId.ValAttr = nd.AbstractNumberID()
		_aaebg = _bcbaa.NumIdAttr
	}
	_bbdeb.ValAttr = _aaebg
	_abdef._bbff.PPr.NumPr.NumId = _bbdeb
}

// SetVAlignment sets the vertical alignment for an anchored image.
func (_cf AnchoredDrawing) SetVAlignment(v _deg.WdST_AlignV) {
	_cf._bgc.PositionV.PosVChoice = &_deg.WdCT_PosVChoice{}
	_cf._bgc.PositionV.PosVChoice.Align = v
}
func (_afgef *WatermarkPicture) getShapeImagedata() *_e.XSDAny {
	return _afgef.getInnerElement("\u0069m\u0061\u0067\u0065\u0064\u0061\u0074a")
}

// Endnote is an individual endnote reference within the document.
type Endnote struct {
	_eecgf *Document
	_cfda  *_deg.CT_FtnEdn
}

func _aaadg(_gfba *Document, _aecg []*_deg.CT_P, _eged *TableInfo, _eafd *DrawingInfo) []Node {
	_adaeea := []Node{}
	for _, _beaba := range _aecg {
		_adgcc := Paragraph{_gfba, _beaba}
		_dbeaa := Node{_cdfa: _gfba, _bbbg: &_adgcc}
		if _dbedd, _efbfc := _gfba.Styles.SearchStyleById(_adgcc.Style()); _efbfc {
			_dbeaa.Style = _dbedd
		}
		for _, _ddabd := range _adgcc.Runs() {
			_dbeaa.Children = append(_dbeaa.Children, Node{_cdfa: _gfba, _bbbg: _ddabd, AnchoredDrawings: _ddabd.DrawingAnchored(), InlineDrawings: _ddabd.DrawingInline()})
		}
		_adaeea = append(_adaeea, _dbeaa)
	}
	return _adaeea
}

// SetKeepWithNext controls if this paragraph should be kept with the next.
func (_adaa ParagraphProperties) SetKeepWithNext(b bool) {
	if !b {
		_adaa._adegb.KeepNext = nil
	} else {
		_adaa._adegb.KeepNext = _deg.NewCT_OnOff()
	}
}

// NumberingLevel is the definition for numbering for a particular level within
// a NumberingDefinition.
type NumberingLevel struct{ _cdgg *_deg.CT_Lvl }

// AbstractNumberID returns the ID that is unique within all numbering
// definitions that is used to assign the definition to a paragraph.
func (_bfacb NumberingDefinition) AbstractNumberID() int64 { return _bfacb._feab.AbstractNumIdAttr }
func (_gcb *Document) InsertTableAfter(relativeTo Paragraph) Table {
	return _gcb.insertTable(relativeTo, false)
}

// SetSmallCaps sets the run to small caps.
func (_eagae RunProperties) SetSmallCaps(b bool) {
	if !b {
		_eagae._bfed.SmallCaps = nil
	} else {
		_eagae._bfed.SmallCaps = _deg.NewCT_OnOff()
	}
}

// X returns the inner wrapped XML type.
func (_bceac TableConditionalFormatting) X() *_deg.CT_TblStylePr { return _bceac._ccaae }

// AddBreak adds a line break to a run.
func (_dbadf Run) AddBreak() {
	_ecbbcf := _dbadf.newIC()
	_ecbbcf.RunInnerContentChoice.Br = _deg.NewCT_Br()
}

// RemoveParagraph removes a paragraph from a footer.
func (_edge Header) RemoveParagraph(p Paragraph) {
	for _, _acg := range _edge._efadbc.EG_BlockLevelElts {
		for _, _edgg := range _acg.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _ccdgf, _cfbd := range _edgg.ContentBlockContentChoice.P {
				if _cfbd == p._bbff {
					copy(_edgg.ContentBlockContentChoice.P[_ccdgf:], _edgg.ContentBlockContentChoice.P[_ccdgf+1:])
					_edgg.ContentBlockContentChoice.P = _edgg.ContentBlockContentChoice.P[0 : len(_edgg.ContentBlockContentChoice.P)-1]
					return
				}
			}
		}
	}
}

// Outline returns true if run outline is on.
func (_dgcff RunProperties) Outline() bool { return _dabbe(_dgcff._bfed.Outline) }

// SetSize sets the font size for a run.
func (_ebcfc RunProperties) SetSize(size _cdg.Distance) {
	_ebcfc._bfed.Sz = _deg.NewCT_HpsMeasure()
	_ebcfc._bfed.Sz.ValAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(size / _cdg.HalfPoint))
	_ebcfc._bfed.SzCs = _deg.NewCT_HpsMeasure()
	_ebcfc._bfed.SzCs.ValAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(size / _cdg.HalfPoint))
}
func (_eada *chart) X() *_bd.ChartSpace { return _eada._cfga }

// SetKeepOnOnePage controls if all lines in a paragraph are kept on the same
// page.
func (_ebdfa ParagraphStyleProperties) SetKeepOnOnePage(b bool) {
	if !b {
		_ebdfa._dgebc.KeepLines = nil
	} else {
		_ebdfa._dgebc.KeepLines = _deg.NewCT_OnOff()
	}
}

// X returns the inner wrapped XML type.
func (_ecgfe Row) X() *_deg.CT_Row { return _ecgfe._ebcb }

// SetVerticalBanding controls the conditional formatting for vertical banding.
func (_ddgac TableLook) SetVerticalBanding(on bool) {
	if !on {
		_ddgac._bfdc.NoVBandAttr = &_fae.ST_OnOff{}
		_ddgac._bfdc.NoVBandAttr.ST_OnOff1 = _fae.ST_OnOff1On
	} else {
		_ddgac._bfdc.NoVBandAttr = &_fae.ST_OnOff{}
		_ddgac._bfdc.NoVBandAttr.ST_OnOff1 = _fae.ST_OnOff1Off
	}
}

// TableProperties are the properties for a table within a document
type TableProperties struct{ _gafba *_deg.CT_TblPr }

// SetAfter sets the spacing that comes after the paragraph.
func (_gfgbbg ParagraphSpacing) SetAfter(after _cdg.Distance) {
	_gfgbbg._gdfc.AfterAttr = &_fae.ST_TwipsMeasure{}
	_gfgbbg._gdfc.AfterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(after / _cdg.Twips))
}

// AddTable adds a table to the footer.
func (_eggg Footer) AddTable() Table {
	_aebad := _deg.NewEG_ContentBlockContent()
	_eggg._aabd.EG_BlockLevelElts = append(_eggg._aabd.EG_BlockLevelElts, &_deg.EG_BlockLevelElts{BlockLevelEltsChoice: &_deg.EG_BlockLevelEltsChoice{EG_ContentBlockContent: []*_deg.EG_ContentBlockContent{_aebad}}})
	_bfdge := _deg.NewCT_Tbl()
	_aebad.ContentBlockContentChoice.Tbl = append(_aebad.ContentBlockContentChoice.Tbl, _bfdge)
	return Table{_eggg._abba, _bfdge}
}

// Comment returns comment associated with given id.
func (_cdfcc *Document) Comment(id int64) Comment {
	for _, _adaf := range _cdfcc.Comments() {
		if _adaf.id() == id {
			return _adaf
		}
	}
	return Comment{}
}

// SetStyle sets the table style name.
func (_dgdfb TableProperties) SetStyle(name string) {
	if name == "" {
		_dgdfb._gafba.TblStyle = nil
	} else {
		_dgdfb._gafba.TblStyle = _deg.NewCT_String()
		_dgdfb._gafba.TblStyle.ValAttr = name
	}
}

// DocRels returns document relationship.
func (_cbae *Document) DocRels() _ee.Relationships { return _cbae._afff }

// SetDoubleStrikeThrough sets the run to double strike-through.
func (_dbge RunProperties) SetDoubleStrikeThrough(b bool) {
	if !b {
		_dbge._bfed.Dstrike = nil
	} else {
		_dbge._bfed.Dstrike = _deg.NewCT_OnOff()
	}
}

// AddRun adds a run to a paragraph.
func (_bdge Paragraph) AddRun() Run {
	_ggad := _deg.NewEG_PContent()
	_bdge._bbff.EG_PContent = append(_bdge._bbff.EG_PContent, _ggad)
	_dbgf := _deg.NewEG_ContentRunContent()
	_ggad.PContentChoice.EG_ContentRunContent = append(_ggad.PContentChoice.EG_ContentRunContent, _dbgf)
	_dbff := _deg.NewCT_R()
	_dbgf.ContentRunContentChoice.R = _dbff
	return Run{_bdge._eaefb, _dbff}
}

// FindNodeByStyleName return slice of node base on style name.
func (_bfde *Nodes) FindNodeByStyleName(styleName string) []Node {
	_cdgf := []Node{}
	for _, _dgdb := range _bfde._aebcgc {
		switch _aefgb := _dgdb._bbbg.(type) {
		case *Paragraph:
			if _aefgb != nil {
				if _aabdc, _cdffa := _dgdb._cdfa.Styles.SearchStyleByName(styleName); _cdffa {
					_afcdb := _aefgb.Style()
					if _afcdb == _aabdc.StyleID() {
						_cdgf = append(_cdgf, _dgdb)
					}
				}
			}
		case *Table:
			if _aefgb != nil {
				if _fded, _abdgb := _dgdb._cdfa.Styles.SearchStyleByName(styleName); _abdgb {
					_aeddc := _aefgb.Style()
					if _aeddc == _fded.StyleID() {
						_cdgf = append(_cdgf, _dgdb)
					}
				}
			}
		}
		_dada := Nodes{_aebcgc: _dgdb.Children}
		_cdgf = append(_cdgf, _dada.FindNodeByStyleName(styleName)...)
	}
	return _cdgf
}

// AddStyle adds a new empty style, if styleID is already exists, it will return the style.
func (_fgcb Styles) AddStyle(styleID string, t _deg.ST_StyleType, isDefault bool) Style {
	if _eaeed, _fedee := _fgcb.SearchStyleById(styleID); _fedee {
		return _eaeed
	}
	_ddgba := _deg.NewCT_Style()
	_ddgba.TypeAttr = t
	if isDefault {
		_ddgba.DefaultAttr = &_fae.ST_OnOff{}
		_ddgba.DefaultAttr.Bool = _e.Bool(isDefault)
	}
	_ddgba.StyleIdAttr = _e.String(styleID)
	_fgcb._cegfc.Style = append(_fgcb._cegfc.Style, _ddgba)
	return Style{_ddgba}
}
func (_cgcdf Paragraph) addStartComment(_egcfb int64) *_deg.CT_MarkupRange {
	_agcff := _deg.NewEG_PContent()
	_cgcdf._bbff.EG_PContent = append(_cgcdf._bbff.EG_PContent, _agcff)
	_ggfbf := _deg.NewEG_ContentRunContent()
	_fffe := _deg.NewEG_RunLevelElts()
	_acegb := _deg.NewEG_RangeMarkupElements()
	_efega := _deg.NewCT_MarkupRange()
	_efega.IdAttr = _egcfb
	_acegb.RangeMarkupElementsChoice.CommentRangeStart = _efega
	_agcff.PContentChoice.EG_ContentRunContent = append(_agcff.PContentChoice.EG_ContentRunContent, _ggfbf)
	_ggfbf.ContentRunContentChoice.EG_RunLevelElts = append(_ggfbf.ContentRunContentChoice.EG_RunLevelElts, _fffe)
	_fffe.RunLevelEltsChoice.EG_RangeMarkupElements = append(_fffe.RunLevelEltsChoice.EG_RangeMarkupElements, _acegb)
	return _efega
}

// SetEastAsiaTheme sets the font East Asia Theme.
func (_dcdcb Fonts) SetEastAsiaTheme(t _deg.ST_Theme) { _dcdcb._gddaa.EastAsiaThemeAttr = t }

// Borders allows manipulation of the table borders.
func (_fgcd TableStyleProperties) Borders() TableBorders {
	if _fgcd._daffa.TblBorders == nil {
		_fgcd._daffa.TblBorders = _deg.NewCT_TblBorders()
	}
	return TableBorders{_fgcd._daffa.TblBorders}
}

// GetRightToLeft returns true if the run text is displayed from right to left.
func (_dccc RunProperties) GetRightToLeft() bool { return _dabbe(_dccc._bfed.Rtl) }

// SetHangingIndent controls special indent of paragraph.
func (_gfcbd Paragraph) SetHangingIndent(m _cdg.Distance) {
	_gfcbd.ensurePPr()
	_gddaf := _gfcbd._bbff.PPr
	if _gddaf.Ind == nil {
		_gddaf.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_gddaf.Ind.HangingAttr = nil
	} else {
		_gddaf.Ind.HangingAttr = &_fae.ST_TwipsMeasure{}
		_gddaf.Ind.HangingAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _cdg.Twips))
	}
}

// AddTabStop adds a tab stop to the paragraph.  It controls the position of text when using Run.AddTab()
func (_bffdd ParagraphProperties) AddTabStop(position _cdg.Distance, justificaton _deg.ST_TabJc, leader _deg.ST_TabTlc) {
	if _bffdd._adegb.Tabs == nil {
		_bffdd._adegb.Tabs = _deg.NewCT_Tabs()
	}
	_bggbg := _deg.NewCT_TabStop()
	_bggbg.LeaderAttr = leader
	_bggbg.ValAttr = justificaton
	_bggbg.PosAttr.Int64 = _e.Int64(int64(position / _cdg.Twips))
	_bffdd._adegb.Tabs.Tab = append(_bffdd._adegb.Tabs.Tab, _bggbg)
}

// Borders allows manipulation of the table borders.
func (_bccef TableProperties) Borders() TableBorders {
	if _bccef._gafba.TblBorders == nil {
		_bccef._gafba.TblBorders = _deg.NewCT_TblBorders()
	}
	return TableBorders{_bccef._gafba.TblBorders}
}

// SetCharacterSpacing sets the run's Character Spacing Adjustment.
func (_ccef RunProperties) SetCharacterSpacing(size _cdg.Distance) {
	_ccef._bfed.Spacing = _deg.NewCT_SignedTwipsMeasure()
	_ccef._bfed.Spacing.ValAttr.Int64 = _e.Int64(int64(size / _cdg.Twips))
}

// RStyle returns the name of character style.
// It is defined here http://officeopenxml.com/WPstyleCharStyles.php
func (_ccfddc ParagraphProperties) RStyle() string {
	if _ccfddc._adegb.RPr.RStyle != nil {
		return _ccfddc._adegb.RPr.RStyle.ValAttr
	}
	return ""
}

// SetCellSpacingPercent sets the cell spacing within a table to a percent width.
func (_egbe TableProperties) SetCellSpacingPercent(pct float64) {
	_egbe._gafba.TblCellSpacing = _deg.NewCT_TblWidth()
	_egbe._gafba.TblCellSpacing.TypeAttr = _deg.ST_TblWidthPct
	_egbe._gafba.TblCellSpacing.WAttr = &_deg.ST_MeasurementOrPercent{}
	_egbe._gafba.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_egbe._gafba.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(pct * 50))
}

// AddBookmark adds a bookmark to a document that can then be used from a hyperlink. Name is a document
// unique name that identifies the bookmark so it can be referenced from hyperlinks.
func (_edbd Paragraph) AddBookmark(name string) Bookmark {
	_geca := _deg.NewEG_PContent()
	_ecbbc := _deg.NewEG_ContentRunContent()
	_geca.PContentChoice.EG_ContentRunContent = append(_geca.PContentChoice.EG_ContentRunContent, _ecbbc)
	_bcfca := _deg.NewEG_RunLevelElts()
	_ecbbc.ContentRunContentChoice.EG_RunLevelElts = append(_ecbbc.ContentRunContentChoice.EG_RunLevelElts, _bcfca)
	_beeag := _deg.NewEG_RangeMarkupElements()
	_cbef := _deg.NewCT_Bookmark()
	_beeag.RangeMarkupElementsChoice.BookmarkStart = _cbef
	_bcfca.RunLevelEltsChoice.EG_RangeMarkupElements = append(_bcfca.RunLevelEltsChoice.EG_RangeMarkupElements, _beeag)
	_beeag = _deg.NewEG_RangeMarkupElements()
	_beeag.RangeMarkupElementsChoice.BookmarkEnd = _deg.NewCT_MarkupRange()
	_bcfca.RunLevelEltsChoice.EG_RangeMarkupElements = append(_bcfca.RunLevelEltsChoice.EG_RangeMarkupElements, _beeag)
	_edbd._bbff.EG_PContent = append(_edbd._bbff.EG_PContent, _geca)
	_adba := Bookmark{_cbef}
	_adba.SetName(name)
	return _adba
}

// TableStyleProperties are table properties as defined in a style.
type TableStyleProperties struct{ _daffa *_deg.CT_TblPrBase }

func (_ccfdd *Node) Remove() {
	switch _dbcb := _ccfdd.X().(type) {
	case *Paragraph:
		_ccfdd._cdfa.RemoveParagraph(*_dbcb)
	case *Table:
		_ccfdd._cdfa.RemoveTable(*_dbcb)
	default:
		_gd.Log.Debug("\u004e\u006f\u0064e \u0074\u0079\u0070\u0065\u0020\u006e\u006f\u0074\u0020\u0073\u0075\u0070\u0070\u006f\u0072\u0074\u0065\u0064")
	}
	for _, _deae := range _ccfdd.Children {
		_deae.Remove()
	}
}
func _ccec() *_dc.Fill { _ffcc := _dc.NewFill(); _ffcc.AngleAttr = _e.Float64(0); return _ffcc }

// Table is a table within a document.
type Table struct {
	_dafd  *Document
	_abbae *_deg.CT_Tbl
}

func (_abae Paragraph) addEndComment(_cbfbea int64) *_deg.CT_MarkupRange {
	_ggdfd := _deg.NewEG_PContent()
	_abae._bbff.EG_PContent = append(_abae._bbff.EG_PContent, _ggdfd)
	_bfeeg := _deg.NewEG_ContentRunContent()
	_debe := _deg.NewEG_RunLevelElts()
	_gfda := _deg.NewEG_RangeMarkupElements()
	_bcag := _deg.NewCT_MarkupRange()
	_bcag.IdAttr = _cbfbea
	_gfda.RangeMarkupElementsChoice.CommentRangeEnd = _bcag
	_ggdfd.PContentChoice.EG_ContentRunContent = append(_ggdfd.PContentChoice.EG_ContentRunContent, _bfeeg)
	_bfeeg.ContentRunContentChoice.EG_RunLevelElts = append(_bfeeg.ContentRunContentChoice.EG_RunLevelElts, _debe)
	_debe.RunLevelEltsChoice.EG_RangeMarkupElements = append(_debe.RunLevelEltsChoice.EG_RangeMarkupElements, _gfda)
	return _bcag
}

// SetAlignment set alignment of paragraph.
func (_adgde Paragraph) SetAlignment(alignment _deg.ST_Jc) {
	_adgde.ensurePPr()
	if _adgde._bbff.PPr.Jc == nil {
		_adgde._bbff.PPr.Jc = _deg.NewCT_Jc()
	}
	_adgde._bbff.PPr.Jc.ValAttr = alignment
}

// SetWidthAuto sets the the cell width to automatic.
func (_cfgc CellProperties) SetWidthAuto() {
	_cfgc._cbb.TcW = _deg.NewCT_TblWidth()
	_cfgc._cbb.TcW.TypeAttr = _deg.ST_TblWidthAuto
}

// SetLeft sets the left border to a specified type, color and thickness.
func (_caf CellBorders) SetLeft(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_caf._fba.Left = _deg.NewCT_Border()
	_bgdcd(_caf._fba.Left, t, c, thickness)
}

// Type returns the type of the style.
func (_eabfd Style) Type() _deg.ST_StyleType { return _eabfd._bageg.TypeAttr }

// NewWatermarkText generates a new WatermarkText.
func NewWatermarkText() WatermarkText {
	_gdcdd := _dc.NewShapetype()
	_faeb := _debd()
	_deegea := _bedae()
	_adfb := _dggg()
	_fffec := _fafae()
	_aacf := _fdad()
	_gdcdd.EG_ShapeElements = []*_dc.EG_ShapeElements{{ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Formulas: _faeb}}, {ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Path: _deegea}}, {ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Textpath: _adfb}}, {ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Handles: _fffec}}, {ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Lock: _aacf}}}
	var (
		_afgea = "_\u0078\u0030\u0030\u0030\u0030\u005f\u0074\u0031\u0033\u0036"
		_abbga = "2\u0031\u0036\u0030\u0030\u002c\u0032\u0031\u0036\u0030\u0030"
		_cbgaa = float32(136.0)
		_ddbga = "\u0031\u0030\u00380\u0030"
		_defc  = "m\u0040\u0037\u002c\u006c\u0040\u0038,\u006d\u0040\u0035\u002c\u0032\u0031\u0036\u0030\u0030l\u0040\u0036\u002c2\u00316\u0030\u0030\u0065"
	)
	_gdcdd.IdAttr = &_afgea
	_gdcdd.CoordsizeAttr = &_abbga
	_gdcdd.SptAttr = &_cbgaa
	_gdcdd.AdjAttr = &_ddbga
	_gdcdd.PathAttr = &_defc
	_ddac := _dc.NewShape()
	_ddac.ShapeChoice = append(_ddac.ShapeChoice, &_dc.CT_ShapeChoice{ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Fill: _ccec()}})
	_ddac.ShapeChoice = append(_ddac.ShapeChoice, &_dc.CT_ShapeChoice{ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Textpath: _cgcfg()}})
	var (
		_bbbeg = "\u0050\u006f\u0077\u0065\u0072\u0050l\u0075\u0073\u0057\u0061\u0074\u0065\u0072\u004d\u0061\u0072\u006b\u004f\u0062j\u0065\u0063\u0074\u0031\u0033\u0036\u00380\u0030\u0038\u0038\u0036"
		_bedcg = "\u005f\u0078\u00300\u0030\u0030\u005f\u0073\u0032\u0030\u0035\u0031"
		_geddg = "\u0023\u005f\u00780\u0030\u0030\u0030\u005f\u0074\u0031\u0033\u0036"
		_ebgfc = ""
		_aecgb = "\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u003a\u0061bs\u006f\u006c\u0075\u0074\u0065;\u006d\u0061\u0072\u0067\u0069\u006e\u002d\u006c\u0065f\u0074\u003a\u0030\u003b\u006d\u0061\u0072\u0067\u0069\u006e\u002d\u0074\u006f\u0070\u003a\u0030\u003b\u0077\u0069\u0064\u0074h\u003a\u0034\u0036\u0038\u0070\u0074\u003bh\u0065ig\u0068\u0074\u003a\u0032\u0033\u0034p\u0074\u003b\u007a\u002d\u0069\u006e\u0064\u0065x\u003a\u002d\u0032\u00351\u0036\u0035\u0031\u0030\u0037\u0032\u003b\u006d\u0073o\u002d\u0077r\u0061\u0070\u002d\u0065\u0064\u0069\u0074\u0065\u0064\u003a\u0066\u003b\u006d\u0073\u006f\u002d\u0077\u0069\u0064\u0074\u0068\u002d\u0070\u0065\u0072\u0063\u0065\u006e\u0074\u003a\u0030\u003b\u006d\u0073\u006f\u002dh\u0065\u0069\u0067\u0068\u0074\u002dp\u0065\u0072\u0063\u0065\u006e\u0074\u003a\u0030\u003b\u006d\u0073\u006f\u002dp\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u002d\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u003a\u0063\u0065\u006e\u0074\u0065r\u003b\u006d\u0073\u006f\u002d\u0070\u006f\u0073\u0069\u0074\u0069\u006fn\u002d\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u002d\u0072\u0065\u006ca\u0074\u0069\u0076\u0065\u003a\u006d\u0061\u0072\u0067\u0069\u006e\u003b\u006d\u0073\u006f\u002d\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u002d\u0076e\u0072\u0074\u0069\u0063\u0061\u006c\u003a\u0063\u0065\u006e\u0074\u0065\u0072\u003b\u006d\u0073\u006f\u002d\u0070\u006f\u0073\u0069\u0074\u0069o\u006e\u002d\u0076e\u0072\u0074\u0069\u0063\u0061\u006c-\u0072\u0065\u006c\u0061\u0074\u0069v\u0065\u003a\u006d\u0061\u0072\u0067\u0069\u006e;\u006d\u0073\u006f\u002d\u0077\u0069\u0064\u0074\u0068-p\u0065\u0072\u0063\u0065\u006e\u0074:\u0030\u003b\u006d\u0073\u006f-\u0068\u0065\u0069\u0067\u0068\u0074\u002d\u0070\u0065\u0072\u0063\u0065\u006e\u0074\u003a\u0030\u003b"
		_eddb  = "\u0073\u0069\u006c\u0076\u0065\u0072"
	)
	_ddac.IdAttr = &_bbbeg
	_ddac.SpidAttr = &_bedcg
	_ddac.TypeAttr = &_geddg
	_ddac.AltAttr = &_ebgfc
	_ddac.StyleAttr = &_aecgb
	_ddac.AllowincellAttr = _fae.ST_TrueFalseFalse
	_ddac.FillcolorAttr = &_eddb
	_ddac.StrokedAttr = _fae.ST_TrueFalseF
	_dcefbg := _deg.NewCT_Picture()
	_dcefbg.Any = []_e.Any{_gdcdd, _ddac}
	return WatermarkText{_deegd: _dcefbg, _cfbf: _ddac, _dbda: _gdcdd}
}

// Italic returns true if run font is italic.
func (_eegde RunProperties) Italic() bool {
	_bccfb := _eegde._bfed
	return _dabbe(_bccfb.I) || _dabbe(_bccfb.ICs)
}
func _fdfeb(_dgaf *_deg.CT_OnOff) OnOffValue {
	if _dgaf == nil {
		return OnOffValueUnset
	}
	if _dgaf.ValAttr != nil && _dgaf.ValAttr.Bool != nil && *_dgaf.ValAttr.Bool == false {
		return OnOffValueOff
	}
	return OnOffValueOn
}

// StyleID returns the style ID.
func (_fbec Style) StyleID() string {
	if _fbec._bageg.StyleIdAttr == nil {
		return ""
	}
	return *_fbec._bageg.StyleIdAttr
}

// X returns the inner wrapped XML type.
func (_egda Settings) X() *_deg.Settings { return _egda._bbaeb }

// SearchStyleByName return style by its name.
func (_ggaea Styles) SearchStyleByName(name string) (Style, bool) {
	for _, _ceca := range _ggaea._cegfc.Style {
		if _ceca.Name != nil {
			if _ceca.Name.ValAttr == name {
				return Style{_ceca}, true
			}
		}
	}
	return Style{}, false
}

// Outline returns true if paragraph outline is on.
func (_gggea ParagraphProperties) Outline() bool { return _dabbe(_gggea._adegb.RPr.Outline) }

// OpenTemplate opens a document, removing all content so it can be used as a
// template.  Since Word removes unused styles from a document upon save, to
// create a template in Word add a paragraph with every style of interest.  When
// opened with OpenTemplate the document's styles will be available but the
// content will be gone.
func OpenTemplate(filename string) (*Document, error) {
	_abgd, _bdac := Open(filename)
	if _bdac != nil {
		return nil, _bdac
	}
	_abgd._effc.Body = _deg.NewCT_Body()
	return _abgd, nil
}
func (_aadab Paragraph) removeCommentRange(_edcb int64) bool {
	_gbcaf := false
	for _, _afbe := range _aadab.X().EG_PContent {
		for _, _acff := range _afbe.PContentChoice.EG_ContentRunContent {
			for _, _dcff := range _acff.ContentRunContentChoice.EG_RunLevelElts {
				for _agae, _eebef := range _dcff.RunLevelEltsChoice.EG_RangeMarkupElements {
					if !_gbcaf && _eebef.RangeMarkupElementsChoice.CommentRangeStart != nil && _eebef.RangeMarkupElementsChoice.CommentRangeStart.IdAttr == _edcb {
						_edaadb := _dcff.RunLevelEltsChoice.EG_RangeMarkupElements[:_agae]
						_edaadb = append(_edaadb, _dcff.RunLevelEltsChoice.EG_RangeMarkupElements[_agae+1:len(_dcff.RunLevelEltsChoice.EG_RangeMarkupElements)]...)
						_dcff.RunLevelEltsChoice.EG_RangeMarkupElements = _edaadb
						_gbcaf = true
					}
					if _gbcaf && _eebef.RangeMarkupElementsChoice.CommentRangeEnd != nil && _eebef.RangeMarkupElementsChoice.CommentRangeEnd.IdAttr == _edcb {
						_bead := _dcff.RunLevelEltsChoice.EG_RangeMarkupElements[:_agae]
						_bead = append(_bead, _dcff.RunLevelEltsChoice.EG_RangeMarkupElements[_agae+1:len(_dcff.RunLevelEltsChoice.EG_RangeMarkupElements)]...)
						_dcff.RunLevelEltsChoice.EG_RangeMarkupElements = _bead
						return true
					}
				}
			}
		}
	}
	return false
}

// SetAlignment controls the paragraph alignment
func (_cgegc ParagraphStyleProperties) SetAlignment(align _deg.ST_Jc) {
	if align == _deg.ST_JcUnset {
		_cgegc._dgebc.Jc = nil
	} else {
		_cgegc._dgebc.Jc = _deg.NewCT_Jc()
		_cgegc._dgebc.Jc.ValAttr = align
	}
}

// HasEndnotes returns a bool based on the presence or abscence of endnotes within
// the document.
func (_bgae *Document) HasEndnotes() bool { return _bgae._ebfb != nil }

// SetColumnBandSize sets the number of Columns in the column band
func (_ebcbd TableStyleProperties) SetColumnBandSize(cols int64) {
	_ebcbd._daffa.TblStyleColBandSize = _deg.NewCT_DecimalNumber()
	_ebcbd._daffa.TblStyleColBandSize.ValAttr = cols
}

// X returns the inner wml.CT_PBdr
func (_ddgca ParagraphBorders) X() *_deg.CT_PBdr { return _ddgca._gdbad }

// TableConditionalFormatting returns a conditional formatting object of a given
// type.  Calling this method repeatedly will return the same object.
func (_ccebc Style) TableConditionalFormatting(typ _deg.ST_TblStyleOverrideType) TableConditionalFormatting {
	for _, _egdb := range _ccebc._bageg.TblStylePr {
		if _egdb.TypeAttr == typ {
			return TableConditionalFormatting{_egdb}
		}
	}
	_dgacf := _deg.NewCT_TblStylePr()
	_dgacf.TypeAttr = typ
	_ccebc._bageg.TblStylePr = append(_ccebc._bageg.TblStylePr, _dgacf)
	return TableConditionalFormatting{_dgacf}
}

// SetTarget sets the URL target of the hyperlink.
func (_gedgd HyperLink) SetTarget(url string) {
	_edaa := _gedgd._babe.AddHyperlink(url)
	_gedgd._babce.IdAttr = _e.String(_ee.Relationship(_edaa).ID())
	_gedgd._babce.AnchorAttr = nil
}

// Bold returns true if paragraph font is bold.
func (_eefgf ParagraphProperties) Bold() bool {
	_fafb := _eefgf._adegb.RPr
	return _dabbe(_fafb.B) || _dabbe(_fafb.BCs)
}

// SetEnabled marks a FormField as enabled or disabled.
func (_acba FormField) SetEnabled(enabled bool) {
	_fbabda := _deg.NewCT_OnOff()
	_fbabda.ValAttr = &_fae.ST_OnOff{Bool: &enabled}
	_acba._bgcg.FFDataChoice = []*_deg.CT_FFDataChoice{{Enabled: _fbabda}}
}

// Nodes return the document's element as nodes.
func (_dfcg *Document) Nodes() Nodes {
	_fdda := []Node{}
	for _, _beag := range _dfcg._effc.Body.EG_BlockLevelElts {
		_fdda = append(_fdda, _bedgd(_dfcg, _beag.BlockLevelEltsChoice.EG_ContentBlockContent, nil)...)
	}
	if _dfcg._effc.Body.SectPr != nil {
		_fdda = append(_fdda, Node{_bbbg: _dfcg._effc.Body.SectPr})
	}
	_fddf := Nodes{_aebcgc: _fdda}
	return _fddf
}

// SetNumberingLevel sets the numbering level of a paragraph.  If used, then the
// NumberingDefinition must also be set via SetNumberingDefinition or
// SetNumberingDefinitionByID.
func (_ecbc Paragraph) SetNumberingLevel(listLevel int) {
	_ecbc.ensurePPr()
	if _ecbc._bbff.PPr.NumPr == nil {
		_ecbc._bbff.PPr.NumPr = _deg.NewCT_NumPr()
	}
	_fgeaa := _deg.NewCT_DecimalNumber()
	_fgeaa.ValAttr = int64(listLevel)
	_ecbc._bbff.PPr.NumPr.Ilvl = _fgeaa
}

// InsertRowBefore inserts a row before another row
func (_cbdc Table) InsertRowBefore(r Row) Row {
	for _dabcc, _eaedd := range _cbdc._abbae.EG_ContentRowContent {
		if len(_eaedd.ContentRowContentChoice.Tr) > 0 && r.X() == _eaedd.ContentRowContentChoice.Tr[0] {
			_cgfc := _deg.NewEG_ContentRowContent()
			_cbdc._abbae.EG_ContentRowContent = append(_cbdc._abbae.EG_ContentRowContent, nil)
			copy(_cbdc._abbae.EG_ContentRowContent[_dabcc+1:], _cbdc._abbae.EG_ContentRowContent[_dabcc:])
			_cbdc._abbae.EG_ContentRowContent[_dabcc] = _cgfc
			_ebadf := _deg.NewCT_Row()
			_cgfc.ContentRowContentChoice.Tr = append(_cgfc.ContentRowContentChoice.Tr, _ebadf)
			return Row{_cbdc._dafd, _ebadf}
		}
	}
	return _cbdc.AddRow()
}

// AddTable adds a new table to the document body.
func (_faeg *Document) AddTable() Table {
	_gdee := _deg.NewEG_BlockLevelElts()
	_faeg._effc.Body.EG_BlockLevelElts = append(_faeg._effc.Body.EG_BlockLevelElts, _gdee)
	_gga := _deg.NewEG_ContentBlockContent()
	_gdee.BlockLevelEltsChoice.EG_ContentBlockContent = append(_gdee.BlockLevelEltsChoice.EG_ContentBlockContent, _gga)
	_dbab := _deg.NewCT_Tbl()
	_gga.ContentBlockContentChoice.Tbl = append(_gga.ContentBlockContentChoice.Tbl, _dbab)
	return Table{_faeg, _dbab}
}

// X returns the inner wrapped XML type.
func (_addbg ParagraphProperties) X() *_deg.CT_PPr { return _addbg._adegb }

// SetPictureWashout set washout to watermark picture.
func (_dfbgc *WatermarkPicture) SetPictureWashout(isWashout bool) {
	if _dfbgc._bfadf != nil {
		_afae := _dfbgc._bfadf.ShapeChoice
		if len(_afae) > 0 && _afae[0].ShapeElementsChoice.Imagedata != nil {
			if isWashout {
				_caag := "\u0031\u0039\u0036\u0036\u0031\u0066"
				_fecb := "\u0032\u0032\u0039\u0033\u0038\u0066"
				_afae[0].ShapeElementsChoice.Imagedata.GainAttr = &_caag
				_afae[0].ShapeElementsChoice.Imagedata.BlacklevelAttr = &_fecb
			}
		}
	}
}

// ReplaceTextByRegexp replace text inside node using regexp.
func (_cgfab *Nodes) ReplaceTextByRegexp(expr *_be.Regexp, newText string) {
	for _, _fgbd := range _cgfab._aebcgc {
		_fgbd.ReplaceTextByRegexp(expr, newText)
	}
}

// Styles is the document wide styles contained in styles.xml.
type Styles struct{ _cegfc *_deg.Styles }

func (_gag *Document) removeFootnote(_ggge int64) {
	_ada := _gag._daaf
	var _dadf int
	for _fcbbc, _gaaa := range _ada.CT_Footnotes.Footnote {
		if _gaaa.IdAttr == _ggge {
			_dadf = _fcbbc
			break
		}
	}
	_ada.CT_Footnotes.Footnote[_dadf] = nil
	_ada.CT_Footnotes.Footnote[_dadf] = _ada.CT_Footnotes.Footnote[len(_ada.CT_Footnotes.Footnote)-1]
	_ada.CT_Footnotes.Footnote = _ada.CT_Footnotes.Footnote[:len(_ada.CT_Footnotes.Footnote)-1]
	_gag.reorderFootnote()
	_gag.syncFootnoteSettings()
}

// CellProperties are a table cells properties within a document.
type CellProperties struct{ _cbb *_deg.CT_TcPr }

func (_gaggc Paragraph) addBeginFldChar(_babcc string) *_deg.CT_FFData {
	_adgb := _gaggc.addFldChar()
	_adgb.FldCharTypeAttr = _deg.ST_FldCharTypeBegin
	if _adgb.FldCharChoice == nil {
		_adgb.FldCharChoice = _deg.NewCT_FldCharChoice()
	}
	_adgb.FldCharChoice.FfData = _deg.NewCT_FFData()
	_fagbc := _deg.NewCT_FFName()
	_fagbc.ValAttr = &_babcc
	_adgb.FldCharChoice.FfData.FFDataChoice = []*_deg.CT_FFDataChoice{&_deg.CT_FFDataChoice{Name: _fagbc}}
	return _adgb.FldCharChoice.FfData
}

// SetDiagonalLayout enables or disables diagonal layout.
// By default, diagonal layout is disabled and we have horizontal layout.
func (_dbdf *WatermarkText) EnableDiagonalLayout(value bool) {
	if _dbdf._cfbf != nil && _dbdf._cfbf.StyleAttr != nil {
		_dfbgg := *_dbdf._cfbf.StyleAttr
		if value {
			_dfbgg += "\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u003a\u0033\u0031\u0035\u003b"
		} else {
			_dfbgg = _ac.ReplaceAll(_dfbgg, "\u0072\u006f\u0074\u0061\u0074\u0069\u006f\u006e\u003a\u0033\u0031\u0035\u003b", "")
		}
		_dbdf._cfbf.StyleAttr = &_dfbgg
	}
}
func (_dfgac Styles) initializeStyleDefaults() {
	_bbcf := _dfgac.AddStyle("\u004e\u006f\u0072\u006d\u0061\u006c", _deg.ST_StyleTypeParagraph, true)
	_bbcf.SetName("\u004e\u006f\u0072\u006d\u0061\u006c")
	_bbcf.SetPrimaryStyle(true)
	_dddea := _dfgac.AddStyle("D\u0065f\u0061\u0075\u006c\u0074\u0050\u0061\u0072\u0061g\u0072\u0061\u0070\u0068Fo\u006e\u0074", _deg.ST_StyleTypeCharacter, true)
	_dddea.SetName("\u0044\u0065\u0066\u0061ul\u0074\u0020\u0050\u0061\u0072\u0061\u0067\u0072\u0061\u0070\u0068\u0020\u0046\u006fn\u0074")
	_dddea.SetUISortOrder(1)
	_dddea.SetSemiHidden(true)
	_dddea.SetUnhideWhenUsed(true)
	_ecgdd := _dfgac.AddStyle("\u0054i\u0074\u006c\u0065\u0043\u0068\u0061r", _deg.ST_StyleTypeCharacter, false)
	_ecgdd.SetName("\u0054\u0069\u0074\u006c\u0065\u0020\u0043\u0068\u0061\u0072")
	_ecgdd.SetBasedOn(_dddea.StyleID())
	_ecgdd.SetLinkedStyle("\u0054\u0069\u0074l\u0065")
	_ecgdd.SetUISortOrder(10)
	_ecgdd.RunProperties().Fonts().SetASCIITheme(_deg.ST_ThemeMajorAscii)
	_ecgdd.RunProperties().Fonts().SetEastAsiaTheme(_deg.ST_ThemeMajorEastAsia)
	_ecgdd.RunProperties().Fonts().SetHANSITheme(_deg.ST_ThemeMajorHAnsi)
	_ecgdd.RunProperties().Fonts().SetCSTheme(_deg.ST_ThemeMajorBidi)
	_ecgdd.RunProperties().SetSize(28 * _cdg.Point)
	_ecgdd.RunProperties().SetKerning(14 * _cdg.Point)
	_ecgdd.RunProperties().SetCharacterSpacing(-10 * _cdg.Twips)
	_bdaf := _dfgac.AddStyle("\u0054\u0069\u0074l\u0065", _deg.ST_StyleTypeParagraph, false)
	_bdaf.SetName("\u0054\u0069\u0074l\u0065")
	_bdaf.SetBasedOn(_bbcf.StyleID())
	_bdaf.SetNextStyle(_bbcf.StyleID())
	_bdaf.SetLinkedStyle(_ecgdd.StyleID())
	_bdaf.SetUISortOrder(10)
	_bdaf.SetPrimaryStyle(true)
	_bdaf.ParagraphProperties().SetContextualSpacing(true)
	_bdaf.RunProperties().Fonts().SetASCIITheme(_deg.ST_ThemeMajorAscii)
	_bdaf.RunProperties().Fonts().SetEastAsiaTheme(_deg.ST_ThemeMajorEastAsia)
	_bdaf.RunProperties().Fonts().SetHANSITheme(_deg.ST_ThemeMajorHAnsi)
	_bdaf.RunProperties().Fonts().SetCSTheme(_deg.ST_ThemeMajorBidi)
	_bdaf.RunProperties().SetSize(28 * _cdg.Point)
	_bdaf.RunProperties().SetKerning(14 * _cdg.Point)
	_bdaf.RunProperties().SetCharacterSpacing(-10 * _cdg.Twips)
	_fegfa := _dfgac.AddStyle("T\u0061\u0062\u006c\u0065\u004e\u006f\u0072\u006d\u0061\u006c", _deg.ST_StyleTypeTable, false)
	_fegfa.SetName("\u004e\u006f\u0072m\u0061\u006c\u0020\u0054\u0061\u0062\u006c\u0065")
	_fegfa.SetUISortOrder(99)
	_fegfa.SetSemiHidden(true)
	_fegfa.SetUnhideWhenUsed(true)
	_fegfa.X().TblPr = _deg.NewCT_TblPrBase()
	_egaff := NewTableWidth()
	_fegfa.X().TblPr.TblInd = _egaff.X()
	_egaff.SetValue(0 * _cdg.Dxa)
	_fegfa.X().TblPr.TblCellMar = _deg.NewCT_TblCellMar()
	_egaff = NewTableWidth()
	_fegfa.X().TblPr.TblCellMar.Top = _egaff.X()
	_egaff.SetValue(0 * _cdg.Dxa)
	_egaff = NewTableWidth()
	_fegfa.X().TblPr.TblCellMar.Bottom = _egaff.X()
	_egaff.SetValue(0 * _cdg.Dxa)
	_egaff = NewTableWidth()
	_fegfa.X().TblPr.TblCellMar.Left = _egaff.X()
	_egaff.SetValue(108 * _cdg.Dxa)
	_egaff = NewTableWidth()
	_fegfa.X().TblPr.TblCellMar.Right = _egaff.X()
	_egaff.SetValue(108 * _cdg.Dxa)
	_acfcf := _dfgac.AddStyle("\u004e\u006f\u004c\u0069\u0073\u0074", _deg.ST_StyleTypeNumbering, false)
	_acfcf.SetName("\u004eo\u0020\u004c\u0069\u0073\u0074")
	_acfcf.SetUISortOrder(1)
	_acfcf.SetSemiHidden(true)
	_acfcf.SetUnhideWhenUsed(true)
	_dcdg := []_cdg.Distance{16, 13, 12, 11, 11, 11, 11, 11, 11}
	_ebaea := []_cdg.Distance{240, 40, 40, 40, 40, 40, 40, 40, 40}
	for _edgad := 0; _edgad < 9; _edgad++ {
		_gecc := _dd.Sprintf("\u0048e\u0061\u0064\u0069\u006e\u0067\u0025d", _edgad+1)
		_aefa := _dfgac.AddStyle(_gecc+"\u0043\u0068\u0061\u0072", _deg.ST_StyleTypeCharacter, false)
		_aefa.SetName(_dd.Sprintf("\u0048e\u0061d\u0069\u006e\u0067\u0020\u0025\u0064\u0020\u0043\u0068\u0061\u0072", _edgad+1))
		_aefa.SetBasedOn(_dddea.StyleID())
		_aefa.SetLinkedStyle(_gecc)
		_aefa.SetUISortOrder(9 + _edgad)
		_aefa.RunProperties().SetSize(_dcdg[_edgad] * _cdg.Point)
		_cccg := _dfgac.AddStyle(_gecc, _deg.ST_StyleTypeParagraph, false)
		_cccg.SetName(_dd.Sprintf("\u0068\u0065\u0061\u0064\u0069\u006e\u0067\u0020\u0025\u0064", _edgad+1))
		_cccg.SetNextStyle(_bbcf.StyleID())
		_cccg.SetLinkedStyle(_cccg.StyleID())
		_cccg.SetUISortOrder(9 + _edgad)
		_cccg.SetPrimaryStyle(true)
		_cccg.ParagraphProperties().SetKeepNext(true)
		_cccg.ParagraphProperties().SetSpacing(_ebaea[_edgad]*_cdg.Twips, 0)
		_cccg.ParagraphProperties().SetOutlineLevel(_edgad)
		_cccg.RunProperties().SetSize(_dcdg[_edgad] * _cdg.Point)
	}
}

// GetHighlight returns the HighlightColor.
func (_gdccf RunProperties) GetHighlight() _deg.ST_HighlightColor {
	if _gdccf._bfed.Highlight != nil {
		return _gdccf._bfed.Highlight.ValAttr
	}
	return _deg.ST_HighlightColorNone
}

// RunProperties controls run styling properties.
type RunProperties struct{ _bfed *_deg.CT_RPr }

// RightToLeft returns true if run text goes from right to left.
func (_ggea RunProperties) RightToLeft() bool { return _dabbe(_ggea._bfed.Rtl) }

// X returns the inner wrapped XML type.
func (_fd AnchoredDrawing) X() *_deg.WdAnchor { return _fd._bgc }

// Cell is a table cell within a document (not a spreadsheet)
type Cell struct {
	_dff *Document
	_fdf *_deg.CT_Tc
}

// DoubleStrike returns true if paragraph is double striked.
func (_fccbe ParagraphProperties) DoubleStrike() bool { return _dabbe(_fccbe._adegb.RPr.Dstrike) }

// Header is a header for a document section.
type Header struct {
	_efbf   *Document
	_efadbc *_deg.Hdr
}

// SetName sets the name of the style.
func (_cadbg Style) SetName(name string) {
	_cadbg._bageg.Name = _deg.NewCT_String()
	_cadbg._bageg.Name.ValAttr = name
}
func (_agdab Paragraph) addEndFldChar() *_deg.CT_FldChar {
	_dggea := _agdab.addFldChar()
	_dggea.FldCharTypeAttr = _deg.ST_FldCharTypeEnd
	return _dggea
}

// X returns the inner wrapped XML type.
func (_eed *Document) X() *_deg.Document { return _eed._effc }

// X returns the inner wrapped XML type.
func (_gfe Bookmark) X() *_deg.CT_Bookmark { return _gfe._ggfb }

// InsertRunAfter inserts a run in the paragraph after the relative run.
func (_cdae Paragraph) InsertRunAfter(relativeTo Run) Run { return _cdae.insertRun(relativeTo, false) }

// Style return the table style.
func (_cgfgf Table) Style() string {
	if _cgfgf._abbae.TblPr != nil && _cgfgf._abbae.TblPr.TblStyle != nil {
		return _cgfgf._abbae.TblPr.TblStyle.ValAttr
	}
	return ""
}

// SetHANSITheme sets the font H ANSI Theme.
func (_bddb Fonts) SetHANSITheme(t _deg.ST_Theme) { _bddb._gddaa.HAnsiThemeAttr = t }

// AddTable adds a table to the header.
func (_fggcf Header) AddTable() Table {
	_gbee := _deg.NewEG_ContentBlockContent()
	_fggcf._efadbc.EG_BlockLevelElts = append(_fggcf._efadbc.EG_BlockLevelElts, &_deg.EG_BlockLevelElts{BlockLevelEltsChoice: &_deg.EG_BlockLevelEltsChoice{EG_ContentBlockContent: []*_deg.EG_ContentBlockContent{_gbee}}})
	_bdgbc := _deg.NewCT_Tbl()
	_gbee.ContentBlockContentChoice.Tbl = append(_gbee.ContentBlockContentChoice.Tbl, _bdgbc)
	return Table{_fggcf._efbf, _bdgbc}
}

// AddTextInput adds text input form field to the paragraph and returns it.
func (_bfae Paragraph) AddTextInput(name string) FormField {
	_cgbfg := _bfae.addFldCharsForField(name, "\u0046\u004f\u0052\u004d\u0054\u0045\u0058\u0054")
	_cgbfg._bgcg.FFDataChoice[0].TextInput = _deg.NewCT_FFTextInput()
	return _cgbfg
}

// RemoveComment will remove comment with a given id from the document.
func (_bgfb *Document) RemoveComment(id int64) bool {
	if !_bgfb.HasComments() {
		return false
	}
	_fbcg := _bgfb._aeg
	var _dceb int
	for _dgda, _egg := range _fbcg.CT_Comments.Comment {
		if _egg.IdAttr == id {
			_dceb = _dgda
			break
		}
	}
	_cadb := _fbcg.CT_Comments.Comment[:_dceb]
	_cadb = append(_cadb, _fbcg.CT_Comments.Comment[_dceb+1:len(_fbcg.CT_Comments.Comment)]...)
	_fbcg.CT_Comments.Comment = _cadb
	for _, _gaaf := range _bgfb.Paragraphs() {
		if _gaaf.removeCommentRange(id) {
			_gaaf.removeCommentRef(id)
			break
		}
	}
	_bgfb.reorderComments()
	return true
}

// AddHeader creates a header associated with the document, but doesn't add it
// to the document for display.
func (_acc *Document) AddHeader() Header {
	_fef := _deg.NewHdr()
	_acc._aaad = append(_acc._aaad, _fef)
	_cbe := _dd.Sprintf("\u0068\u0065\u0061d\u0065\u0072\u0025\u0064\u002e\u0078\u006d\u006c", len(_acc._aaad))
	_acc._afff.AddRelationship(_cbe, _e.HeaderType)
	_acc.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072\u0064\u002f"+_cbe, "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0076\u006e\u0064.\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c\u002e\u0068\u0065\u0061\u0064e\u0072\u002b\u0078\u006d\u006c")
	_acc._dgea = append(_acc._dgea, _ee.NewRelationships())
	return Header{_acc, _fef}
}
func (_dabb *Document) syncEndnoteSettings() {
	_afab := []int64{}
	_agbg := _dabb.Endnotes()
	for _, _ggaf := range _agbg {
		if _ggaf.X().TypeAttr != _deg.ST_FtnEdnUnset && _ggaf.X().TypeAttr != _deg.ST_FtnEdnNormal {
			_afab = append(_afab, _ggaf.X().IdAttr)
		}
	}
	_ccbc := _dabb.Settings.X().CT_Settings.EndnotePr
	if _ccbc == nil {
		_ccbc = _deg.NewCT_EdnDocProps()
	}
	if len(_afab) == 0 {
		_ccbc.Endnote = nil
		return
	}
	_ccbc.Endnote = []*_deg.CT_FtnEdnSepRef{}
	for _, _ggdg := range _afab {
		_ggdfa := _deg.NewCT_FtnEdnSepRef()
		_ggdfa.IdAttr = _ggdg
		_ccbc.Endnote = append(_ccbc.Endnote, _ggdfa)
	}
}

// SetPictureSize set watermark picture size with given width and height.
func (_edff *WatermarkPicture) SetPictureSize(width, height int64) {
	if _edff._bfadf != nil {
		_adbg := _edff.GetShapeStyle()
		_adbg.SetWidth(float64(width) * _cdg.Point)
		_adbg.SetHeight(float64(height) * _cdg.Point)
		_edff.SetShapeStyle(_adbg)
	}
}

// AddPageBreak adds a page break to a run.
func (_eabd Run) AddPageBreak() {
	_gcbaf := _eabd.newIC()
	_gcbaf.RunInnerContentChoice.Br = _deg.NewCT_Br()
	_gcbaf.RunInnerContentChoice.Br.TypeAttr = _deg.ST_BrTypePage
}

// AddText adds text to a run.
func (_caca Run) AddText(s string) {
	_dgeag := _deg.NewEG_RunInnerContent()
	_caca._gabc.EG_RunInnerContent = append(_caca._gabc.EG_RunInnerContent, _dgeag)
	_dgeag.RunInnerContentChoice.T = _deg.NewCT_Text()
	if _e.NeedsSpacePreserve(s) {
		_cdede := "\u0070\u0072\u0065\u0073\u0065\u0072\u0076\u0065"
		_dgeag.RunInnerContentChoice.T.SpaceAttr = &_cdede
	}
	_dgeag.RunInnerContentChoice.T.Content = s
}

// X returns the inner wml.CT_TblBorders
func (_gaebd TableBorders) X() *_deg.CT_TblBorders { return _gaebd._cadbb }

// X returns the inner wrapped XML type.
func (_bcfg HyperLink) X() *_deg.CT_Hyperlink { return _bcfg._babce }
func _bedae() *_dc.Path {
	_faec := _dc.NewPath()
	_faec.TextpathokAttr = _fae.ST_TrueFalseTrue
	_faec.ConnecttypeAttr = _dc.OfcST_ConnectTypeCustom
	_edcga := "\u0040\u0039\u002c0;\u0040\u0031\u0030\u002c\u0031\u0030\u0038\u0030\u0030;\u00401\u0031,\u00321\u0036\u0030\u0030\u003b\u0040\u0031\u0032\u002c\u0031\u0030\u0038\u0030\u0030"
	_faec.ConnectlocsAttr = &_edcga
	_feefe := "\u0032\u0037\u0030,\u0031\u0038\u0030\u002c\u0039\u0030\u002c\u0030"
	_faec.ConnectanglesAttr = &_feefe
	return _faec
}

// Clear removes all the content from within a run.
func (_ggafb Run) Clear() { _ggafb._gabc.EG_RunInnerContent = nil }

// ParagraphStyleProperties is the styling information for a paragraph.
type ParagraphStyleProperties struct{ _dgebc *_deg.CT_PPrGeneral }

// Bold returns true if run font is bold.
func (_fegce RunProperties) Bold() bool {
	_cfaeg := _fegce._bfed
	return _dabbe(_cfaeg.B) || _dabbe(_cfaeg.BCs)
}

// SetWrapPathLineTo sets wrapPath lineTo value.
func (_dbce AnchorDrawWrapOptions) SetWrapPathLineTo(coordinates []*_ad.CT_Point2D) {
	_dbce._ddf = coordinates
}

// SetPageMargins sets the page margins for a section
func (_dbbf Section) SetPageMargins(top, right, bottom, left, header, footer, gutter _cdg.Distance) {
	_edgf := _deg.NewCT_PageMar()
	_edgf.TopAttr.Int64 = _e.Int64(int64(top / _cdg.Twips))
	_edgf.BottomAttr.Int64 = _e.Int64(int64(bottom / _cdg.Twips))
	_edgf.RightAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(right / _cdg.Twips))
	_edgf.LeftAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(left / _cdg.Twips))
	_edgf.HeaderAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(header / _cdg.Twips))
	_edgf.FooterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(footer / _cdg.Twips))
	_edgf.GutterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(gutter / _cdg.Twips))
	_dbbf._eegag.PgMar = _edgf
}

// SetCellSpacingAuto sets the cell spacing within a table to automatic.
func (_acaeg TableStyleProperties) SetCellSpacingAuto() {
	_acaeg._daffa.TblCellSpacing = _deg.NewCT_TblWidth()
	_acaeg._daffa.TblCellSpacing.TypeAttr = _deg.ST_TblWidthAuto
}

// SetStartIndent controls the start indentation.
func (_edaaa ParagraphProperties) SetStartIndent(m _cdg.Distance) {
	if _edaaa._adegb.Ind == nil {
		_edaaa._adegb.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_edaaa._adegb.Ind.StartAttr = nil
	} else {
		_edaaa._adegb.Ind.StartAttr = &_deg.ST_SignedTwipsMeasure{}
		_edaaa._adegb.Ind.StartAttr.Int64 = _e.Int64(int64(m / _cdg.Twips))
	}
}

// NewAnchorDrawWrapOptions return anchor drawing options property.
func NewAnchorDrawWrapOptions() *AnchorDrawWrapOptions {
	_adf := &AnchorDrawWrapOptions{}
	if !_adf._eagb {
		_eec, _aaa := _fbf()
		_adf._bad = _eec
		_adf._ddf = _aaa
	}
	return _adf
}

// SetLeftPct sets the cell left margin
func (_ddb CellMargins) SetLeftPct(pct float64) {
	_ddb._fee.Left = _deg.NewCT_TblWidth()
	_cfgb(_ddb._fee.Left, pct)
}
func _ggga(_eggd *_deg.CT_P, _dbfe map[string]string) {
	for _, _dfafe := range _eggd.EG_PContent {
		if _dfafe.PContentChoice.Hyperlink != nil && _dfafe.PContentChoice.Hyperlink.IdAttr != nil {
			if _ecbf, _bcdeb := _dbfe[*_dfafe.PContentChoice.Hyperlink.IdAttr]; _bcdeb {
				*_dfafe.PContentChoice.Hyperlink.IdAttr = _ecbf
			}
		}
	}
}
func (_debf Paragraph) addStartBookmark(_agab int64, _fbbea string) *_deg.CT_Bookmark {
	_fgda := _deg.NewEG_PContent()
	_debf._bbff.EG_PContent = append(_debf._bbff.EG_PContent, _fgda)
	_bcgg := _deg.NewEG_ContentRunContent()
	_fabf := _deg.NewEG_RunLevelElts()
	_cfdcg := _deg.NewEG_RangeMarkupElements()
	_eacbe := _deg.NewCT_Bookmark()
	_eacbe.NameAttr = _fbbea
	_eacbe.IdAttr = _agab
	_cfdcg.RangeMarkupElementsChoice.BookmarkStart = _eacbe
	_fgda.PContentChoice.EG_ContentRunContent = append(_fgda.PContentChoice.EG_ContentRunContent, _bcgg)
	_bcgg.ContentRunContentChoice.EG_RunLevelElts = append(_bcgg.ContentRunContentChoice.EG_RunLevelElts, _fabf)
	_fabf.RunLevelEltsChoice.EG_RangeMarkupElements = append(_fabf.RunLevelEltsChoice.EG_RangeMarkupElements, _cfdcg)
	return _eacbe
}

// SetHAlignment sets the horizontal alignment for an anchored image.
func (_ef AnchoredDrawing) SetHAlignment(h _deg.WdST_AlignH) {
	_ef._bgc.PositionH.PosHChoice = &_deg.WdCT_PosHChoice{}
	_ef._bgc.PositionH.PosHChoice.Align = h
}

// SetHeader sets a section header.
func (_fbad Section) SetHeader(h Header, t _deg.ST_HdrFtr) {
	_eafge := _deg.NewEG_HdrFtrReferences()
	_fbad._eegag.EG_HdrFtrReferences = append(_fbad._eegag.EG_HdrFtrReferences, _eafge)
	_eafge.HdrFtrReferencesChoice.HeaderReference = _deg.NewCT_HdrFtrRef()
	_eafge.HdrFtrReferencesChoice.HeaderReference.TypeAttr = t
	_ggce := _fbad._bbbea._afff.FindRIDForN(h.Index(), _e.HeaderType)
	if _ggce == "" {
		_gd.Log.Debug("\u0075\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0072\u006d\u0069\u006e\u0065\u0020\u0068\u0065\u0061\u0064\u0065r \u0049\u0044")
	}
	_eafge.HdrFtrReferencesChoice.HeaderReference.IdAttr = _ggce
}

// TableBorders allows manipulation of borders on a table.
type TableBorders struct{ _cadbb *_deg.CT_TblBorders }

// Paragraphs returns the paragraphs within a structured document tag.
func (_gadgf StructuredDocumentTag) Paragraphs() []Paragraph {
	if _gadgf._dbbdc.SdtContent == nil {
		return nil
	}
	_fage := []Paragraph{}
	for _, _fgada := range _gadgf._dbbdc.SdtContent.EG_ContentBlockContent {
		for _, _fcff := range _fgada.ContentBlockContentChoice.P {
			_fage = append(_fage, Paragraph{_gadgf._gddd, _fcff})
		}
	}
	return _fage
}

// CellMargins are the margins for an individual cell.
type CellMargins struct{ _fee *_deg.CT_TcMar }

// SetTextWrapSquare sets the text wrap to square with a given wrap type.
func (_gf AnchoredDrawing) SetTextWrapSquare(t _deg.WdST_WrapText) {
	_gf._bgc.WrapTypeChoice = &_deg.WdEG_WrapTypeChoice{}
	_gf._bgc.WrapTypeChoice.WrapSquare = _deg.NewWdCT_WrapSquare()
	_gf._bgc.WrapTypeChoice.WrapSquare.WrapTextAttr = t
}

// SetLeftIndent controls left indent of paragraph.
func (_cega Paragraph) SetLeftIndent(m _cdg.Distance) {
	_cega.ensurePPr()
	_fbeb := _cega._bbff.PPr
	if _fbeb.Ind == nil {
		_fbeb.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_fbeb.Ind.LeftAttr = nil
	} else {
		_fbeb.Ind.LeftAttr = &_deg.ST_SignedTwipsMeasure{}
		_fbeb.Ind.LeftAttr.Int64 = _e.Int64(int64(m / _cdg.Twips))
	}
}

// AddEndnoteReference adds a footnote reference to a run.
func (_bbgg Run) AddEndnoteReference() {
	_accbd := _bbgg.newIC()
	_accbd.RunInnerContentChoice.EndnoteRef = &_deg.CT_Empty{}
}

// SetStrikeThrough sets the run to strike-through.
func (_dddeb RunProperties) SetStrikeThrough(b bool) {
	if !b {
		_dddeb._bfed.Strike = nil
	} else {
		_dddeb._bfed.Strike = _deg.NewCT_OnOff()
	}
}

// SetHorizontalBanding controls the conditional formatting for horizontal banding.
func (_fgbcf TableLook) SetHorizontalBanding(on bool) {
	if !on {
		_fgbcf._bfdc.NoHBandAttr = &_fae.ST_OnOff{}
		_fgbcf._bfdc.NoHBandAttr.ST_OnOff1 = _fae.ST_OnOff1On
	} else {
		_fgbcf._bfdc.NoHBandAttr = &_fae.ST_OnOff{}
		_fgbcf._bfdc.NoHBandAttr.ST_OnOff1 = _fae.ST_OnOff1Off
	}
}

// VerticalAlign returns the value of run vertical align.
func (_bgfbb RunProperties) VerticalAlignment() _fae.ST_VerticalAlignRun {
	if _gacge := _bgfbb._bfed.VertAlign; _gacge != nil {
		return _gacge.ValAttr
	}
	return 0
}

// SetLayout controls the table layout. wml.ST_TblLayoutTypeAutofit corresponds
// to "Automatically resize to fit contents" being checked, while
// wml.ST_TblLayoutTypeFixed corresponds to it being unchecked.
func (_gbaef TableProperties) SetLayout(l _deg.ST_TblLayoutType) {
	if l == _deg.ST_TblLayoutTypeUnset || l == _deg.ST_TblLayoutTypeAutofit {
		_gbaef._gafba.TblLayout = nil
	} else {
		_gbaef._gafba.TblLayout = _deg.NewCT_TblLayoutType()
		_gbaef._gafba.TblLayout.TypeAttr = l
	}
}

// SetCellSpacingPercent sets the cell spacing within a table to a percent width.
func (_aecca TableStyleProperties) SetCellSpacingPercent(pct float64) {
	_aecca._daffa.TblCellSpacing = _deg.NewCT_TblWidth()
	_aecca._daffa.TblCellSpacing.TypeAttr = _deg.ST_TblWidthPct
	_aecca._daffa.TblCellSpacing.WAttr = &_deg.ST_MeasurementOrPercent{}
	_aecca._daffa.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_aecca._daffa.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(pct * 50))
}

// TableWidth controls width values in table settings.
type TableWidth struct{ _baggc *_deg.CT_TblWidth }

// SetCantSplit set row properties for Can't Split value.
func (_agbf RowProperties) SetCantSplit(val bool) {
	if !val {
		_agbf._ebdgc.TrPrBaseChoice = nil
	} else {
		_agbf._ebdgc.TrPrBaseChoice = []*_deg.CT_TrPrBaseChoice{&_deg.CT_TrPrBaseChoice{CantSplit: _deg.NewCT_OnOff()}}
	}
}

// WatermarkPicture is watermark picture within document.
type WatermarkPicture struct {
	_dbece  *_deg.CT_Picture
	_affedc *_bgg.ShapeStyle
	_bfadf  *_dc.Shape
	_dbeec  *_dc.Shapetype
}

// AddImage adds an image to the document package, returning a reference that
// can be used to add the image to a run and place it in the document contents.
func (_gebb Footer) AddImage(i _ee.Image) (_ee.ImageRef, error) {
	var _gdff _ee.Relationships
	for _dgaec, _ageb := range _gebb._abba._bcf {
		if _ageb == _gebb._aabd {
			_gdff = _gebb._abba._fce[_dgaec]
		}
	}
	_bdcfg := _ee.MakeImageRef(i, &_gebb._abba.DocBase, _gdff)
	if i.Data == nil && i.Path == "" {
		return _bdcfg, _bea.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0064\u0061t\u0061\u0020\u006f\u0072\u0020\u0061\u0020\u0070\u0061\u0074\u0068")
	}
	if i.Format == "" {
		return _bdcfg, _bea.New("\u0069\u006d\u0061\u0067\u0065\u0020\u006d\u0075\u0073\u0074 \u0068\u0061\u0076\u0065\u0020\u0061\u0020v\u0061\u006c\u0069\u0064\u0020\u0066\u006f\u0072\u006d\u0061\u0074")
	}
	if i.Size.X == 0 || i.Size.Y == 0 {
		return _bdcfg, _bea.New("\u0069\u006d\u0061\u0067e\u0020\u006d\u0075\u0073\u0074\u0020\u0068\u0061\u0076\u0065 \u0061 \u0076\u0061\u006c\u0069\u0064\u0020\u0073i\u007a\u0065")
	}
	_gebb._abba.Images = append(_gebb._abba.Images, _bdcfg)
	_gebc := _dd.Sprintf("\u006d\u0065d\u0069\u0061\u002fi\u006d\u0061\u0067\u0065\u0025\u0064\u002e\u0025\u0073", len(_gebb._abba.Images), i.Format)
	_fffdc := _gdff.AddRelationship(_gebc, _e.ImageType)
	_bdcfg.SetRelID(_fffdc.X().IdAttr)
	return _bdcfg, nil
}

// Endnotes returns the endnotes defined in the document.
func (_fad *Document) Endnotes() []Endnote {
	_ege := []Endnote{}
	for _, _cded := range _fad._ebfb.CT_Endnotes.Endnote {
		_ege = append(_ege, Endnote{_fad, _cded})
	}
	return _ege
}
func _gecb(_cec *_deg.CT_TblWidth, _acf _cdg.Distance) {
	_cec.TypeAttr = _deg.ST_TblWidthDxa
	_cec.WAttr = &_deg.ST_MeasurementOrPercent{}
	_cec.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_cec.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(_acf / _cdg.Dxa))
}

// NumId return numbering numId that being use by style properties.
func (_ddage ParagraphStyleProperties) NumId() int64 {
	if _ddage._dgebc.NumPr != nil {
		if _ddage._dgebc.NumPr.NumId != nil {
			return _ddage._dgebc.NumPr.NumId.ValAttr
		}
	}
	return -1
}

// Headers returns the headers defined in the document.
func (_cccb *Document) Headers() []Header {
	_gafa := []Header{}
	for _, _fg := range _cccb._aaad {
		_gafa = append(_gafa, Header{_cccb, _fg})
	}
	return _gafa
}

// SetAllowOverlapAttr sets the allowOverlap attribute of anchor.
func (_ggc AnchoredDrawing) SetAllowOverlapAttr(val bool) { _ggc._bgc.AllowOverlapAttr = val }

// SetLineSpacing sets the spacing between lines in a paragraph.
func (_becdg Paragraph) SetLineSpacing(d _cdg.Distance, rule _deg.ST_LineSpacingRule) {
	_becdg.ensurePPr()
	if _becdg._bbff.PPr.Spacing == nil {
		_becdg._bbff.PPr.Spacing = _deg.NewCT_Spacing()
	}
	_eafa := _becdg._bbff.PPr.Spacing
	if rule == _deg.ST_LineSpacingRuleUnset {
		_eafa.LineRuleAttr = _deg.ST_LineSpacingRuleUnset
		_eafa.LineAttr = nil
	} else {
		_eafa.LineRuleAttr = rule
		_eafa.LineAttr = &_deg.ST_SignedTwipsMeasure{}
		_eafa.LineAttr.Int64 = _e.Int64(int64(d / _cdg.Twips))
	}
}

// SetOutlineLvl sets outline level of paragraph.
func (_agbgb Paragraph) SetOutlineLvl(lvl int64) {
	_agbgb.ensurePPr()
	if _agbgb._bbff.PPr.OutlineLvl == nil {
		_agbgb._bbff.PPr.OutlineLvl = _deg.NewCT_DecimalNumber()
	}
	_bdeae := lvl - 1
	_agbgb._bbff.PPr.OutlineLvl.ValAttr = _bdeae
}

// AddTab adds tab to a run and can be used with the the Paragraph's tab stops.
func (_bfccb Run) AddTab() {
	_bgdbg := _bfccb.newIC()
	_bgdbg.RunInnerContentChoice.Tab = _deg.NewCT_Empty()
}

// X returns the inner wrapped XML type.
func (_fdd CellProperties) X() *_deg.CT_TcPr { return _fdd._cbb }

// Section return paragraph properties section value.
func (_daef ParagraphProperties) Section() (Section, bool) {
	if _daef._adegb.SectPr != nil {
		return Section{_daef._agcfge, _daef._adegb.SectPr}, true
	}
	return Section{}, false
}

// X returns the inner wrapped XML type.
func (_ggbd Style) X() *_deg.CT_Style { return _ggbd._bageg }

// GetKerning returns the kerning (character spacing) of a run
func (_gcaaa RunProperties) GetKerning() _cdg.Distance {
	if _gcaaa._bfed.Kern != nil {
		return _cdg.Distance(float64(*_gcaaa._bfed.Kern.ValAttr.ST_UnsignedDecimalNumber) * _cdg.HalfPoint)
	}
	return 0
}
func (_deee *WatermarkText) getShape() *_e.XSDAny {
	return _deee.getInnerElement("\u0073\u0068\u0061p\u0065")
}
func _eecd(_debb *_deg.CT_Tbl, _afge, _cbeb map[int64]int64) {
	for _, _dcac := range _debb.EG_ContentRowContent {
		for _, _baab := range _dcac.ContentRowContentChoice.Tr {
			for _, _efaa := range _baab.EG_ContentCellContent {
				for _, _egadf := range _efaa.ContentCellContentChoice.Tc {
					for _, _gdccd := range _egadf.EG_BlockLevelElts {
						for _, _cdcc := range _gdccd.BlockLevelEltsChoice.EG_ContentBlockContent {
							for _, _daec := range _cdcc.ContentBlockContentChoice.P {
								_eafbd(_daec, _afge, _cbeb)
							}
							for _, _gae := range _cdcc.ContentBlockContentChoice.Tbl {
								_eecd(_gae, _afge, _cbeb)
							}
						}
					}
				}
			}
		}
	}
}

// IsFootnote returns a bool based on whether the run has a
// footnote or not. Returns both a bool as to whether it has
// a footnote as well as the ID of the footnote.
func (_gcadd Run) IsFootnote() (bool, int64) {
	if _gcadd._gabc.EG_RunInnerContent != nil {
		if _gcadd._gabc.EG_RunInnerContent[0].RunInnerContentChoice.FootnoteReference != nil {
			return true, _gcadd._gabc.EG_RunInnerContent[0].RunInnerContentChoice.FootnoteReference.IdAttr
		}
	}
	return false, 0
}

// Append appends a document d0 to a document d1. All settings, headers and footers remain the same as in the document d0 if they exist there, otherwise they are taken from the d1.
func (_fbgf *Document) Append(d1orig *Document) error {
	_eea, _cdga := d1orig.Copy()
	if _cdga != nil {
		return _cdga
	}
	_fbgf.DocBase = _fbgf.DocBase.Append(_eea.DocBase)
	if _eea._effc.ConformanceAttr != _fae.ST_ConformanceClassStrict {
		_fbgf._effc.ConformanceAttr = _eea._effc.ConformanceAttr
	}
	_cecd := _fbgf._afff.X().Relationship
	_egff := _eea._afff.X().Relationship
	_bfbde := _eea._effc.Body
	_adgc := map[string]string{}
	_gedd := map[int64]int64{}
	_agbe := map[int64]int64{}
	for _, _dfbc := range _egff {
		_fgce := true
		_ecebc := _dfbc.IdAttr
		_gaae := _dfbc.TargetAttr
		_bbeb := _dfbc.TypeAttr
		_cgdce := _bbeb == _e.ImageType
		_ccdff := _bbeb == _e.HyperLinkType
		var _cabe string
		for _, _agfc := range _cecd {
			if _agfc.TypeAttr == _bbeb && _agfc.TargetAttr == _gaae {
				_fgce = false
				_cabe = _agfc.IdAttr
				break
			}
		}
		if _cgdce {
			_bcgd := "\u0077\u006f\u0072d\u002f" + _gaae
			for _, _bfgbc := range _eea.DocBase.Images {
				if _bfgbc.Target() == _bcgd {
					_eecec, _fbge := _ee.ImageFromStorage(_bfgbc.Path())
					if _fbge != nil {
						return _fbge
					}
					_eadab, _fbge := _fbgf.AddImage(_eecec)
					if _fbge != nil {
						return _fbge
					}
					_cabe = _eadab.RelID()
					break
				}
			}
		} else if _fgce {
			if _ccdff {
				_ceac := _fbgf._afff.AddHyperlink(_gaae)
				_cabe = _ee.Relationship(_ceac).ID()
			} else {
				_ggdb := _fbgf._afff.AddRelationship(_gaae, _bbeb)
				_cabe = _ggdb.X().IdAttr
			}
		}
		if _ecebc != _cabe {
			_adgc[_ecebc] = _cabe
		}
	}
	if _bfbde.SectPr != nil {
		for _, _gcfe := range _bfbde.SectPr.EG_HdrFtrReferences {
			if _gcfe.HdrFtrReferencesChoice.HeaderReference != nil {
				if _fdcf, _becbe := _adgc[_gcfe.HdrFtrReferencesChoice.HeaderReference.IdAttr]; _becbe {
					_gcfe.HdrFtrReferencesChoice.HeaderReference.IdAttr = _fdcf
					_fbgf._dgea = append(_fbgf._dgea, _ee.NewRelationships())
				}
			} else if _gcfe.HdrFtrReferencesChoice.FooterReference != nil {
				if _ecbdf, _cafe := _adgc[_gcfe.HdrFtrReferencesChoice.FooterReference.IdAttr]; _cafe {
					_gcfe.HdrFtrReferencesChoice.FooterReference.IdAttr = _ecbdf
					_fbgf._fce = append(_fbgf._fce, _ee.NewRelationships())
				}
			}
		}
	}
	_ebe, _adgd := _fbgf._ebfb, _eea._ebfb
	if _ebe != nil {
		if _adgd != nil {
			if _ebe.Endnote != nil {
				if _adgd.Endnote != nil {
					_dgcc := int64(len(_ebe.Endnote) + 1)
					for _, _fdcgc := range _adgd.Endnote {
						_ffcgb := _fdcgc.IdAttr
						if _ffcgb > 0 {
							_fdcgc.IdAttr = _dgcc
							_ebe.Endnote = append(_ebe.Endnote, _fdcgc)
							_agbe[_ffcgb] = _dgcc
							_dgcc++
						}
					}
				}
			} else {
				_ebe.Endnote = _adgd.Endnote
			}
		}
	} else if _adgd != nil {
		_ebe = _adgd
	}
	_fbgf._ebfb = _ebe
	_agcf, _facb := _fbgf._daaf, _eea._daaf
	if _agcf != nil {
		if _facb != nil {
			if _agcf.Footnote != nil {
				if _facb.Footnote != nil {
					_gddc := int64(len(_agcf.Footnote) + 1)
					for _, _eefae := range _facb.Footnote {
						_cbcg := _eefae.IdAttr
						if _cbcg > 0 {
							_eefae.IdAttr = _gddc
							_agcf.Footnote = append(_agcf.Footnote, _eefae)
							_gedd[_cbcg] = _gddc
							_gddc++
						}
					}
				}
			} else {
				_agcf.Footnote = _facb.Footnote
			}
		}
	} else if _facb != nil {
		_agcf = _facb
	}
	_fbgf._daaf = _agcf
	for _, _egfd := range _bfbde.EG_BlockLevelElts {
		for _, _fafa := range _egfd.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _, _bceg := range _fafa.ContentBlockContentChoice.P {
				_egeb(_bceg, _adgc)
				_ggga(_bceg, _adgc)
				_eafbd(_bceg, _gedd, _agbe)
			}
			for _, _bcd := range _fafa.ContentBlockContentChoice.Tbl {
				_bcedg(_bcd, _adgc)
				_bcdb(_bcd, _adgc)
				_eecd(_bcd, _gedd, _agbe)
			}
		}
	}
	_fbgf._effc.Body.EG_BlockLevelElts = append(_fbgf._effc.Body.EG_BlockLevelElts, _eea._effc.Body.EG_BlockLevelElts...)
	if _fbgf._effc.Body.SectPr == nil {
		_fbgf._effc.Body.SectPr = _eea._effc.Body.SectPr
	} else {
		var _aefef, _agef bool
		for _, _dfabf := range _fbgf._effc.Body.SectPr.EG_HdrFtrReferences {
			if _dfabf.HdrFtrReferencesChoice.HeaderReference != nil {
				_aefef = true
			} else if _dfabf.HdrFtrReferencesChoice.FooterReference != nil {
				_agef = true
			}
		}
		if !_aefef {
			for _, _cbcgb := range _eea._effc.Body.SectPr.EG_HdrFtrReferences {
				if _cbcgb.HdrFtrReferencesChoice.HeaderReference != nil {
					_fbgf._effc.Body.SectPr.EG_HdrFtrReferences = append(_fbgf._effc.Body.SectPr.EG_HdrFtrReferences, _cbcgb)
					break
				}
			}
		}
		if !_agef {
			for _, _ggdec := range _eea._effc.Body.SectPr.EG_HdrFtrReferences {
				if _ggdec.HdrFtrReferencesChoice.FooterReference != nil {
					_fbgf._effc.Body.SectPr.EG_HdrFtrReferences = append(_fbgf._effc.Body.SectPr.EG_HdrFtrReferences, _ggdec)
					break
				}
			}
		}
		if _fbgf._effc.Body.SectPr.Cols == nil && _eea._effc.Body.SectPr.Cols != nil {
			_fbgf._effc.Body.SectPr.Cols = _eea._effc.Body.SectPr.Cols
		}
	}
	_dggfg := _fbgf.Numbering._gcfa
	_bgaa := _eea.Numbering._gcfa
	if _dggfg == nil && _bgaa != nil {
		_dggfg = _bgaa
	}
	_fbgf.Numbering._gcfa = _dggfg
	if _fbgf.Styles._cegfc == nil && _eea.Styles._cegfc != nil {
		_fbgf.Styles._cegfc = _eea.Styles._cegfc
	}
	_fbgf._dgb = append(_fbgf._dgb, _eea._dgb...)
	_fbgf._gdcf = append(_fbgf._gdcf, _eea._gdcf...)
	if len(_fbgf._aaad) == 0 {
		_fbgf._aaad = _eea._aaad
	}
	if len(_fbgf._bcf) == 0 {
		_fbgf._bcf = _eea._bcf
	}
	_bcde := _fbgf._egb
	_agbb := _eea._egb
	if _bcde != nil {
		if _agbb != nil {
			if _bcde.Divs != nil {
				if _agbb.Divs != nil {
					_bcde.Divs.Div = append(_bcde.Divs.Div, _agbb.Divs.Div...)
				}
			} else {
				_bcde.Divs = _agbb.Divs
			}
		}
		_bcde.Frameset = nil
	} else if _agbb != nil {
		_bcde = _agbb
		_bcde.Frameset = nil
	}
	_fbgf._egb = _bcde
	_fgcef := _fbgf._ffea
	_fadb := _eea._ffea
	if _fgcef != nil {
		if _fadb != nil {
			if _fgcef.Font != nil {
				if _fadb.Font != nil {
					for _, _gbbc := range _fadb.Font {
						_cbgf := true
						for _, _fdcc := range _fgcef.Font {
							if _fdcc.NameAttr == _gbbc.NameAttr {
								_cbgf = false
								break
							}
						}
						if _cbgf {
							_fgcef.Font = append(_fgcef.Font, _gbbc)
						}
					}
				}
			} else {
				_fgcef.Font = _fadb.Font
			}
		}
	} else if _fadb != nil {
		_fgcef = _fadb
	}
	_fbgf._ffea = _fgcef
	return nil
}

// X returns the inner wrapped XML type.
func (_cegag Styles) X() *_deg.Styles { return _cegag._cegfc }

// SetLineSpacing controls the line spacing of the paragraph.
func (_eage ParagraphStyleProperties) SetLineSpacing(m _cdg.Distance, rule _deg.ST_LineSpacingRule) {
	if _eage._dgebc.Spacing == nil {
		_eage._dgebc.Spacing = _deg.NewCT_Spacing()
	}
	if rule == _deg.ST_LineSpacingRuleUnset {
		_eage._dgebc.Spacing.LineRuleAttr = _deg.ST_LineSpacingRuleUnset
		_eage._dgebc.Spacing.LineAttr = nil
	} else {
		_eage._dgebc.Spacing.LineRuleAttr = rule
		_eage._dgebc.Spacing.LineAttr = &_deg.ST_SignedTwipsMeasure{}
		_eage._dgebc.Spacing.LineAttr.Int64 = _e.Int64(int64(m / _cdg.Twips))
	}
}
func _dabbe(_abdg *_deg.CT_OnOff) bool { return _abdg != nil }

// FontTable returns document fontTable element.
func (_ggee *Document) FontTable() *_deg.Fonts { return _ggee._ffea }
func (_caec Paragraph) ensurePPr() {
	if _caec._bbff.PPr == nil {
		_caec._bbff.PPr = _deg.NewCT_PPr()
	}
}

type chart struct {
	_cfga *_bd.ChartSpace
	_bfab string
	_bgag string
}

// SetFontSize sets font size of watermark text.
func (_aecdf *WatermarkText) SetFontSize(value int64) {
	_cbged := _aecdf.GetStyle()
	_cbged.SetFontSize(value)
	_aecdf.SetStyle(_cbged)
	if _aecdf._cfbf != nil && _aecdf._cfbf.StyleAttr != nil {
		_efcaa := *_aecdf._cfbf.StyleAttr
		_efcaa = _ac.ReplaceAll(_efcaa, "\u0077i\u0064\u0074\u0068\u003a4\u0036\u0038\u0070\u0074\u003bh\u0065i\u0067h\u0074\u003a\u0032\u0033\u0034\u0070\u0074;", _dd.Sprintf("\u0077\u0069\u0064th\u003a\u0025\u0064\u0070\u0074\u003b\u0068\u0065\u0069\u0067\u0068\u0074\u003a\u0025\u0064\u0070\u0074\u003b", int64(len(_aecdf.GetText()))*value, 2*value))
		_aecdf._cfbf.StyleAttr = &_efcaa
	}
}

// X returns the inner wrapped XML type.
func (_dfced RunProperties) X() *_deg.CT_RPr { return _dfced._bfed }
func (_fdaba *WatermarkText) findNode(_faecf *_e.XSDAny, _daafd string) *_e.XSDAny {
	for _, _ebbg := range _faecf.Nodes {
		if _ebbg.XMLName.Local == _daafd {
			return _ebbg
		}
	}
	return nil
}

// SetLinkedStyle sets the style that this style is linked to.
func (_cggef Style) SetLinkedStyle(name string) {
	if name == "" {
		_cggef._bageg.Link = nil
	} else {
		_cggef._bageg.Link = _deg.NewCT_String()
		_cggef._bageg.Link.ValAttr = name
	}
}

// Shadow returns true if paragraph shadow is on.
func (_ecbcf ParagraphProperties) Shadow() bool { return _dabbe(_ecbcf._adegb.RPr.Shadow) }
func (_bdff Paragraph) addInstrText(_abdaa string) *_deg.CT_Text {
	_bcaf := _bdff.AddRun()
	_ffbee := _bcaf.X()
	_gdgdf := _deg.NewEG_RunInnerContent()
	_cdgae := _deg.NewCT_Text()
	_cefea := "\u0070\u0072\u0065\u0073\u0065\u0072\u0076\u0065"
	_cdgae.SpaceAttr = &_cefea
	_cdgae.Content = "\u0020" + _abdaa + "\u0020"
	_gdgdf.RunInnerContentChoice.InstrText = _cdgae
	_ffbee.EG_RunInnerContent = append(_ffbee.EG_RunInnerContent, _gdgdf)
	return _cdgae
}

// SetNumberingDefinitionByID sets the numbering definition ID directly, which must
// match an ID defined in numbering.xml
func (_gffd Paragraph) SetNumberingDefinitionByID(abstractNumberID int64) {
	_gffd.ensurePPr()
	if _gffd._bbff.PPr.NumPr == nil {
		_gffd._bbff.PPr.NumPr = _deg.NewCT_NumPr()
	}
	_ggcf := _deg.NewCT_DecimalNumber()
	_ggcf.ValAttr = int64(abstractNumberID)
	_gffd._bbff.PPr.NumPr.NumId = _ggcf
}

// SetName sets the name of the bookmark. This is the name that is used to
// reference the bookmark from hyperlinks.
func (_gec Bookmark) SetName(name string) { _gec._ggfb.NameAttr = name }

// Paragraphs returns the paragraphs defined in a footnote.
func (_baba Footnote) Paragraphs() []Paragraph {
	_egead := []Paragraph{}
	for _, _gdgdb := range _baba.content() {
		for _, _aaebe := range _gdgdb.ContentBlockContentChoice.P {
			_egead = append(_egead, Paragraph{_baba._dagad, _aaebe})
		}
	}
	return _egead
}

// DocText is an array of extracted text items which has some methods for representing extracted text.
type DocText struct {
	Items  []TextItem
	_cedag []listItemInfo
	_facbe map[int64]map[int64]int64
}

// SetValue sets the value of a FormFieldTypeText or FormFieldTypeDropDown. For
// FormFieldTypeDropDown, the value must be one of the fields possible values.
func (_ddaf FormField) SetValue(v string) {
	if len(_ddaf._bgcg.FFDataChoice) > 0 {
		for _, _fgfee := range _ddaf._bgcg.FFDataChoice {
			if _fgfee.DdList != nil {
				for _fddd, _fdbc := range _ddaf.PossibleValues() {
					if _fdbc == v {
						_fgfee.DdList.Result = _deg.NewCT_DecimalNumber()
						_fgfee.DdList.Result.ValAttr = int64(_fddd)
						break
					}
				}
			} else if _fgfee.TextInput != nil {
				_ddaf._edda.RunInnerContentChoice.T = _deg.NewCT_Text()
				_ddaf._edda.RunInnerContentChoice.T.Content = v
			}
		}
	}
}

// CellProperties returns the cell properties.
func (_acdcc TableConditionalFormatting) CellProperties() CellProperties {
	if _acdcc._ccaae.TcPr == nil {
		_acdcc._ccaae.TcPr = _deg.NewCT_TcPr()
	}
	return CellProperties{_acdcc._ccaae.TcPr}
}

// Style returns the style for a paragraph, or an empty string if it is unset.
func (_abgee Paragraph) Style() string {
	if _abgee._bbff.PPr != nil && _abgee._bbff.PPr.PStyle != nil {
		return _abgee._bbff.PPr.PStyle.ValAttr
	}
	return ""
}

// Control returns an *axcontrol.Control object contained in the run or the nil value in case of no controls.
func (_dgfb Run) Control() *_cd.Control {
	if _dgdd := _dgfb._gabc.EG_RunInnerContent; _dgdd != nil {
		if _eccb := _dgdd[0].RunInnerContentChoice.Object; _eccb != nil {
			if _aeebb := _eccb.ObjectChoice; _aeebb != nil {
				if _afgf := _aeebb.Control; _afgf != nil {
					if _afgf.IdAttr != nil {
						_caaf := _dgfb._fced.GetDocRelTargetByID(*_afgf.IdAttr)
						for _, _cgcbff := range _dgfb._fced._gdcf {
							if _caaf == _cgcbff.TargetAttr {
								return _cgcbff
							}
						}
					}
				}
			}
		}
	}
	return nil
}

// Copy makes a deep copy of the document by saving and reading it back.
// It can be useful to avoid sharing common data between two documents.
func (_bedgb *Document) Copy() (*Document, error) {
	_gbggf := _ag.NewBuffer([]byte{})
	_gdfg := _bedgb.save(_gbggf, _bedgb._cfgg)
	if _gdfg != nil {
		return nil, _gdfg
	}
	_bafd := _gbggf.Bytes()
	_fgg := _ag.NewReader(_bafd)
	return _ebdf(_fgg, int64(_fgg.Len()), _bedgb._cfgg)
}

// Emboss returns true if run emboss is on.
func (_gbfac RunProperties) Emboss() bool { return _dabbe(_gbfac._bfed.Emboss) }

type mergeFieldInfo struct {
	_bbdde              string
	_dgfff              string
	_daff               string
	_fbfcg              bool
	_acge               bool
	_aagab              bool
	_gcce               bool
	_adeaa              Paragraph
	_dcgf, _aeee, _efgf int
	_ffde               *_deg.EG_PContent
	_eefaee             bool
}

// FindNodeByText return node based on matched text and return a slice of node.
func (_aaaaf *Nodes) FindNodeByText(text string) []Node {
	_afeg := []Node{}
	for _, _gbaea := range _aaaaf._aebcgc {
		if _ac.TrimSpace(_gbaea.Text()) == text {
			_afeg = append(_afeg, _gbaea)
		}
		_efeg := Nodes{_aebcgc: _gbaea.Children}
		_afeg = append(_afeg, _efeg.FindNodeByText(text)...)
	}
	return _afeg
}

// SaveToFile writes the document out to a file.
func (_cegf *Document) SaveToFile(path string) error {
	_bggf, _dffb := _ea.Create(path)
	if _dffb != nil {
		return _dffb
	}
	defer _bggf.Close()
	return _cegf.Save(_bggf)
}

// Open opens and reads a document from a file (.docx).
func Open(filename string) (*Document, error) {
	_aacag, _ffec := _ea.Open(filename)
	if _ffec != nil {
		return nil, _dd.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _ffec)
	}
	defer _aacag.Close()
	_ddag, _ffec := _ea.Stat(filename)
	if _ffec != nil {
		return nil, _dd.Errorf("e\u0072r\u006f\u0072\u0020\u006f\u0070\u0065\u006e\u0069n\u0067\u0020\u0025\u0073: \u0025\u0073", filename, _ffec)
	}
	_ = _ddag
	return Read(_aacag, _ddag.Size())
}

// GetImageByRelID returns an ImageRef with the associated relation ID in the
// document.
func (_adea *Document) GetImageByRelID(relID string) (_ee.ImageRef, bool) {
	_babf := _adea._afff.GetTargetByRelId(relID)
	_beeb := ""
	for _, _fgd := range _adea._dgea {
		if _beeb != "" {
			break
		}
		_beeb = _fgd.GetTargetByRelId(relID)
	}
	_abdf := ""
	for _, _cfgd := range _adea._fce {
		if _abdf != "" {
			break
		}
		_abdf = _cfgd.GetTargetByRelId(relID)
	}
	for _, _bedf := range _adea.Images {
		if _bedf.RelID() == relID {
			return _bedf, true
		}
		if _babf != "" {
			_feac := _ac.Replace(_bedf.Target(), "\u0077\u006f\u0072d\u002f", "", 1)
			if _feac == _babf {
				if _bedf.RelID() == "" {
					_bedf.SetRelID(relID)
				}
				return _bedf, true
			}
		}
		if _beeb != "" {
			_beffe := _ac.Replace(_bedf.Target(), "\u0077\u006f\u0072d\u002f", "", 1)
			if _beffe == _beeb {
				if _bedf.RelID() == "" {
					_bedf.SetRelID(relID)
				}
				return _bedf, true
			}
		}
		if _abdf != "" {
			_daae := _ac.Replace(_bedf.Target(), "\u0077\u006f\u0072d\u002f", "", 1)
			if _daae == _abdf {
				if _bedf.RelID() == "" {
					_bedf.SetRelID(relID)
				}
				return _bedf, true
			}
		}
	}
	return _ee.ImageRef{}, false
}

// HasComments checks if the document contains comments.
func (_gafg *Document) HasComments() bool { return _gafg._aeg != nil }

// SetValue sets the width value.
func (_cdccc TableWidth) SetValue(m _cdg.Distance) {
	_cdccc._baggc.WAttr = &_deg.ST_MeasurementOrPercent{}
	_cdccc._baggc.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_cdccc._baggc.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(m / _cdg.Twips))
	_cdccc._baggc.TypeAttr = _deg.ST_TblWidthDxa
}

// FormFields extracts all the fields from a document.  They can then be
// manipulated via the methods on the field and the document saved.
func (_faedb *Document) FormFields() []FormField {
	_dagb := []FormField{}
	for _, _gefd := range _faedb.Paragraphs() {
		_ggfg := _gefd.Runs()
		for _eedg, _bgagd := range _ggfg {
			for _, _adeaf := range _bgagd._gabc.EG_RunInnerContent {
				if _adeaf.RunInnerContentChoice.FldChar == nil || _adeaf.RunInnerContentChoice.FldChar.FldCharChoice.FfData == nil {
					continue
				}
				if _adeaf.RunInnerContentChoice.FldChar.FldCharTypeAttr == _deg.ST_FldCharTypeBegin {
					_dfafd := false
					for _, _edc := range _adeaf.RunInnerContentChoice.FldChar.FldCharChoice.FfData.FFDataChoice {
						if _edc.Name == nil || _edc.Name.ValAttr == nil {
							continue
						}
						_dfafd = true
						break
					}
					if !_dfafd {
						continue
					}
					_bcga := FormField{_bgcg: _adeaf.RunInnerContentChoice.FldChar.FldCharChoice.FfData}
					for _, _gdbf := range _adeaf.RunInnerContentChoice.FldChar.FldCharChoice.FfData.FFDataChoice {
						if _gdbf.TextInput == nil {
							continue
						}
						for _bcgb := _eedg + 1; _bcgb < len(_ggfg)-1; _bcgb++ {
							if len(_ggfg[_bcgb]._gabc.EG_RunInnerContent) == 0 {
								continue
							}
							_gbegd := _ggfg[_bcgb]._gabc.EG_RunInnerContent[0]
							if _gbegd.RunInnerContentChoice.FldChar != nil && _gbegd.RunInnerContentChoice.FldChar.FldCharTypeAttr == _deg.ST_FldCharTypeSeparate {
								if len(_ggfg[_bcgb+1]._gabc.EG_RunInnerContent) == 0 {
									continue
								}
								if _ggfg[_bcgb+1]._gabc.EG_RunInnerContent[0].RunInnerContentChoice.FldChar == nil {
									_bcga._edda = _ggfg[_bcgb+1]._gabc.EG_RunInnerContent[0]
									break
								}
							}
						}
					}
					_dagb = append(_dagb, _bcga)
				}
			}
		}
	}
	for _, _cgea := range _faedb.Headers() {
		for _, _egd := range _cgea.Paragraphs() {
			_aebg := _egd.Runs()
			for _cffd, _baaa := range _aebg {
				for _, _cead := range _baaa._gabc.EG_RunInnerContent {
					if _cead.RunInnerContentChoice.FldChar == nil || _cead.RunInnerContentChoice.FldChar.FldCharChoice.FfData == nil {
						continue
					}
					if _cead.RunInnerContentChoice.FldChar.FldCharTypeAttr == _deg.ST_FldCharTypeBegin {
						_bbgf := false
						for _, _fafe := range _cead.RunInnerContentChoice.FldChar.FldCharChoice.FfData.FFDataChoice {
							if _fafe.Name == nil || _fafe.Name.ValAttr == nil {
								continue
							}
							_bbgf = true
							break
						}
						if !_bbgf {
							continue
						}
						_fffb := FormField{_bgcg: _cead.RunInnerContentChoice.FldChar.FldCharChoice.FfData}
						for _, _cebad := range _cead.RunInnerContentChoice.FldChar.FldCharChoice.FfData.FFDataChoice {
							if _cebad.TextInput == nil {
								continue
							}
							for _cacdf := _cffd + 1; _cacdf < len(_aebg)-1; _cacdf++ {
								if len(_aebg[_cacdf]._gabc.EG_RunInnerContent) == 0 {
									continue
								}
								_adae := _aebg[_cacdf]._gabc.EG_RunInnerContent[0]
								if _adae.RunInnerContentChoice.FldChar != nil && _adae.RunInnerContentChoice.FldChar.FldCharTypeAttr == _deg.ST_FldCharTypeSeparate {
									if len(_aebg[_cacdf+1]._gabc.EG_RunInnerContent) == 0 {
										continue
									}
									if _aebg[_cacdf+1]._gabc.EG_RunInnerContent[0].RunInnerContentChoice.FldChar == nil {
										_fffb._edda = _aebg[_cacdf+1]._gabc.EG_RunInnerContent[0]
										break
									}
								}
							}
						}
						_dagb = append(_dagb, _fffb)
					}
				}
			}
		}
	}
	for _, _gdccb := range _faedb.Footers() {
		for _, _adcc := range _gdccb.Paragraphs() {
			_bebd := _adcc.Runs()
			for _cege, _dcag := range _bebd {
				for _, _bbga := range _dcag._gabc.EG_RunInnerContent {
					if _bbga.RunInnerContentChoice.FldChar == nil || _bbga.RunInnerContentChoice.FldChar.FldCharChoice.FfData == nil {
						continue
					}
					if _bbga.RunInnerContentChoice.FldChar.FldCharTypeAttr == _deg.ST_FldCharTypeBegin {
						_dfab := false
						for _, _ebcf := range _bbga.RunInnerContentChoice.FldChar.FldCharChoice.FfData.FFDataChoice {
							if _ebcf.Name == nil || _ebcf.Name.ValAttr == nil {
								continue
							}
							_dfab = true
							break
						}
						if !_dfab {
							continue
						}
						_ggabd := FormField{_bgcg: _bbga.RunInnerContentChoice.FldChar.FldCharChoice.FfData}
						for _, _cfdd := range _bbga.RunInnerContentChoice.FldChar.FldCharChoice.FfData.FFDataChoice {
							if _cfdd.TextInput == nil {
								continue
							}
							for _cebc := _cege + 1; _cebc < len(_bebd)-1; _cebc++ {
								if len(_bebd[_cebc]._gabc.EG_RunInnerContent) == 0 {
									continue
								}
								_cedef := _bebd[_cebc]._gabc.EG_RunInnerContent[0]
								if _cedef.RunInnerContentChoice.FldChar != nil && _cedef.RunInnerContentChoice.FldChar.FldCharTypeAttr == _deg.ST_FldCharTypeSeparate {
									if len(_bebd[_cebc+1]._gabc.EG_RunInnerContent) == 0 {
										continue
									}
									if _bebd[_cebc+1]._gabc.EG_RunInnerContent[0].RunInnerContentChoice.FldChar == nil {
										_ggabd._edda = _bebd[_cebc+1]._gabc.EG_RunInnerContent[0]
										break
									}
								}
							}
						}
						_dagb = append(_dagb, _ggabd)
					}
				}
			}
		}
	}
	return _dagb
}

// X returns the inner wrapped XML type.
func (_acaf TableWidth) X() *_deg.CT_TblWidth { return _acaf._baggc }

// SetDefaultValue sets the default value of a FormFieldTypeDropDown. For
// FormFieldTypeDropDown, the value must be one of the fields possible values.
func (_ggfgf FormField) SetDefaultValue(v string) {
	if len(_ggfgf._bgcg.FFDataChoice) > 0 {
		for _, _fcee := range _ggfgf._bgcg.FFDataChoice {
			if _fcee.DdList != nil {
				for _eeadg, _cggg := range _ggfgf.PossibleValues() {
					if _cggg == v {
						_fcee.DdList.Default = _deg.NewCT_DecimalNumber()
						_fcee.DdList.Default.ValAttr = int64(_eeadg)
						break
					}
				}
			}
		}
	}
}

// Section is the beginning of a new section.
type Section struct {
	_bbbea *Document
	_eegag *_deg.CT_SectPr
}

// SearchStylesById returns style by its id.
func (_cffb Styles) SearchStyleById(id string) (Style, bool) {
	for _, _bfge := range _cffb._cegfc.Style {
		if _bfge.StyleIdAttr != nil {
			if *_bfge.StyleIdAttr == id {
				return Style{_bfge}, true
			}
		}
	}
	return Style{}, false
}

// VerticalAlign returns the value of paragraph vertical align.
func (_dgeb ParagraphProperties) VerticalAlignment() _fae.ST_VerticalAlignRun {
	if _bgdb := _dgeb._adegb.RPr.VertAlign; _bgdb != nil {
		return _bgdb.ValAttr
	}
	return 0
}

// TableLook is the conditional formatting associated with a table style that
// has been assigned to a table.
type TableLook struct{ _bfdc *_deg.CT_TblLook }

// PutNodeAfter put node to position after relativeTo.
func (_eddd *Document) PutNodeAfter(relativeTo, node Node) { _eddd.putNode(relativeTo, node, false) }

// SetInnerShadowImageEffect sets the inner shadow image effect.
func (_cfd AnchoredDrawing) SetInnerShadowImageEffect(radius, offset _cdg.Distance, c _bg.Color, degrees float64) {
	_cc := _cdg.ToEMU(float64(radius))
	_bded := _cdg.ToEMU(float64(offset))
	_gff := int32(degrees * 60000)
	for _, _dbc := range _cfd._bgc.Graphic.GraphicData.Any {
		if _gad, _ece := _dbc.(*_gg.Pic); _ece {
			_cfd.initializeEffectList(_gad.SpPr)
			_gad.SpPr.EffectPropertiesChoice.EffectLst.InnerShdw = _ad.NewCT_InnerShadowEffect()
			_gad.SpPr.EffectPropertiesChoice.EffectLst.InnerShdw.BlurRadAttr = &_cc
			_gad.SpPr.EffectPropertiesChoice.EffectLst.InnerShdw.DistAttr = &_bded
			_gad.SpPr.EffectPropertiesChoice.EffectLst.InnerShdw.DirAttr = &_gff
			_gad.SpPr.EffectPropertiesChoice.EffectLst.InnerShdw.SrgbClr = _ad.NewCT_SRgbColor()
			_gad.SpPr.EffectPropertiesChoice.EffectLst.InnerShdw.SrgbClr.ValAttr = *c.AsRGBString()
		}
	}
}

// ComplexSizeValue returns the value of run font size for complex fonts in points.
func (_ddbb RunProperties) ComplexSizeValue() float64 {
	if _cbgcf := _ddbb._bfed.SzCs; _cbgcf != nil {
		_gfedba := _cbgcf.ValAttr
		if _gfedba.ST_UnsignedDecimalNumber != nil {
			return float64(*_gfedba.ST_UnsignedDecimalNumber) / 2
		}
	}
	return 0.0
}

// WatermarkText is watermark text within the document.
type WatermarkText struct {
	_deegd *_deg.CT_Picture
	_afef  *_bgg.TextpathStyle
	_cfbf  *_dc.Shape
	_dbda  *_dc.Shapetype
}

// HasFootnotes returns a bool based on the presence or abscence of footnotes within
// the document.
func (_abgg *Document) HasFootnotes() bool { return _abgg._daaf != nil }
func (_gccgb *WatermarkPicture) getShapeType() *_e.XSDAny {
	return _gccgb.getInnerElement("\u0073h\u0061\u0070\u0065\u0074\u0079\u0070e")
}
func (_fed *Document) InsertTableBefore(relativeTo Paragraph) Table {
	return _fed.insertTable(relativeTo, true)
}
func (_edbf Paragraph) insertRun(_fgeg Run, _gdga bool) Run {
	for _, _aabcg := range _edbf._bbff.EG_PContent {
		for _dcaf, _bgeb := range _aabcg.PContentChoice.EG_ContentRunContent {
			if _bgeb.ContentRunContentChoice.R == _fgeg.X() {
				_gefcg := _deg.NewCT_R()
				_aabcg.PContentChoice.EG_ContentRunContent = append(_aabcg.PContentChoice.EG_ContentRunContent, nil)
				if _gdga {
					copy(_aabcg.PContentChoice.EG_ContentRunContent[_dcaf+1:], _aabcg.PContentChoice.EG_ContentRunContent[_dcaf:])
					_aabcg.PContentChoice.EG_ContentRunContent[_dcaf] = _deg.NewEG_ContentRunContent()
					_aabcg.PContentChoice.EG_ContentRunContent[_dcaf].ContentRunContentChoice.R = _gefcg
				} else {
					copy(_aabcg.PContentChoice.EG_ContentRunContent[_dcaf+2:], _aabcg.PContentChoice.EG_ContentRunContent[_dcaf+1:])
					_aabcg.PContentChoice.EG_ContentRunContent[_dcaf+1] = _deg.NewEG_ContentRunContent()
					_aabcg.PContentChoice.EG_ContentRunContent[_dcaf+1].ContentRunContentChoice.R = _gefcg
				}
				return Run{_edbf._eaefb, _gefcg}
			}
			if _bgeb.ContentRunContentChoice.Sdt != nil && _bgeb.ContentRunContentChoice.Sdt.SdtContent != nil {
				for _, _cecbg := range _bgeb.ContentRunContentChoice.Sdt.SdtContent.EG_PContent {
					for _, _fdef := range _cecbg.PContentChoice.EG_ContentRunContent {
						if _fdef.ContentRunContentChoice.R == _fgeg.X() {
							_faeac := _deg.NewCT_R()
							_cecbg.PContentChoice.EG_ContentRunContent = append(_cecbg.PContentChoice.EG_ContentRunContent, nil)
							if _gdga {
								copy(_cecbg.PContentChoice.EG_ContentRunContent[_dcaf+1:], _cecbg.PContentChoice.EG_ContentRunContent[_dcaf:])
								_cecbg.PContentChoice.EG_ContentRunContent[_dcaf] = _deg.NewEG_ContentRunContent()
								_cecbg.PContentChoice.EG_ContentRunContent[_dcaf].ContentRunContentChoice.R = _faeac
							} else {
								copy(_cecbg.PContentChoice.EG_ContentRunContent[_dcaf+2:], _cecbg.PContentChoice.EG_ContentRunContent[_dcaf+1:])
								_cecbg.PContentChoice.EG_ContentRunContent[_dcaf+1] = _deg.NewEG_ContentRunContent()
								_cecbg.PContentChoice.EG_ContentRunContent[_dcaf+1].ContentRunContentChoice.R = _faeac
							}
							return Run{_edbf._eaefb, _faeac}
						}
					}
				}
			}
		}
	}
	return _edbf.AddRun()
}

// SetWidthPercent sets the table to a width percentage.
func (_cebfe TableProperties) SetWidthPercent(pct float64) {
	_cebfe._gafba.TblW = _deg.NewCT_TblWidth()
	_cebfe._gafba.TblW.TypeAttr = _deg.ST_TblWidthPct
	_cebfe._gafba.TblW.WAttr = &_deg.ST_MeasurementOrPercent{}
	_cebfe._gafba.TblW.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_cebfe._gafba.TblW.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(pct * 50))
}

// Node is document element node,
// contains Paragraph or Table element.
type Node struct {
	_cdfa            *Document
	_bbbg            interface{}
	Style            Style
	AnchoredDrawings []AnchoredDrawing
	InlineDrawings   []InlineDrawing
	Children         []Node
}

// SetLeft sets the cell left margin
func (_gaa CellMargins) SetLeft(d _cdg.Distance) {
	_gaa._fee.Left = _deg.NewCT_TblWidth()
	_gecb(_gaa._fee.Left, d)
}

// Properties returns the cell properties.
func (_gcc Cell) Properties() CellProperties {
	if _gcc._fdf.TcPr == nil {
		_gcc._fdf.TcPr = _deg.NewCT_TcPr()
	}
	return CellProperties{_gcc._fdf.TcPr}
}

// ExtractText returns text from the document as a DocText object.
func (_adeg *Document) ExtractText() *DocText {
	_fbag := []TextItem{}
	for _, _edacd := range _adeg._effc.Body.EG_BlockLevelElts {
		_fbag = append(_fbag, _aege(_edacd.BlockLevelEltsChoice.EG_ContentBlockContent, nil)...)
	}
	var _cfcf []listItemInfo
	_facg := _adeg.Paragraphs()
	for _, _dgge := range _facg {
		_faad := _fgfbb(_adeg, _dgge)
		_cfcf = append(_cfcf, _faad)
	}
	_deag := _eaaf(_adeg)
	return &DocText{Items: _fbag, _cedag: _cfcf, _facbe: _deag}
}

// AddRow adds a row to a table.
func (_gggcc Table) AddRow() Row {
	_caeg := _deg.NewEG_ContentRowContent()
	_gggcc._abbae.EG_ContentRowContent = append(_gggcc._abbae.EG_ContentRowContent, _caeg)
	_geagf := _deg.NewCT_Row()
	_caeg.ContentRowContentChoice.Tr = append(_caeg.ContentRowContentChoice.Tr, _geagf)
	return Row{_gggcc._dafd, _geagf}
}

// SetToolTip sets the tooltip text for a hyperlink.
func (_bbfb HyperLink) SetToolTip(text string) {
	if text == "" {
		_bbfb._babce.TooltipAttr = nil
	} else {
		_bbfb._babce.TooltipAttr = _e.String(text)
	}
}
func _befca(_eagbf *_ad.CT_Blip, _dcef map[string]string) {
	if _eagbf.EmbedAttr != nil {
		if _eecde, _bcea := _dcef[*_eagbf.EmbedAttr]; _bcea {
			*_eagbf.EmbedAttr = _eecde
		}
	}
}
func (_gbega *WatermarkText) getShapeType() *_e.XSDAny {
	return _gbega.getInnerElement("\u0073h\u0061\u0070\u0065\u0074\u0079\u0070e")
}

// MailMerge finds mail merge fields and replaces them with the text provided.  It also removes
// the mail merge source info from the document settings.
func (_cdgcd *Document) MailMerge(mergeContent map[string]string) {
	_addc := _cdgcd.mergeFields()
	_gdgfa := map[Paragraph][]Run{}
	for _, _eeee := range _addc {
		_fffdcf, _ffbga := mergeContent[_eeee._bbdde]
		if _ffbga {
			if _eeee._fbfcg {
				_fffdcf = _ac.ToUpper(_fffdcf)
			} else if _eeee._acge {
				_fffdcf = _ac.ToLower(_fffdcf)
			} else if _eeee._gcce {
				_fffdcf = _ac.Title(_fffdcf)
			} else if _eeee._aagab {
				_eeae := _ag.Buffer{}
				for _egdc, _dcae := range _fffdcf {
					if _egdc == 0 {
						_eeae.WriteRune(_a.ToUpper(_dcae))
					} else {
						_eeae.WriteRune(_dcae)
					}
				}
				_fffdcf = _eeae.String()
			}
			if _fffdcf != "" && _eeee._daff != "" {
				_fffdcf = _eeee._daff + _fffdcf
			}
			if _fffdcf != "" && _eeee._dgfff != "" {
				_fffdcf = _fffdcf + _eeee._dgfff
			}
		}
		if _eeee._eefaee {
			if len(_eeee._ffde.PContentChoice.FldSimple) == 1 && len(_eeee._ffde.PContentChoice.FldSimple[0].EG_PContent) == 1 && len(_eeee._ffde.PContentChoice.FldSimple[0].EG_PContent[0].PContentChoice.EG_ContentRunContent) == 1 {
				_ccbcd := _deg.NewEG_ContentRunContent()
				_ccbcd.ContentRunContentChoice.R = _eeee._ffde.PContentChoice.FldSimple[0].EG_PContent[0].PContentChoice.EG_ContentRunContent[0].ContentRunContentChoice.R
				_eeee._ffde.PContentChoice.FldSimple = nil
				_ddfdd := Run{_cdgcd, _ccbcd.ContentRunContentChoice.R}
				_ddfdd.ClearContent()
				_ddfdd.AddText(_fffdcf)
				_eeee._ffde.PContentChoice.EG_ContentRunContent = append(_eeee._ffde.PContentChoice.EG_ContentRunContent, _ccbcd)
			}
		} else {
			_cecb := _eeee._adeaa.Runs()
			for _afag := _eeee._dcgf; _afag <= _eeee._efgf; _afag++ {
				if _afag == _eeee._aeee+1 {
					_cecb[_afag].ClearContent()
					_cecb[_afag].AddText(_fffdcf)
				} else {
					_gdgfa[_eeee._adeaa] = append(_gdgfa[_eeee._adeaa], _cecb[_afag])
				}
			}
		}
	}
	for _cbfba, _dacea := range _gdgfa {
		for _, _aegf := range _dacea {
			_cbfba.RemoveRun(_aegf)
		}
	}
	_cdgcd.Settings.RemoveMailMerge()
}
func _bgdcd(_gfbce *_deg.CT_Border, _efabf _deg.ST_Border, _eebf _bg.Color, _edaaae _cdg.Distance) {
	_gfbce.ValAttr = _efabf
	_gfbce.ColorAttr = &_deg.ST_HexColor{}
	if _eebf.IsAuto() {
		_gfbce.ColorAttr.ST_HexColorAuto = _deg.ST_HexColorAutoAuto
	} else {
		_gfbce.ColorAttr.ST_HexColorRGB = _eebf.AsRGBString()
	}
	if _edaaae != _cdg.Zero {
		_gfbce.SzAttr = _e.Uint64(uint64(_edaaae / _cdg.Point * 8))
	}
}

// X returns the inner wrapped XML type.
func (_gdaf Endnote) X() *_deg.CT_FtnEdn { return _gdaf._cfda }
func (_dddda *WatermarkPicture) findNode(_agdea *_e.XSDAny, _dgbc string) *_e.XSDAny {
	for _, _acbab := range _agdea.Nodes {
		if _acbab.XMLName.Local == _dgbc {
			return _acbab
		}
	}
	return nil
}

// SetBottom sets the bottom border to a specified type, color and thickness.
func (_gdc CellBorders) SetBottom(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_gdc._fba.Bottom = _deg.NewCT_Border()
	_bgdcd(_gdc._fba.Bottom, t, c, thickness)
}

// X returns the inner wrapped XML type.
func (_beca Paragraph) X() *_deg.CT_P { return _beca._bbff }

// SetLeftIndent controls the left indent of the paragraph.
func (_efcea ParagraphStyleProperties) SetLeftIndent(m _cdg.Distance) {
	if _efcea._dgebc.Ind == nil {
		_efcea._dgebc.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_efcea._dgebc.Ind.LeftAttr = nil
	} else {
		_efcea._dgebc.Ind.LeftAttr = &_deg.ST_SignedTwipsMeasure{}
		_efcea._dgebc.Ind.LeftAttr.Int64 = _e.Int64(int64(m / _cdg.Twips))
	}
}

// UnderlineColor returns the hex color value of run underline.
func (_gdcde RunProperties) UnderlineColor() string {
	if _fgaa := _gdcde._bfed.U; _fgaa != nil {
		_fcbcd := _fgaa.ColorAttr
		if _fcbcd != nil && _fcbcd.ST_HexColorRGB != nil {
			return *_fcbcd.ST_HexColorRGB
		}
	}
	return ""
}

// Color controls the run or styles color.
type Color struct{ _dbb *_deg.CT_Color }

// X returns the inner wrapped XML type.
func (_bgaag TableStyleProperties) X() *_deg.CT_TblPrBase { return _bgaag._daffa }
func (_bfabd *Document) onNewRelationship(_fab *_db.DecodeMap, _ddec, _bfac string, _cbba []*_fa.File, _afdb *_eab.Relationship, _adbc _db.Target) error {
	_ddfa := _e.DocTypeDocument
	switch _bfac {
	case _e.OfficeDocumentType, _e.OfficeDocumentTypeStrict:
		_bfabd._effc = _deg.NewDocument()
		_fab.AddTarget(_ddec, _bfabd._effc, _bfac, 0)
		_fab.AddTarget(_db.RelationsPathFor(_ddec), _bfabd._afff.X(), _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.CorePropertiesType:
		_fab.AddTarget(_ddec, _bfabd.CoreProperties.X(), _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.CorePropertiesAltType:
		_fab.AddTarget(_ddec, _bfabd.CoreProperties.X(), _e.CorePropertiesType, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _e.CorePropertiesType, 0)
	case _e.CustomPropertiesType:
		_fab.AddTarget(_ddec, _bfabd.CustomProperties.X(), _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.ExtendedPropertiesType, _e.ExtendedPropertiesTypeStrict:
		_fab.AddTarget(_ddec, _bfabd.AppProperties.X(), _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.ThumbnailType, _e.ThumbnailTypeStrict:
		for _edcg, _gagd := range _cbba {
			if _gagd == nil {
				continue
			}
			if _gagd.Name == _ddec {
				_abbe, _afgd := _gagd.Open()
				if _afgd != nil {
					return _dd.Errorf("e\u0072\u0072\u006f\u0072\u0020\u0072e\u0061\u0064\u0069\u006e\u0067\u0020\u0074\u0068\u0075m\u0062\u006e\u0061i\u006c:\u0020\u0025\u0073", _afgd)
				}
				_bfabd.Thumbnail, _, _afgd = _bfa.Decode(_abbe)
				_abbe.Close()
				if _afgd != nil {
					return _dd.Errorf("\u0065\u0072\u0072\u006fr\u0020\u0064\u0065\u0063\u006f\u0064\u0069\u006e\u0067\u0020t\u0068u\u006d\u0062\u006e\u0061\u0069\u006c\u003a \u0025\u0073", _afgd)
				}
				_cbba[_edcg] = nil
			}
		}
	case _e.SettingsType, _e.SettingsTypeStrict:
		_fab.AddTarget(_ddec, _bfabd.Settings.X(), _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.NumberingType, _e.NumberingTypeStrict:
		_bfabd.Numbering = NewNumbering()
		_fab.AddTarget(_ddec, _bfabd.Numbering.X(), _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.StylesType, _e.StylesTypeStrict:
		_bfabd.Styles.Clear()
		_fab.AddTarget(_ddec, _bfabd.Styles.X(), _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.HeaderType, _e.HeaderTypeStrict:
		_dggf := _deg.NewHdr()
		_fab.AddTarget(_ddec, _dggf, _bfac, uint32(len(_bfabd._aaad)))
		_bfabd._aaad = append(_bfabd._aaad, _dggf)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, len(_bfabd._aaad))
		_egcf := _ee.NewRelationships()
		_fab.AddTarget(_db.RelationsPathFor(_ddec), _egcf.X(), _bfac, 0)
		_bfabd._dgea = append(_bfabd._dgea, _egcf)
	case _e.FooterType, _e.FooterTypeStrict:
		_cgdbc := _deg.NewFtr()
		_fab.AddTarget(_ddec, _cgdbc, _bfac, uint32(len(_bfabd._bcf)))
		_bfabd._bcf = append(_bfabd._bcf, _cgdbc)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, len(_bfabd._bcf))
		_fgcc := _ee.NewRelationships()
		_fab.AddTarget(_db.RelationsPathFor(_ddec), _fgcc.X(), _bfac, 0)
		_bfabd._fce = append(_bfabd._fce, _fgcc)
	case _e.ThemeType, _e.ThemeTypeStrict:
		_gbba := _ad.NewTheme()
		_fab.AddTarget(_ddec, _gbba, _bfac, uint32(len(_bfabd._dgb)))
		_bfabd._dgb = append(_bfabd._dgb, _gbba)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, len(_bfabd._dgb))
	case _e.WebSettingsType, _e.WebSettingsTypeStrict:
		_bfabd._egb = _deg.NewWebSettings()
		_fab.AddTarget(_ddec, _bfabd._egb, _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.FontTableType, _e.FontTableTypeStrict:
		_bfabd._ffea = _deg.NewFonts()
		_fab.AddTarget(_ddec, _bfabd._ffea, _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.FontEmbeddingType:
		_cgdbca := _ee.NewRelationships()
		_fab.AddTarget(_db.RelationsPathFor(_ddec), _cgdbca.X(), _bfac, 0)
		_bfabd._gdcc = _cgdbca
	case _e.EndNotesType, _e.EndNotesTypeStrict:
		_bfabd._ebfb = _deg.NewEndnotes()
		_fab.AddTarget(_ddec, _bfabd._ebfb, _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.FootNotesType, _e.FootNotesTypeStrict:
		_bfabd._daaf = _deg.NewFootnotes()
		_fab.AddTarget(_ddec, _bfabd._daaf, _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.CommentsType:
		_bfabd._aeg = _deg.NewComments()
		_fab.AddTarget(_ddec, _bfabd._aeg, _bfac, 0)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, 0)
	case _e.ImageType, _e.ImageTypeStrict:
		var _egbg _ee.ImageRef
		for _dcg, _fge := range _cbba {
			if _fge == nil {
				continue
			}
			_bccf := _ac.TrimPrefix(_fge.Name, "\u0077\u006f\u0072d\u002f")
			if _daf := _ac.TrimPrefix(_ddec, "\u0077\u006f\u0072d\u002f"); _bccf == _daf {
				_eaea, _bbagg := _db.ExtractToDiskTmp(_fge, _bfabd.TmpPath)
				if _bbagg != nil {
					return _bbagg
				}
				_gdda := _f.Ext(_fge.Name)
				_gbd := _ee.Image{}
				if _gdda[1:] != "\u0065\u006d\u0066" {
					_cggb, _bedg := _ee.ImageFromStorage(_eaea)
					if _bedg != nil {
						return _bedg
					}
					_gbd = _cggb
				} else {
					_gbd.Path = _eaea
				}
				_gbd.Format = _gdda[1:]
				_egbg = _ee.MakeImageRef(_gbd, &_bfabd.DocBase, _bfabd._afff)
				_cbba[_dcg] = nil
			}
		}
		if _egbg.Format() != "" {
			_deabc := "\u002e" + _ac.ToLower(_egbg.Format())
			_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, len(_bfabd.Images)+1)
			if _ecee := _f.Ext(_afdb.TargetAttr); _ecee != _deabc {
				_afdb.TargetAttr = _afdb.TargetAttr[0:len(_afdb.TargetAttr)-len(_ecee)] + _deabc
			}
			_egbg.SetTarget("\u0077\u006f\u0072d\u002f" + _afdb.TargetAttr)
			_bfabd.Images = append(_bfabd.Images, _egbg)
		}
	case _e.ControlType, _e.ControlTypeStrict:
		_eedf := _da.NewOcx()
		_gced := _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, len(_bfabd._gdcf)+1)
		_gcac := "\u0077\u006f\u0072d\u002f" + _gced[:len(_gced)-4] + "\u002e\u0062\u0069\u006e"
		for _ggbeg, _ecbd := range _cbba {
			if _ecbd == nil {
				continue
			}
			if _ecbd.Name == _gcac {
				_gedfa, _efea := _db.ExtractToDiskTmp(_ecbd, _bfabd.TmpPath)
				if _efea != nil {
					return _efea
				}
				_fgec, _efea := _cd.ImportFromFile(_gedfa)
				if _efea == nil {
					_fgec.TargetAttr = _gced
					_fgec.Ocx = _eedf
					_bfabd._gdcf = append(_bfabd._gdcf, _fgec)
					_fab.AddTarget(_ddec, _eedf, _bfac, uint32(len(_bfabd._gdcf)))
					_afdb.TargetAttr = _gced
					_cbba[_ggbeg] = nil
				} else {
					_gd.Log.Debug("c\u0061\u006e\u006e\u006f\u0074\u0020r\u0065\u0061\u0064\u0020\u0062\u0069\u006e\u0020\u0066i\u006c\u0065\u003a \u0025s\u0020\u0025\u0073", _gcac, _efea.Error())
				}
				break
			}
		}
	case _e.ChartType:
		_adac := chart{_cfga: _bd.NewChartSpace()}
		_edd := uint32(len(_bfabd._gbg))
		_fab.AddTarget(_ddec, _adac._cfga, _bfac, _edd)
		_bfabd._gbg = append(_bfabd._gbg, &_adac)
		_afdb.TargetAttr = _e.RelativeFilename(_ddfa, _adbc.Typ, _bfac, len(_bfabd._gbg))
		_adac._bgag = _afdb.TargetAttr
	default:
		_gd.Log.Debug("\u0075\u006e\u0073\u0075\u0070p\u006f\u0072\u0074\u0065\u0064\u0020\u0072\u0065\u006c\u0061\u0074\u0069\u006fn\u0073\u0068\u0069\u0070\u0020\u0074\u0079\u0070\u0065\u003a\u0020\u0025\u0073\u0020\u0074\u0067\u0074\u003a\u0020\u0025\u0073", _bfac, _ddec)
	}
	return nil
}

// DrawingInline return a slice of InlineDrawings.
func (_gaffb Run) DrawingInline() []InlineDrawing {
	_acdce := []InlineDrawing{}
	for _, _dcbd := range _gaffb._gabc.EG_RunInnerContent {
		if _dcbd.RunInnerContentChoice.Drawing == nil {
			continue
		}
		for _, _bdgg := range _dcbd.RunInnerContentChoice.Drawing.DrawingChoice {
			if _bdgg.Inline == nil {
				continue
			}
			_acdce = append(_acdce, InlineDrawing{_gaffb._fced, _bdgg.Inline})
		}
	}
	return _acdce
}
func (_gfbc *Document) addFootnotes() {
	_gfbc._daaf = _deg.NewFootnotes()
	_gfbc._daaf.CT_Footnotes = _deg.CT_Footnotes{}
	_gfbc._daaf.Footnote = make([]*_deg.CT_FtnEdn, 0)
	_gfbc.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072d/\u0066\u006f\u006f\u0074\u006e\u006f\u0074\u0065\u0073\u002e\u0078\u006d\u006c", "\u0061\u0070\u0070\u006c\u0069c\u0061\u0074\u0069\u006f\u006e\u002f\u0076n\u0064\u002e\u006f\u0070\u0065\u006e\u0078\u006d\u006c\u0066\u006f\u0072\u006d\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063e\u0073\u0073\u0069\u006e\u0067\u006d\u006c\u002e\u0066\u006f\u006f\u0074n\u006f\u0074\u0065\u0073\u002b\u0078m\u006c")
	_gfbc._afff.AddRelationship("\u002f\u0077\u006f\u0072d/\u0066\u006f\u006f\u0074\u006e\u006f\u0074\u0065\u0073\u002e\u0078\u006d\u006c", _e.FootNotesType)
	_aggb := _gfbc.Styles.AddStyle(FootnoteTextStyleId, _deg.ST_StyleTypeParagraph, false)
	_aggb.SetName("\u0046\u006f\u006f\u0074\u006e\u006f\u0074\u0065\u0020\u0054\u0065\u0078\u0074")
	_aggb.SetBasedOn("\u004e\u006f\u0072\u006d\u0061\u006c")
	_ggde := _aggb.ParagraphProperties()
	_ggde.X().SuppressLineNumbers = &_deg.CT_OnOff{}
	_cdfe := _aggb.RunProperties()
	_cdfe.X().Sz = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_gda}}
	_cdfe.X().SzCs = &_deg.CT_HpsMeasure{ValAttr: _deg.ST_HpsMeasure{ST_UnsignedDecimalNumber: &_gda}}
	_gaab := _gfbc.Styles.AddStyle(_adb, _deg.ST_StyleTypeCharacter, false)
	_gaab.SetName("\u0046o\u006ft\u006e\u006f\u0074\u0065\u0020R\u0065\u0066e\u0072\u0065\u006e\u0063\u0065")
	_bffb := _gaab.RunProperties()
	_bffb.X().VertAlign = &_deg.CT_VerticalAlignRun{ValAttr: _fae.ST_VerticalAlignRunSuperscript}
	_gfbc.addFootnoteSeparator()
}

// Italic returns true if paragraph font is italic.
func (_begc ParagraphProperties) Italic() bool {
	_gagba := _begc._adegb.RPr
	return _dabbe(_gagba.I) || _dabbe(_gagba.ICs)
}

// FindNodeByRegexp return node based on matched text and return a slice of node.
func (_bdbec *Nodes) FindNodeByRegexp(r *_be.Regexp) []Node {
	_bfced := []Node{}
	for _, _cgdfg := range _bdbec._aebcgc {
		if r.MatchString(_cgdfg.Text()) {
			_bfced = append(_bfced, _cgdfg)
		}
		_efab := Nodes{_aebcgc: _cgdfg.Children}
		_bfced = append(_bfced, _efab.FindNodeByRegexp(r)...)
	}
	return _bfced
}

// RunProperties returns the run properties controlling text formatting within the table.
func (_fafga TableConditionalFormatting) RunProperties() RunProperties {
	if _fafga._ccaae.RPr == nil {
		_fafga._ccaae.RPr = _deg.NewCT_RPr()
	}
	return RunProperties{_fafga._ccaae.RPr}
}
func _cgcfg() *_dc.Textpath {
	_ebcga := _dc.NewTextpath()
	_gbbgb := "\u0066\u006f\u006e\u0074\u002d\u0066\u0061\u006d\u0069l\u0079\u003a\u0022\u0043\u0061\u006c\u0069\u0062\u0072\u0069\u0022\u003b\u0066\u006f\u006e\u0074\u002d\u0073\u0069\u007a\u0065\u003a\u00366\u0070\u0074;\u0066\u006fn\u0074\u002d\u0077\u0065\u0069\u0067\u0068\u0074\u003a\u0062\u006f\u006c\u0064;f\u006f\u006e\u0074\u002d\u0073\u0074\u0079\u006c\u0065:\u0069\u0074\u0061\u006c\u0069\u0063"
	_ebcga.StyleAttr = &_gbbgb
	_bcbef := "\u0041\u0053\u0041\u0050"
	_ebcga.StringAttr = &_bcbef
	_ebcga.FitshapeAttr = _fae.ST_TrueFalseT
	return _ebcga
}

// GetShapeStyle returns string style of the shape in watermark and format it to ShapeStyle.
func (_edcf *WatermarkPicture) GetShapeStyle() _bgg.ShapeStyle {
	if _edcf._bfadf != nil && _edcf._bfadf.StyleAttr != nil {
		return _bgg.NewShapeStyle(*_edcf._bfadf.StyleAttr)
	}
	return _bgg.NewShapeStyle("")
}

// HyperLink is a link within a document.
type HyperLink struct {
	_babe  *Document
	_babce *_deg.CT_Hyperlink
}

// SetTextWrapInFrontOfText sets the text wrap to in front of text.
func (_afc AnchoredDrawing) SetTextWrapInFrontOfText() {
	_afc._bgc.WrapTypeChoice = &_deg.WdEG_WrapTypeChoice{}
	_afc._bgc.WrapTypeChoice.WrapNone = _deg.NewWdCT_WrapNone()
	_afc._bgc.BehindDocAttr = false
	_afc._bgc.LayoutInCellAttr = true
	_afc._bgc.AllowOverlapAttr = true
}

// Style returns the style for a paragraph, or an empty string if it is unset.
func (_cgdd ParagraphProperties) Style() string {
	if _cgdd._adegb.PStyle != nil {
		return _cgdd._adegb.PStyle.ValAttr
	}
	return ""
}

// FindNodeByCondition return node based on condition function,
// if wholeElements is true, its will extract children as next node elements.
func (_eddg *Nodes) FindNodeByCondition(f func(_bfad *Node) bool, wholeElements bool) []Node {
	_fadcb := []Node{}
	for _, _eeba := range _eddg._aebcgc {
		if f(&_eeba) {
			_fadcb = append(_fadcb, _eeba)
		}
		if wholeElements {
			_cgcbf := Nodes{_aebcgc: _eeba.Children}
			_fadcb = append(_fadcb, _cgcbf.FindNodeByCondition(f, wholeElements)...)
		}
	}
	return _fadcb
}

// InsertRunBefore inserts a run in the paragraph before the relative run.
func (_aegad Paragraph) InsertRunBefore(relativeTo Run) Run {
	return _aegad.insertRun(relativeTo, true)
}

// SetAll sets all of the borders to a given value.
func (_gecda ParagraphBorders) SetAll(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_gecda.SetBottom(t, c, thickness)
	_gecda.SetLeft(t, c, thickness)
	_gecda.SetRight(t, c, thickness)
	_gecda.SetTop(t, c, thickness)
}

// SetBottom sets the bottom border to a specified type, color and thickness.
func (_deff ParagraphBorders) SetBottom(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_deff._gdbad.Bottom = _deg.NewCT_Border()
	_dcfaff(_deff._gdbad.Bottom, t, c, thickness)
}

// AddTable adds a table to the table cell.
func (_aab Cell) AddTable() Table {
	_ddc := _deg.NewEG_BlockLevelElts()
	_aab._fdf.EG_BlockLevelElts = append(_aab._fdf.EG_BlockLevelElts, _ddc)
	_gafd := _deg.NewEG_ContentBlockContent()
	_ddc.BlockLevelEltsChoice.EG_ContentBlockContent = append(_ddc.BlockLevelEltsChoice.EG_ContentBlockContent, _gafd)
	_bab := _deg.NewCT_Tbl()
	_gafd.ContentBlockContentChoice.Tbl = append(_gafd.ContentBlockContentChoice.Tbl, _bab)
	return Table{_aab._dff, _bab}
}

// SetLeft sets the left border to a specified type, color and thickness.
func (_fgab TableBorders) SetLeft(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_fgab._cadbb.Left = _deg.NewCT_Border()
	_bgdcd(_fgab._cadbb.Left, t, c, thickness)
}

// SetSpacing sets the spacing that comes before and after the paragraph.
func (_acea ParagraphStyleProperties) SetSpacing(before, after _cdg.Distance) {
	if _acea._dgebc.Spacing == nil {
		_acea._dgebc.Spacing = _deg.NewCT_Spacing()
	}
	if before == _cdg.Zero {
		_acea._dgebc.Spacing.BeforeAttr = nil
	} else {
		_acea._dgebc.Spacing.BeforeAttr = &_fae.ST_TwipsMeasure{}
		_acea._dgebc.Spacing.BeforeAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(before / _cdg.Twips))
	}
	if after == _cdg.Zero {
		_acea._dgebc.Spacing.AfterAttr = nil
	} else {
		_acea._dgebc.Spacing.AfterAttr = &_fae.ST_TwipsMeasure{}
		_acea._dgebc.Spacing.AfterAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(after / _cdg.Twips))
	}
}

// SetFollowImageShape sets wrapPath to follow image shape,
// if nil return wrapPath that follow image size.
func (_fbg AnchorDrawWrapOptions) SetFollowImageShape(val bool) {
	_fbg._eagb = val
	if !val {
		_eadf, _aeb := _fbf()
		_fbg._bad = _eadf
		_fbg._ddf = _aeb
	}
}
func (_ceff *chart) RelId() string { return _ceff._bfab }

// SetStrict is a shortcut for document.SetConformance,
// as one of these values from github.com/unidoc/unioffice/schema/soo/ofc/sharedTypes:
// ST_ConformanceClassUnset, ST_ConformanceClassStrict or ST_ConformanceClassTransitional.
func (_adef Document) SetStrict(strict bool) {
	if strict {
		_adef._effc.ConformanceAttr = _fae.ST_ConformanceClassStrict
	} else {
		_adef._effc.ConformanceAttr = _fae.ST_ConformanceClassTransitional
	}
}

// SetTextWrapThrough sets the text wrap to through with a give wrap type.
func (_bef AnchoredDrawing) SetTextWrapThrough(option *AnchorDrawWrapOptions) {
	_bef._bgc.WrapTypeChoice = &_deg.WdEG_WrapTypeChoice{}
	_bef._bgc.WrapTypeChoice.WrapThrough = _deg.NewWdCT_WrapThrough()
	_bef._bgc.WrapTypeChoice.WrapThrough.WrapTextAttr = _deg.WdST_WrapTextBothSides
	_cfe := false
	_bef._bgc.WrapTypeChoice.WrapThrough.WrapPolygon.EditedAttr = &_cfe
	if option == nil {
		option = NewAnchorDrawWrapOptions()
	}
	_bef._bgc.WrapTypeChoice.WrapThrough.WrapPolygon.Start = option.GetWrapPathStart()
	_bef._bgc.WrapTypeChoice.WrapThrough.WrapPolygon.LineTo = option.GetWrapPathLineTo()
	_bef._bgc.LayoutInCellAttr = true
	_bef._bgc.AllowOverlapAttr = true
}

// GetNumberingLevelByIds returns a NumberingLevel by its NumId and LevelId attributes
// or an empty one if not found.
func (_dgac *Document) GetNumberingLevelByIds(numId, levelId int64) NumberingLevel {
	if _dgac.Numbering._gcfa == nil {
		return NumberingLevel{}
	}
	for _, _ccfb := range _dgac.Numbering._gcfa.Num {
		if _ccfb != nil && _ccfb.NumIdAttr == numId {
			_cafd := _ccfb.AbstractNumId.ValAttr
			for _, _gafaa := range _dgac.Numbering._gcfa.AbstractNum {
				if _gafaa.AbstractNumIdAttr == _cafd {
					if _gafaa.NumStyleLink != nil && len(_gafaa.Lvl) == 0 {
						if _dbec, _bfcd := _dgac.Styles.SearchStyleById(_gafaa.NumStyleLink.ValAttr); _bfcd {
							if _dbec.ParagraphProperties().NumId() > -1 {
								return _dgac.GetNumberingLevelByIds(_dbec.ParagraphProperties().NumId(), levelId)
							}
						}
					}
					for _, _cfec := range _gafaa.Lvl {
						if _cfec.IlvlAttr == levelId {
							return NumberingLevel{_cfec}
						}
					}
				}
			}
		}
	}
	return NumberingLevel{}
}

// Footers returns the footers defined in the document.
func (_bbg *Document) Footers() []Footer {
	_afca := []Footer{}
	for _, _fcbb := range _bbg._bcf {
		_afca = append(_afca, Footer{_bbg, _fcbb})
	}
	return _afca
}

// SetPageSizeAndOrientation sets the page size and orientation for a section.
func (_adgafb Section) SetPageSizeAndOrientation(w, h _cdg.Distance, orientation _deg.ST_PageOrientation) {
	if _adgafb._eegag.PgSz == nil {
		_adgafb._eegag.PgSz = _deg.NewCT_PageSz()
	}
	_adgafb._eegag.PgSz.OrientAttr = orientation
	if orientation == _deg.ST_PageOrientationLandscape {
		_adgafb._eegag.PgSz.WAttr = &_fae.ST_TwipsMeasure{}
		_adgafb._eegag.PgSz.WAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(h / _cdg.Twips))
		_adgafb._eegag.PgSz.HAttr = &_fae.ST_TwipsMeasure{}
		_adgafb._eegag.PgSz.HAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(w / _cdg.Twips))
	} else {
		_adgafb._eegag.PgSz.WAttr = &_fae.ST_TwipsMeasure{}
		_adgafb._eegag.PgSz.WAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(w / _cdg.Twips))
		_adgafb._eegag.PgSz.HAttr = &_fae.ST_TwipsMeasure{}
		_adgafb._eegag.PgSz.HAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(h / _cdg.Twips))
	}
}

// SetKeepOnOnePage controls if all lines in a paragraph are kept on the same
// page.
func (_cfbc ParagraphProperties) SetKeepOnOnePage(b bool) {
	if !b {
		_cfbc._adegb.KeepLines = nil
	} else {
		_cfbc._adegb.KeepLines = _deg.NewCT_OnOff()
	}
}

// X returns the inner wrapped XML type.
func (_ffg Fonts) X() *_deg.CT_Fonts { return _ffg._gddaa }

// SetSemiHidden controls if the style is hidden in the UI.
func (_fceb Style) SetSemiHidden(b bool) {
	if b {
		_fceb._bageg.SemiHidden = _deg.NewCT_OnOff()
	} else {
		_fceb._bageg.SemiHidden = nil
	}
}

// SetVerticalAlignment sets the vertical alignment of content within a table cell.
func (_bgf CellProperties) SetVerticalAlignment(align _deg.ST_VerticalJc) {
	if align == _deg.ST_VerticalJcUnset {
		_bgf._cbb.VAlign = nil
	} else {
		_bgf._cbb.VAlign = _deg.NewCT_VerticalJc()
		_bgf._cbb.VAlign.ValAttr = align
	}
}

// Clear clears the styes.
func (_cafeg Styles) Clear() {
	_cafeg._cegfc.DocDefaults = nil
	_cafeg._cegfc.LatentStyles = nil
	_cafeg._cegfc.Style = nil
}

// SetUnderline controls underline for a run style.
func (_bafgd RunProperties) SetUnderline(style _deg.ST_Underline, c _bg.Color) {
	if style == _deg.ST_UnderlineUnset {
		_bafgd._bfed.U = nil
	} else {
		_bafgd._bfed.U = _deg.NewCT_Underline()
		_bafgd._bfed.U.ColorAttr = &_deg.ST_HexColor{}
		_bafgd._bfed.U.ColorAttr.ST_HexColorRGB = c.AsRGBString()
		_bafgd._bfed.U.ValAttr = style
	}
}

// SetRight sets the cell right margin
func (_acbc CellMargins) SetRight(d _cdg.Distance) {
	_acbc._fee.Right = _deg.NewCT_TblWidth()
	_gecb(_acbc._fee.Right, d)
}

// CharacterSpacingMeasure returns paragraph characters spacing with its measure which can be mm, cm, in, pt, pc or pi.
func (_gcedg RunProperties) CharacterSpacingMeasure() string {
	if _gbggc := _gcedg._bfed.Spacing; _gbggc != nil {
		_eegbd := _gbggc.ValAttr
		if _eegbd.ST_UniversalMeasure != nil {
			return *_eegbd.ST_UniversalMeasure
		}
	}
	return ""
}

// SetShapeStyle sets style to the element v:shape in watermark.
func (_edeg *WatermarkPicture) SetShapeStyle(shapeStyle _bgg.ShapeStyle) {
	if _edeg._bfadf != nil {
		_bccg := shapeStyle.String()
		_edeg._bfadf.StyleAttr = &_bccg
	}
}

// SetTargetByRef sets the URL target of the hyperlink and is more efficient if a link
// destination will be used many times.
func (_bedd HyperLink) SetTargetByRef(link _ee.Hyperlink) {
	_bedd._babce.IdAttr = _e.String(_ee.Relationship(link).ID())
	_bedd._babce.AnchorAttr = nil
}

// ParagraphProperties returns the paragraph style properties.
func (_aedc Style) ParagraphProperties() ParagraphStyleProperties {
	if _aedc._bageg.PPr == nil {
		_aedc._bageg.PPr = _deg.NewCT_PPrGeneral()
	}
	return ParagraphStyleProperties{_aedc._bageg.PPr}
}

// SetLeft sets the left border to a specified type, color and thickness.
func (_aeebf ParagraphBorders) SetLeft(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_aeebf._gdbad.Left = _deg.NewCT_Border()
	_dcfaff(_aeebf._gdbad.Left, t, c, thickness)
}

// X returns the inner wrapped XML type.
func (_begdf NumberingLevel) X() *_deg.CT_Lvl { return _begdf._cdgg }

// SetWidthAuto sets the the table width to automatic.
func (_addddf TableProperties) SetWidthAuto() {
	_addddf._gafba.TblW = _deg.NewCT_TblWidth()
	_addddf._gafba.TblW.TypeAttr = _deg.ST_TblWidthAuto
}

// PutNodeBefore put node to position before relativeTo.
func (_egge *Document) PutNodeBefore(relativeTo, node Node) { _egge.putNode(relativeTo, node, true) }

// NumberingDefinition defines a numbering definition for a list of pragraphs.
type NumberingDefinition struct{ _feab *_deg.CT_AbstractNum }

func _bafb(_dbbc *_deg.CT_P, _gaafe *_deg.CT_Hyperlink, _gfdd *TableInfo, _aaag *DrawingInfo, _ecgg []*_deg.EG_ContentRunContent) []TextItem {
	_cceg := []TextItem{}
	for _, _cacdce := range _ecgg {
		if _bgge := _cacdce.ContentRunContentChoice.Sdt; _bgge != nil {
			if _bfdfbd := _bgge.SdtContent; _bfdfbd != nil {
				for _, _bdag := range _bfdfbd.EG_PContent {
					_cceg = append(_cceg, _bafb(_dbbc, _gaafe, _gfdd, _aaag, _bdag.PContentChoice.EG_ContentRunContent)...)
				}
			}
		}
		if _fegdc := _cacdce.ContentRunContentChoice.R; _fegdc != nil {
			_cfddd := _ag.NewBuffer([]byte{})
			for _, _eacg := range _fegdc.EG_RunInnerContent {
				if _eacg.RunInnerContentChoice.Br != nil {
					_cfddd.WriteString("\u000a")
				}
				if _eacg.RunInnerContentChoice.Tab != nil {
					_cfddd.WriteString("\u0009")
				}
				if _eacg.RunInnerContentChoice.T != nil {
					_cfddd.WriteString(_eacg.RunInnerContentChoice.T.Content)
				}
				if _eacg.RunInnerContentChoice.Pict != nil && len(_eacg.RunInnerContentChoice.Pict.Any) > 0 {
					for _, _cedb := range _eacg.RunInnerContentChoice.Pict.Any {
						if _acef, _gdgfc := _cedb.(*_dc.Shape); _gdgfc {
							for _, _fdbe := range _acef.ShapeChoice {
								if _eeaac := _fdbe.ShapeElementsChoice.Textbox; _eeaac != nil {
									if _eeaac.TxbxContent != nil {
										for _, _dcgac := range _eeaac.TxbxContent.EG_BlockLevelElts {
											_cceg = append(_cceg, _aege(_dcgac.BlockLevelEltsChoice.EG_ContentBlockContent, nil)...)
										}
									}
								}
							}
						}
					}
				}
			}
			_cceg = append(_cceg, TextItem{Text: _cfddd.String(), DrawingInfo: _aaag, Paragraph: _dbbc, Hyperlink: _gaafe, Run: _fegdc, TableInfo: _gfdd})
			for _, _dbcea := range _fegdc.Extra {
				if _cbgbd, _fgcga := _dbcea.(*_deg.AlternateContentRun); _fgcga {
					_daafe := &DrawingInfo{Drawing: _cbgbd.Choice.Drawing}
					for _, _dagg := range _daafe.Drawing.DrawingChoice {
						if _dagg.Anchor == nil {
							continue
						}
						for _, _gcbgf := range _dagg.Anchor.Graphic.GraphicData.Any {
							if _gaee, _faca := _gcbgf.(*_deg.WdWsp); _faca {
								if _gaee.WordprocessingShapeChoice1 != nil {
									if _faggd := _gaee.SpPr; _faggd != nil {
										if _gdeg := _faggd.Xfrm; _gdeg != nil {
											if _ebfe := _gdeg.Ext; _ebfe != nil {
												_daafe.Width = _ebfe.CxAttr
												_daafe.Height = _ebfe.CyAttr
											}
										}
									}
									for _, _adcd := range _gaee.WordprocessingShapeChoice1.Txbx.TxbxContent.EG_BlockLevelElts {
										for _, _cegd := range _adcd.BlockLevelEltsChoice.EG_ContentBlockContent {
											_cceg = append(_cceg, _eabf(_cegd.ContentBlockContentChoice.P, _gfdd, _daafe)...)
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	return _cceg
}
func _fgfbb(_fabc *Document, _bbcc Paragraph) listItemInfo {
	if _fabc.Numbering.X() == nil {
		return listItemInfo{}
	}
	if len(_fabc.Numbering.Definitions()) < 1 {
		return listItemInfo{}
	}
	_geba := _dfbe(_bbcc)
	if _geba == nil {
		return listItemInfo{}
	}
	_fccfe := _fabc.GetNumberingLevelByIds(_geba.NumId.ValAttr, _geba.Ilvl.ValAttr)
	if _gcgbd := _fccfe.X(); _gcgbd == nil {
		return listItemInfo{}
	}
	_ebcc := int64(0)
	for _, _edbe := range _fabc.Numbering._gcfa.Num {
		if _edbe != nil && _edbe.NumIdAttr == _geba.NumId.ValAttr {
			_ebcc = _edbe.AbstractNumId.ValAttr
		}
	}
	return listItemInfo{FromParagraph: &_bbcc, AbstractNumId: &_ebcc, NumberingLevel: &_fccfe}
}
func (_ecgc *Document) addEndnoteSeparator() {
	_agda := _deg.NewCT_FtnEdn()
	_agda.IdAttr = -1
	_agda.TypeAttr = _deg.ST_FtnEdnSeparator
	_fbac := Footnote{_ecgc, _agda}
	_fbac.X().EG_BlockLevelElts = []*_deg.EG_BlockLevelElts{_deg.NewEG_BlockLevelElts()}
	_gedf := _fbac.AddParagraph()
	_gedf.X().PPr = nil
	_feded := _gedf.AddRun()
	_bfbd := _feded.newIC()
	_bfbd.RunInnerContentChoice.Separator = _deg.NewCT_Empty()
	_ecgc._ebfb.CT_Endnotes.Endnote = append(_ecgc._ebfb.CT_Endnotes.Endnote, _agda)
	_agda = _deg.NewCT_FtnEdn()
	_agda.IdAttr = 0
	_agda.TypeAttr = _deg.ST_FtnEdnContinuationSeparator
	_fbac = Footnote{_ecgc, _agda}
	_fbac.X().EG_BlockLevelElts = []*_deg.EG_BlockLevelElts{_deg.NewEG_BlockLevelElts()}
	_gedf = _fbac.AddParagraph()
	_gedf.X().PPr = nil
	_feded = _gedf.AddRun()
	_bfbd = _feded.newIC()
	_bfbd.RunInnerContentChoice.ContinuationSeparator = _deg.NewCT_Empty()
	_ecgc._ebfb.CT_Endnotes.Endnote = append(_ecgc._ebfb.CT_Endnotes.Endnote, _agda)
}

// SetColumnSpan sets the number of Grid Columns Spanned by the Cell.  This is used
// to give the appearance of merged cells.
func (_efef CellProperties) SetColumnSpan(cols int) {
	if cols == 0 {
		_efef._cbb.GridSpan = nil
	} else {
		_efef._cbb.GridSpan = _deg.NewCT_DecimalNumber()
		_efef._cbb.GridSpan.ValAttr = int64(cols)
	}
}

// TableProperties returns the table style properties.
func (_fafgg Style) TableProperties() TableStyleProperties {
	if _fafgg._bageg.TblPr == nil {
		_fafgg._bageg.TblPr = _deg.NewCT_TblPrBase()
	}
	return TableStyleProperties{_fafgg._bageg.TblPr}
}

// X returns the internally wrapped *wml.CT_SectPr.
func (_abegd Section) X() *_deg.CT_SectPr { return _abegd._eegag }

// SetTextWrapTight sets the text wrap to tight with a give wrap type.
func (_efc AnchoredDrawing) SetTextWrapTight(option *AnchorDrawWrapOptions) {
	_efc._bgc.WrapTypeChoice = &_deg.WdEG_WrapTypeChoice{}
	_efc._bgc.WrapTypeChoice.WrapTight = _deg.NewWdCT_WrapTight()
	_efc._bgc.WrapTypeChoice.WrapTight.WrapTextAttr = _deg.WdST_WrapTextBothSides
	_bca := false
	_efc._bgc.WrapTypeChoice.WrapTight.WrapPolygon.EditedAttr = &_bca
	if option == nil {
		option = NewAnchorDrawWrapOptions()
	}
	_efc._bgc.WrapTypeChoice.WrapTight.WrapPolygon.LineTo = option.GetWrapPathLineTo()
	_efc._bgc.WrapTypeChoice.WrapTight.WrapPolygon.Start = option.GetWrapPathStart()
	_efc._bgc.LayoutInCellAttr = true
	_efc._bgc.AllowOverlapAttr = true
}

// SetEmboss sets the run to embossed text.
func (_ebec RunProperties) SetEmboss(b bool) {
	if !b {
		_ebec._bfed.Emboss = nil
	} else {
		_ebec._bfed.Emboss = _deg.NewCT_OnOff()
	}
}

// AddCheckBox adds checkbox form field to the paragraph and returns it.
func (_gcad Paragraph) AddCheckBox(name string) FormField {
	_baabe := _gcad.addFldCharsForField(name, "\u0046\u004f\u0052M\u0043\u0048\u0045\u0043\u004b\u0042\u004f\u0058")
	_baabe._bgcg.FFDataChoice[0].CheckBox = _deg.NewCT_FFCheckBox()
	return _baabe
}

// SetAll sets all of the borders to a given value.
func (_fgdae TableBorders) SetAll(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_fgdae.SetBottom(t, c, thickness)
	_fgdae.SetLeft(t, c, thickness)
	_fgdae.SetRight(t, c, thickness)
	_fgdae.SetTop(t, c, thickness)
	_fgdae.SetInsideHorizontal(t, c, thickness)
	_fgdae.SetInsideVertical(t, c, thickness)
}

// IsChecked returns true if a FormFieldTypeCheckBox is checked.
func (_ccgd FormField) IsChecked() bool {
	if len(_ccgd._bgcg.FFDataChoice) == 0 {
		return false
	}
	for _, _egcd := range _ccgd._bgcg.FFDataChoice {
		if _egcd.CheckBox != nil {
			if _egcd.CheckBox.Checked != nil {
				return true
			}
		}
	}
	return false
}

// Name returns the name of the field.
func (_efadb FormField) Name() string {
	if len(_efadb._bgcg.FFDataChoice) == 0 {
		return ""
	}
	return *_efadb._bgcg.FFDataChoice[0].Name.ValAttr
}

// Borders allows controlling individual cell borders.
func (_aag CellProperties) Borders() CellBorders {
	if _aag._cbb.TcBorders == nil {
		_aag._cbb.TcBorders = _deg.NewCT_TcBorders()
	}
	return CellBorders{_aag._cbb.TcBorders}
}

// Color returns the style's Color.
func (_cbgbb RunProperties) Color() Color {
	if _cbgbb._bfed.Color == nil {
		_cbgbb._bfed.Color = _deg.NewCT_Color()
	}
	return Color{_cbgbb._bfed.Color}
}
func (_dacec Endnote) id() int64 { return _dacec._cfda.IdAttr }

// NewSettings constructs a new empty Settings
func NewSettings() Settings {
	_fccef := _deg.NewSettings()
	_fccef.Compat = _deg.NewCT_Compat()
	_fbde := _deg.NewCT_CompatSetting()
	_fbde.NameAttr = _e.String("\u0063\u006f\u006d\u0070\u0061\u0074\u0069\u0062\u0069\u006c\u0069\u0074y\u004d\u006f\u0064\u0065")
	_fbde.UriAttr = _e.String("h\u0074\u0074\u0070\u003a\u002f\u002f\u0073\u0063\u0068\u0065\u006d\u0061\u0073\u002e\u006d\u0069\u0063\u0072o\u0073\u006f\u0066\u0074\u002e\u0063\u006f\u006d\u002f\u006fff\u0069\u0063\u0065/\u0077o\u0072\u0064")
	_fbde.ValAttr = _e.String("\u0031\u0035")
	_fccef.Compat.CompatSetting = append(_fccef.Compat.CompatSetting, _fbde)
	return Settings{_fccef}
}

// SetImprint sets the run to imprinted text.
func (_fbbec RunProperties) SetImprint(b bool) {
	if !b {
		_fbbec._bfed.Imprint = nil
	} else {
		_fbbec._bfed.Imprint = _deg.NewCT_OnOff()
	}
}

// X returns the inner wrapped XML type.
func (_efgc TableProperties) X() *_deg.CT_TblPr { return _efgc._gafba }

// GetImage returns the ImageRef associated with an InlineDrawing.
func (_face InlineDrawing) GetImage() (_ee.ImageRef, bool) {
	_ffee := _face._bfcfc.Graphic.GraphicData.Any
	if len(_ffee) > 0 {
		for _, _bcgdc := range _ffee {
			_gbbec, _eecdc := _bcgdc.(*_gg.Pic)
			if _eecdc {
				if _gbbec.BlipFill != nil && _gbbec.BlipFill.Blip != nil && _gbbec.BlipFill.Blip.EmbedAttr != nil {
					return _face._cbge.GetImageByRelID(*_gbbec.BlipFill.Blip.EmbedAttr)
				}
			}
		}
	}
	return _ee.ImageRef{}, false
}

// Row is a row within a table within a document.
type Row struct {
	_bace *Document
	_ebcb *_deg.CT_Row
}

// SetTextStyleItalic sets text style of watermark to italic.
func (_bgcde *WatermarkText) SetTextStyleItalic(value bool) {
	_gaecd := _bgcde.GetStyle()
	_gaecd.SetItalic(value)
	_bgcde.SetStyle(_gaecd)
}

// OnOffValue represents an on/off value that can also be unset
type OnOffValue byte

// ParagraphSpacing controls the spacing for a paragraph and its lines.
type ParagraphSpacing struct{ _gdfc *_deg.CT_Spacing }

// SetSize sets the size of the displayed image on the page.
func (_fcfbb InlineDrawing) SetSize(w, h _cdg.Distance) {
	_fcfbb._bfcfc.Extent.CxAttr = int64(float64(w*_cdg.Pixel72) / _cdg.EMU)
	_fcfbb._bfcfc.Extent.CyAttr = int64(float64(h*_cdg.Pixel72) / _cdg.EMU)
}

// RemoveFootnote removes a footnote from both the paragraph and the document
// the requested footnote must be anchored on the paragraph being referenced.
//
// After each removal, the rest of the footnote ids would be reordered.
func (_dfge Paragraph) RemoveFootnote(id int64) {
	for _, _ccbee := range _dfge.Runs() {
		if _afgb, _gfefe := _ccbee.IsFootnote(); _afgb {
			if _gfefe == id {
				_dfge.RemoveRun(_ccbee)
				break
			}
		}
	}
	_dfge._eaefb.removeFootnote(id)
}

// SetBeforeSpacing sets spacing above paragraph.
func (_ceabb Paragraph) SetBeforeSpacing(d _cdg.Distance) {
	_ceabb.ensurePPr()
	if _ceabb._bbff.PPr.Spacing == nil {
		_ceabb._bbff.PPr.Spacing = _deg.NewCT_Spacing()
	}
	_dagc := _ceabb._bbff.PPr.Spacing
	_dagc.BeforeAttr = &_fae.ST_TwipsMeasure{}
	_dagc.BeforeAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(d / _cdg.Twips))
}

// SetRightIndent controls right indent of paragraph.
func (_fcef Paragraph) SetRightIndent(m _cdg.Distance) {
	_fcef.ensurePPr()
	_cdfee := _fcef._bbff.PPr
	if _cdfee.Ind == nil {
		_cdfee.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_cdfee.Ind.RightAttr = nil
	} else {
		_cdfee.Ind.RightAttr = &_deg.ST_SignedTwipsMeasure{}
		_cdfee.Ind.RightAttr.Int64 = _e.Int64(int64(m / _cdg.Twips))
	}
}

// SetAfterLineSpacing sets spacing below paragraph in line units.
func (_cbgd Paragraph) SetAfterLineSpacing(d _cdg.Distance) {
	_cbgd.ensurePPr()
	if _cbgd._bbff.PPr.Spacing == nil {
		_cbgd._bbff.PPr.Spacing = _deg.NewCT_Spacing()
	}
	_aeaf := _cbgd._bbff.PPr.Spacing
	_aeaf.AfterLinesAttr = _e.Int64(int64(d / _cdg.Twips))
}

// SetStartIndent controls the start indent of the paragraph.
func (_bbacb ParagraphStyleProperties) SetStartIndent(m _cdg.Distance) {
	if _bbacb._dgebc.Ind == nil {
		_bbacb._dgebc.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_bbacb._dgebc.Ind.StartAttr = nil
	} else {
		_bbacb._dgebc.Ind.StartAttr = &_deg.ST_SignedTwipsMeasure{}
		_bbacb._dgebc.Ind.StartAttr.Int64 = _e.Int64(int64(m / _cdg.Twips))
	}
}

// SetSoftEdgeImageEffect sets the soft edge image effect.
func (_cgad AnchoredDrawing) SetSoftEdgeImageEffect(radius _cdg.Distance) {
	_bdc := _cdg.ToEMU(float64(radius))
	for _, _geec := range _cgad._bgc.Graphic.GraphicData.Any {
		if _gcf, _cgab := _geec.(*_gg.Pic); _cgab {
			_cgad.initializeEffectList(_gcf.SpPr)
			_gcf.SpPr.EffectPropertiesChoice.EffectLst.SoftEdge = _ad.NewCT_SoftEdgesEffect()
			_gcf.SpPr.EffectPropertiesChoice.EffectLst.SoftEdge.RadAttr = _bdc
		}
	}
}

// AddFootnoteReference adds a footnote reference to a run.
func (_egebb Run) AddFootnoteReference() {
	_fdcaa := _egebb.newIC()
	_fdcaa.RunInnerContentChoice.FootnoteRef = &_deg.CT_Empty{}
}

// GetColor returns the color.Color object representing the run color.
func (_bdbf RunProperties) GetColor() _bg.Color {
	if _bbfbe := _bdbf._bfed.Color; _bbfbe != nil {
		_agbeb := _bbfbe.ValAttr
		if _agbeb.ST_HexColorRGB != nil {
			return _bg.FromHex(*_agbeb.ST_HexColorRGB)
		}
	}
	return _bg.Color{}
}

// SetLastRow controls the conditional formatting for the last row in a table.
// This is called the 'Total' row within Word.
func (_ageg TableLook) SetLastRow(on bool) {
	if !on {
		_ageg._bfdc.LastRowAttr = &_fae.ST_OnOff{}
		_ageg._bfdc.LastRowAttr.ST_OnOff1 = _fae.ST_OnOff1Off
	} else {
		_ageg._bfdc.LastRowAttr = &_fae.ST_OnOff{}
		_ageg._bfdc.LastRowAttr.ST_OnOff1 = _fae.ST_OnOff1On
	}
}

// SetAfterAuto controls if spacing after a paragraph is automatically determined.
func (_eecaf ParagraphSpacing) SetAfterAuto(b bool) {
	if b {
		_eecaf._gdfc.AfterAutospacingAttr = &_fae.ST_OnOff{}
		_eecaf._gdfc.AfterAutospacingAttr.Bool = _e.Bool(true)
	} else {
		_eecaf._gdfc.AfterAutospacingAttr = nil
	}
}

// SetAllCaps sets the run to all caps.
func (_ccfe RunProperties) SetAllCaps(b bool) {
	if !b {
		_ccfe._bfed.Caps = nil
	} else {
		_ccfe._bfed.Caps = _deg.NewCT_OnOff()
	}
}

// GetEffect returns the effect of the run.
func (_befd RunProperties) GetEffect() _deg.ST_TextEffect {
	if _befd._bfed.Effect == nil {
		return _deg.ST_TextEffectUnset
	}
	return _befd._bfed.Effect.ValAttr
}
func (_agga Endnote) content() []*_deg.EG_ContentBlockContent {
	var _bgcf []*_deg.EG_ContentBlockContent
	for _, _gdgf := range _agga._cfda.EG_BlockLevelElts {
		_bgcf = append(_bgcf, _gdgf.BlockLevelEltsChoice.EG_ContentBlockContent...)
	}
	return _bgcf
}

// GetColor returns the color.Color object representing the run color.
func (_daag ParagraphProperties) GetColor() _bg.Color {
	if _ecgce := _daag._adegb.RPr.Color; _ecgce != nil {
		_dbfaa := _ecgce.ValAttr
		if _dbfaa.ST_HexColorRGB != nil {
			return _bg.FromHex(*_dbfaa.ST_HexColorRGB)
		}
	}
	return _bg.Color{}
}

// FormField is a form within a document. It references the document, so changes
// to the form field wil be reflected in the document if it is saved.
type FormField struct {
	_bgcg *_deg.CT_FFData
	_edda *_deg.EG_RunInnerContent
}

// SetItalic sets the run to italic.
func (_cbgee RunProperties) SetItalic(b bool) {
	if !b {
		_cbgee._bfed.I = nil
		_cbgee._bfed.ICs = nil
	} else {
		_cbgee._bfed.I = _deg.NewCT_OnOff()
		_cbgee._bfed.ICs = _deg.NewCT_OnOff()
	}
}

// Settings controls the document settings.
type Settings struct{ _bbaeb *_deg.Settings }

func (_cdbe *WatermarkPicture) getInnerElement(_dcge string) *_e.XSDAny {
	for _, _ffag := range _cdbe._dbece.Any {
		_cggce, _gead := _ffag.(*_e.XSDAny)
		if _gead && (_cggce.XMLName.Local == _dcge || _cggce.XMLName.Local == "\u0076\u003a"+_dcge) {
			return _cggce
		}
	}
	return nil
}
func _ageec(_acce *_deg.CT_Tbl, _afbd *_deg.CT_P, _cgc bool) *_deg.CT_Tbl {
	for _, _dfdc := range _acce.EG_ContentRowContent {
		for _, _fbc := range _dfdc.ContentRowContentChoice.Tr {
			for _, _ddde := range _fbc.EG_ContentCellContent {
				for _, _edee := range _ddde.ContentCellContentChoice.Tc {
					for _dca, _dgcf := range _edee.EG_BlockLevelElts {
						for _, _efd := range _dgcf.BlockLevelEltsChoice.EG_ContentBlockContent {
							for _fdfe, _edeb := range _efd.ContentBlockContentChoice.P {
								if _edeb == _afbd {
									_cbbg := _deg.NewEG_BlockLevelElts()
									_dgef := _deg.NewEG_ContentBlockContent()
									_cbbg.BlockLevelEltsChoice.EG_ContentBlockContent = append(_cbbg.BlockLevelEltsChoice.EG_ContentBlockContent, _dgef)
									_gedb := _deg.NewCT_Tbl()
									_dgef.ContentBlockContentChoice.Tbl = append(_dgef.ContentBlockContentChoice.Tbl, _gedb)
									_edee.EG_BlockLevelElts = append(_edee.EG_BlockLevelElts, nil)
									if _cgc {
										copy(_edee.EG_BlockLevelElts[_dca+1:], _edee.EG_BlockLevelElts[_dca:])
										_edee.EG_BlockLevelElts[_dca] = _cbbg
										if _fdfe != 0 {
											_ffed := _deg.NewEG_BlockLevelElts()
											_bedb := _deg.NewEG_ContentBlockContent()
											_ffed.BlockLevelEltsChoice.EG_ContentBlockContent = append(_ffed.BlockLevelEltsChoice.EG_ContentBlockContent, _bedb)
											_bedb.ContentBlockContentChoice.P = _efd.ContentBlockContentChoice.P[:_fdfe]
											_edee.EG_BlockLevelElts = append(_edee.EG_BlockLevelElts, nil)
											copy(_edee.EG_BlockLevelElts[_dca+1:], _edee.EG_BlockLevelElts[_dca:])
											_edee.EG_BlockLevelElts[_dca] = _ffed
										}
										_efd.ContentBlockContentChoice.P = _efd.ContentBlockContentChoice.P[_fdfe:]
									} else {
										copy(_edee.EG_BlockLevelElts[_dca+2:], _edee.EG_BlockLevelElts[_dca+1:])
										_edee.EG_BlockLevelElts[_dca+1] = _cbbg
										if _fdfe != len(_efd.ContentBlockContentChoice.P)-1 {
											_eegd := _deg.NewEG_BlockLevelElts()
											_cebe := _deg.NewEG_ContentBlockContent()
											_eegd.BlockLevelEltsChoice.EG_ContentBlockContent = append(_eegd.BlockLevelEltsChoice.EG_ContentBlockContent, _cebe)
											_cebe.ContentBlockContentChoice.P = _efd.ContentBlockContentChoice.P[_fdfe+1:]
											_edee.EG_BlockLevelElts = append(_edee.EG_BlockLevelElts, nil)
											copy(_edee.EG_BlockLevelElts[_dca+3:], _edee.EG_BlockLevelElts[_dca+2:])
											_edee.EG_BlockLevelElts[_dca+2] = _eegd
										} else {
											_fceg := _deg.NewEG_BlockLevelElts()
											_gbgc := _deg.NewEG_ContentBlockContent()
											_fceg.BlockLevelEltsChoice.EG_ContentBlockContent = append(_fceg.BlockLevelEltsChoice.EG_ContentBlockContent, _gbgc)
											_gbgc.ContentBlockContentChoice.P = []*_deg.CT_P{_deg.NewCT_P()}
											_edee.EG_BlockLevelElts = append(_edee.EG_BlockLevelElts, nil)
											copy(_edee.EG_BlockLevelElts[_dca+3:], _edee.EG_BlockLevelElts[_dca+2:])
											_edee.EG_BlockLevelElts[_dca+2] = _fceg
										}
										_efd.ContentBlockContentChoice.P = _efd.ContentBlockContentChoice.P[:_fdfe+1]
									}
									return _gedb
								}
							}
							for _, _acbf := range _efd.ContentBlockContentChoice.Tbl {
								_daaff := _ageec(_acbf, _afbd, _cgc)
								if _daaff != nil {
									return _daaff
								}
							}
						}
					}
				}
			}
		}
	}
	return nil
}

// AddCommentReference adds comment reference to a run.
func (_aeeeb Run) AddCommentReference(id int64) {
	_bgfa := _aeeeb.newIC()
	_bgfa.RunInnerContentChoice.CommentReference = _deg.NewCT_Markup()
	_bgfa.RunInnerContentChoice.CommentReference.IdAttr = id
}

// Comments get list of comments in the document.
func (_cabb *Document) Comments() []Comment {
	_ccfc := []Comment{}
	for _, _cac := range _cabb._aeg.Comment {
		_ccfc = append(_ccfc, Comment{_cabb, _cac})
	}
	return _ccfc
}

// Document is a text document that can be written out in the OOXML .docx
// format. It can be opened from a file on disk and modified, or created from
// scratch.
type Document struct {
	_ee.DocBase
	_effc     *_deg.Document
	Settings  Settings
	Numbering Numbering
	Styles    Styles
	_aaad     []*_deg.Hdr
	_dgea     []_ee.Relationships
	_bcf      []*_deg.Ftr
	_fce      []_ee.Relationships
	_afff     _ee.Relationships
	_dgb      []*_ad.Theme
	_egb      *_deg.WebSettings
	_ffea     *_deg.Fonts
	_gdcc     _ee.Relationships
	_ebfb     *_deg.Endnotes
	_daaf     *_deg.Footnotes
	_gdcf     []*_cd.Control
	_gbg      []*chart
	_aeg      *_deg.Comments
	_cfgg     string
}

// SetCellSpacing sets the cell spacing within a table.
func (_ceabg TableProperties) SetCellSpacing(m _cdg.Distance) {
	_ceabg._gafba.TblCellSpacing = _deg.NewCT_TblWidth()
	_ceabg._gafba.TblCellSpacing.TypeAttr = _deg.ST_TblWidthDxa
	_ceabg._gafba.TblCellSpacing.WAttr = &_deg.ST_MeasurementOrPercent{}
	_ceabg._gafba.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent = &_deg.ST_DecimalNumberOrPercent{}
	_ceabg._gafba.TblCellSpacing.WAttr.ST_DecimalNumberOrPercent.ST_UnqualifiedPercentage = _e.Int64(int64(m / _cdg.Dxa))
}

// Numbering is the document wide numbering styles contained in numbering.xml.
type Numbering struct{ _gcfa *_deg.Numbering }

// SetPicture sets the watermark picture.
func (_agdee *WatermarkPicture) SetPicture(imageRef _ee.ImageRef) {
	_ecgbc := imageRef.RelID()
	_cffcb := _agdee.getShape()
	if _agdee._bfadf != nil {
		_bagc := _agdee._bfadf.ShapeChoice
		if len(_bagc) > 0 && _bagc[0].ShapeElementsChoice.Imagedata != nil {
			_bagc[0].ShapeElementsChoice.Imagedata.IdAttr = &_ecgbc
		}
	} else {
		_ccfcg := _agdee.findNode(_cffcb, "\u0069m\u0061\u0067\u0065\u0064\u0061\u0074a")
		for _gcbgff, _ecedd := range _ccfcg.Attrs {
			if _ecedd.Name.Local == "\u0069\u0064" {
				_ccfcg.Attrs[_gcbgff].Value = _ecgbc
			}
		}
	}
}

// Properties returns the numbering level paragraph properties.
func (_aeaac NumberingLevel) Properties() ParagraphStyleProperties {
	if _aeaac._cdgg.PPr == nil {
		_aeaac._cdgg.PPr = _deg.NewCT_PPrGeneral()
	}
	return ParagraphStyleProperties{_aeaac._cdgg.PPr}
}

// Set3DRotationImageEffect sets the 3D rotation image effect.
func (_ace AnchoredDrawing) Set3DRotationImageEffect() {
	for _, _adg := range _ace._bgc.Graphic.GraphicData.Any {
		if _dec, _beaf := _adg.(*_gg.Pic); _beaf {
			_dec.SpPr.Scene3d = _ad.NewCT_Scene3D()
			_dec.SpPr.Scene3d.Camera = _ad.NewCT_Camera()
			_dec.SpPr.Scene3d.Camera.PrstAttr = _ad.ST_PresetCameraTypeIsometricRightUp
			_dec.SpPr.Scene3d.LightRig = _ad.NewCT_LightRig()
			_dec.SpPr.Scene3d.LightRig.RigAttr = _ad.ST_LightRigTypeThreePt
			_dec.SpPr.Scene3d.LightRig.DirAttr = _ad.ST_LightRigDirectionT
		}
	}
}
func (_ebaf Paragraph) addFldChar() *_deg.CT_FldChar {
	_fcdg := _ebaf.AddRun()
	_gbge := _fcdg.X()
	_daaef := _deg.NewEG_RunInnerContent()
	_ccff := _deg.NewCT_FldChar()
	_daaef.RunInnerContentChoice.FldChar = _ccff
	_gbge.EG_RunInnerContent = append(_gbge.EG_RunInnerContent, _daaef)
	return _ccff
}

// AddFooter creates a Footer associated with the document, but doesn't add it
// to the document for display.
func (_feg *Document) AddFooter() Footer {
	_fegd := _deg.NewFtr()
	_feg._bcf = append(_feg._bcf, _fegd)
	_geda := _dd.Sprintf("\u0066\u006f\u006ft\u0065\u0072\u0025\u0064\u002e\u0078\u006d\u006c", len(_feg._bcf))
	_feg._afff.AddRelationship(_geda, _e.FooterType)
	_feg.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072\u0064\u002f"+_geda, "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0076\u006e\u0064.\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c\u002e\u0066\u006f\u006f\u0074e\u0072\u002b\u0078\u006d\u006c")
	_feg._fce = append(_feg._fce, _ee.NewRelationships())
	return Footer{_feg, _fegd}
}

var _bed = false

// Close closes the document, removing any temporary files that might have been
// created when opening a document.
func (_dcgb *Document) Close() error {
	if _dcgb.TmpPath != "" {
		return _af.RemoveAll(_dcgb.TmpPath)
	}
	return nil
}

// CharacterSpacingValue returns the value of run's characters spacing in twips (1/20 of point).
func (_fbgg RunProperties) CharacterSpacingValue() int64 {
	if _afbgd := _fbgg._bfed.Spacing; _afbgd != nil {
		_ecbge := _afbgd.ValAttr
		if _ecbge.Int64 != nil {
			return *_ecbge.Int64
		}
	}
	return int64(0)
}

// SetFontFamily sets font family of watermark text.
func (_dedda *WatermarkText) SetFontFamily(value string) {
	_ebbd := _dedda.GetStyle()
	_ebbd.SetFontFamily("\u0022" + value + "\u0022")
	_dedda.SetStyle(_ebbd)
}
func (_eacd *Document) appendParagraph(_aaeb *Paragraph, _ceg Paragraph, _ceaa bool) Paragraph {
	_ggcg := _deg.NewEG_BlockLevelElts()
	_eacd._effc.Body.EG_BlockLevelElts = append(_eacd._effc.Body.EG_BlockLevelElts, _ggcg)
	_ecf := _deg.NewEG_ContentBlockContent()
	_ggcg.BlockLevelEltsChoice.EG_ContentBlockContent = append(_ggcg.BlockLevelEltsChoice.EG_ContentBlockContent, _ecf)
	if _aaeb != nil {
		_daed := _aaeb.X()
		for _, _dgcg := range _eacd._effc.Body.EG_BlockLevelElts {
			for _, _cfgf := range _dgcg.BlockLevelEltsChoice.EG_ContentBlockContent {
				for _ffb, _bbe := range _cfgf.ContentBlockContentChoice.P {
					if _bbe == _daed {
						_gbga := _ceg.X()
						_cfgf.ContentBlockContentChoice.P = append(_cfgf.ContentBlockContentChoice.P, nil)
						if _ceaa {
							copy(_cfgf.ContentBlockContentChoice.P[_ffb+1:], _cfgf.ContentBlockContentChoice.P[_ffb:])
							_cfgf.ContentBlockContentChoice.P[_ffb] = _gbga
						} else {
							copy(_cfgf.ContentBlockContentChoice.P[_ffb+2:], _cfgf.ContentBlockContentChoice.P[_ffb+1:])
							_cfgf.ContentBlockContentChoice.P[_ffb+1] = _gbga
						}
						break
					}
				}
				for _, _faf := range _cfgf.ContentBlockContentChoice.Tbl {
					for _, _ebfg := range _faf.EG_ContentRowContent {
						for _, _gab := range _ebfg.ContentRowContentChoice.Tr {
							for _, _effb := range _gab.EG_ContentCellContent {
								for _, _fga := range _effb.ContentCellContentChoice.Tc {
									for _, _dad := range _fga.EG_BlockLevelElts {
										for _, _abe := range _dad.BlockLevelEltsChoice.EG_ContentBlockContent {
											for _eagf, _fcf := range _abe.ContentBlockContentChoice.P {
												if _fcf == _daed {
													_dcb := _ceg.X()
													_abe.ContentBlockContentChoice.P = append(_abe.ContentBlockContentChoice.P, nil)
													if _ceaa {
														copy(_abe.ContentBlockContentChoice.P[_eagf+1:], _abe.ContentBlockContentChoice.P[_eagf:])
														_abe.ContentBlockContentChoice.P[_eagf] = _dcb
													} else {
														copy(_abe.ContentBlockContentChoice.P[_eagf+2:], _abe.ContentBlockContentChoice.P[_eagf+1:])
														_abe.ContentBlockContentChoice.P[_eagf+1] = _dcb
													}
													break
												}
											}
										}
									}
								}
							}
						}
					}
				}
				if _cfgf.ContentBlockContentChoice.Sdt != nil && _cfgf.ContentBlockContentChoice.Sdt.SdtContent != nil {
					for _, _ddea := range _cfgf.ContentBlockContentChoice.Sdt.SdtContent.EG_ContentBlockContent {
						for _beg, _gaca := range _ddea.ContentBlockContentChoice.P {
							if _gaca == _daed {
								_deab := _ceg.X()
								_ddea.ContentBlockContentChoice.P = append(_ddea.ContentBlockContentChoice.P, nil)
								if _ceaa {
									copy(_ddea.ContentBlockContentChoice.P[_beg+1:], _ddea.ContentBlockContentChoice.P[_beg:])
									_ddea.ContentBlockContentChoice.P[_beg] = _deab
								} else {
									copy(_ddea.ContentBlockContentChoice.P[_beg+2:], _ddea.ContentBlockContentChoice.P[_beg+1:])
									_ddea.ContentBlockContentChoice.P[_beg+1] = _deab
								}
								break
							}
						}
					}
				}
			}
		}
	} else {
		_ecf.ContentBlockContentChoice.P = append(_ecf.ContentBlockContentChoice.P, _ceg.X())
	}
	_bdbg := _ceg.Properties()
	if _ggb, _fgba := _bdbg.Section(); _fgba {
		var (
			_gdae map[string]string
			_cddd map[string]string
		)
		_aafd := _ggb.X().EG_HdrFtrReferences
		for _, _aebaf := range _aafd {
			if _aebaf.HdrFtrReferencesChoice.HeaderReference != nil {
				_gdae = map[string]string{_aebaf.HdrFtrReferencesChoice.HeaderReference.IdAttr: _ggb._bbbea._afff.GetTargetByRelId(_aebaf.HdrFtrReferencesChoice.HeaderReference.IdAttr)}
			}
			if _aebaf.HdrFtrReferencesChoice.FooterReference != nil {
				_cddd = map[string]string{_aebaf.HdrFtrReferencesChoice.FooterReference.IdAttr: _ggb._bbbea._afff.GetTargetByRelId(_aebaf.HdrFtrReferencesChoice.FooterReference.IdAttr)}
			}
		}
		var _gbeg map[int]_ee.ImageRef
		for _, _ggbe := range _ggb._bbbea.Headers() {
			for _ggab, _fdfb := range _gdae {
				_gbbf := _dd.Sprintf("\u0068\u0065\u0061d\u0065\u0072\u0025\u0064\u002e\u0078\u006d\u006c", (_ggbe.Index() + 1))
				if _gbbf == _fdfb {
					_bbb := _dd.Sprintf("\u0068\u0065\u0061d\u0065\u0072\u0025\u0064\u002e\u0078\u006d\u006c", _ggbe.Index())
					_eacd._aaad = append(_eacd._aaad, _ggbe.X())
					_bdf := _eacd._afff.AddRelationship(_bbb, _e.HeaderType)
					_bdf.SetID(_ggab)
					_eacd.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072\u0064\u002f"+_bbb, "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0076\u006e\u0064.\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c\u002e\u0068\u0065\u0061\u0064e\u0072\u002b\u0078\u006d\u006c")
					_eacd._dgea = append(_eacd._dgea, _ee.NewRelationships())
					_bcba := _ggbe.Paragraphs()
					for _, _gdgb := range _bcba {
						for _, _edec := range _gdgb.Runs() {
							_bade := _edec.DrawingAnchored()
							for _, _deaf := range _bade {
								if _ebb, _gdac := _deaf.GetImage(); _gdac {
									_gbeg = map[int]_ee.ImageRef{_ggbe.Index(): _ebb}
								}
							}
							_bae := _edec.DrawingInline()
							for _, _ddbd := range _bae {
								if _bgb, _ecbb := _ddbd.GetImage(); _ecbb {
									_gbeg = map[int]_ee.ImageRef{_ggbe.Index(): _bgb}
								}
							}
						}
					}
				}
			}
		}
		for _bfc, _ddbg := range _gbeg {
			for _, _gfbd := range _eacd.Headers() {
				if (_gfbd.Index() + 1) == _bfc {
					_aefg, _geeg := _ee.ImageFromFile(_ddbg.Path())
					if _geeg != nil {
						_gd.Log.Debug("\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0063r\u0065\u0061\u0074\u0065\u0020\u0069\u006d\u0061\u0067\u0065:\u0020\u0025\u0073", _geeg)
					}
					if _, _geeg = _gfbd.AddImage(_aefg); _geeg != nil {
						_gd.Log.Debug("u\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0061\u0064\u0064\u0020i\u006d\u0061\u0067\u0065\u0020\u0074\u006f \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u003a\u0020%\u0073", _geeg)
					}
				}
				for _, _eega := range _gfbd.Paragraphs() {
					if _cca, _gfea := _ggb._bbbea.Styles.SearchStyleById(_eega.Style()); _gfea {
						if _, _ega := _eacd.Styles.SearchStyleById(_eega.Style()); !_ega {
							_eacd.Styles.InsertStyle(_cca)
						}
					}
				}
			}
		}
		var _gfedb map[int]_ee.ImageRef
		for _, _dgeec := range _ggb._bbbea.Footers() {
			for _bcef, _beba := range _cddd {
				_adcb := _dd.Sprintf("\u0066\u006f\u006ft\u0065\u0072\u0025\u0064\u002e\u0078\u006d\u006c", (_dgeec.Index() + 1))
				if _adcb == _beba {
					_accd := _dd.Sprintf("\u0066\u006f\u006ft\u0065\u0072\u0025\u0064\u002e\u0078\u006d\u006c", _dgeec.Index())
					_eacd._bcf = append(_eacd._bcf, _dgeec.X())
					_cecf := _eacd._afff.AddRelationship(_accd, _e.FooterType)
					_cecf.SetID(_bcef)
					_eacd.ContentTypes.AddOverride("\u002f\u0077\u006f\u0072\u0064\u002f"+_accd, "\u0061p\u0070l\u0069\u0063\u0061\u0074\u0069\u006f\u006e\u002f\u0076\u006e\u0064.\u006f\u0070\u0065\u006ex\u006d\u006c\u0066\u006f\u0072m\u0061\u0074\u0073\u002d\u006f\u0066\u0066\u0069\u0063\u0065\u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u002e\u0077\u006f\u0072\u0064\u0070\u0072\u006f\u0063\u0065\u0073\u0073\u0069n\u0067\u006d\u006c\u002e\u0066\u006f\u006f\u0074e\u0072\u002b\u0078\u006d\u006c")
					_eacd._fce = append(_eacd._fce, _ee.NewRelationships())
					_affb := _dgeec.Paragraphs()
					for _, _dced := range _affb {
						for _, _dcaaa := range _dced.Runs() {
							_ccdg := _dcaaa.DrawingAnchored()
							for _, _babbb := range _ccdg {
								if _ebfga, _abda := _babbb.GetImage(); _abda {
									_gfedb = map[int]_ee.ImageRef{_dgeec.Index(): _ebfga}
								}
							}
							_ccae := _dcaaa.DrawingInline()
							for _, _dac := range _ccae {
								if _bbad, _aaca := _dac.GetImage(); _aaca {
									_gfedb = map[int]_ee.ImageRef{_dgeec.Index(): _bbad}
								}
							}
						}
					}
				}
			}
		}
		for _eecb, _fgf := range _gfedb {
			for _, _dadg := range _eacd.Footers() {
				if (_dadg.Index() + 1) == _eecb {
					_gfge, _ecba := _ee.ImageFromFile(_fgf.Path())
					if _ecba != nil {
						_gd.Log.Debug("\u0075\u006e\u0061\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0063r\u0065\u0061\u0074\u0065\u0020\u0069\u006d\u0061\u0067\u0065:\u0020\u0025\u0073", _ecba)
					}
					if _, _ecba = _dadg.AddImage(_gfge); _ecba != nil {
						_gd.Log.Debug("u\u006e\u0061\u0062\u006c\u0065\u0020t\u006f\u0020\u0061\u0064\u0064\u0020i\u006d\u0061\u0067\u0065\u0020\u0074\u006f \u0064\u006f\u0063\u0075\u006d\u0065\u006e\u0074\u003a\u0020%\u0073", _ecba)
					}
				}
				for _, _aebe := range _dadg.Paragraphs() {
					if _bfag, _bgeed := _ggb._bbbea.Styles.SearchStyleById(_aebe.Style()); _bgeed {
						if _, _ddff := _eacd.Styles.SearchStyleById(_aebe.Style()); !_ddff {
							_eacd.Styles.InsertStyle(_bfag)
						}
					}
				}
			}
		}
	}
	_dfdf := _ceg.Numbering()
	_eacd.Numbering._gcfa.AbstractNum = append(_eacd.Numbering._gcfa.AbstractNum, _dfdf._gcfa.AbstractNum...)
	_eacd.Numbering._gcfa.Num = append(_eacd.Numbering._gcfa.Num, _dfdf._gcfa.Num...)
	return Paragraph{_eacd, _ceg.X()}
}

// Footer is a footer for a document section.
type Footer struct {
	_abba *Document
	_aabd *_deg.Ftr
}

// Bookmarks returns all the bookmarks defined in the document.
func (_dace Document) Bookmarks() []Bookmark {
	if _dace._effc.Body == nil {
		return nil
	}
	_ddeg := []Bookmark{}
	for _, _gefc := range _dace._effc.Body.EG_BlockLevelElts {
		for _, _gcdc := range _gefc.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _, _aceg := range _cfdc(_gcdc) {
				_ddeg = append(_ddeg, _aceg)
			}
		}
	}
	return _ddeg
}

// SetFooter sets a section footer.
func (_ddcbc Section) SetFooter(f Footer, t _deg.ST_HdrFtr) {
	_fecfa := _deg.NewEG_HdrFtrReferences()
	_ddcbc._eegag.EG_HdrFtrReferences = append(_ddcbc._eegag.EG_HdrFtrReferences, _fecfa)
	_fecfa.HdrFtrReferencesChoice.FooterReference = _deg.NewCT_HdrFtrRef()
	_fecfa.HdrFtrReferencesChoice.FooterReference.TypeAttr = t
	_bface := _ddcbc._bbbea._afff.FindRIDForN(f.Index(), _e.FooterType)
	if _bface == "" {
		_gd.Log.Debug("\u0075\u006ea\u0062\u006c\u0065\u0020\u0074\u006f\u0020\u0064\u0065\u0074\u0065\u0072\u006d\u0069\u006e\u0065\u0020\u0066\u006f\u006f\u0074\u0065r \u0049\u0044")
	}
	_fecfa.HdrFtrReferencesChoice.FooterReference.IdAttr = _bface
}

// GetDocRelTargetByID returns TargetAttr of document relationship given its IdAttr.
func (_dfad *Document) GetDocRelTargetByID(idAttr string) string {
	for _, _ddbf := range _dfad._afff.X().Relationship {
		if _ddbf.IdAttr == idAttr {
			return _ddbf.TargetAttr
		}
	}
	return ""
}

// SetTblHeader set row properties for repeat table row on every new page value.
func (_edbc RowProperties) SetTblHeader(val bool) {
	if !val {
		_edbc._ebdgc.TrPrBaseChoice = nil
	} else {
		_edbc._ebdgc.TrPrBaseChoice = []*_deg.CT_TrPrBaseChoice{&_deg.CT_TrPrBaseChoice{TblHeader: _deg.NewCT_OnOff()}}
	}
}

// AddParagraph adds a paragraph to the comment.
func (_dge Comment) AddParagraph() Paragraph {
	_fdc := _deg.NewEG_ContentBlockContent()
	_dge._bfbc.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent = append(_dge._bfbc.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent, _fdc)
	_dde := _deg.NewCT_P()
	_fdc.ContentBlockContentChoice.P = append(_fdc.ContentBlockContentChoice.P, _dde)
	_cgg := Paragraph{_dge._gfae, _dde}
	_cgg._bbff.PPr = _deg.NewCT_PPr()
	_cgg._bbff.PPr.RPr = _deg.NewCT_ParaRPr()
	return _cgg
}

// SetBefore sets the spacing that comes before the paragraph.
func (_affee ParagraphSpacing) SetBefore(before _cdg.Distance) {
	_affee._gdfc.BeforeAttr = &_fae.ST_TwipsMeasure{}
	_affee._gdfc.BeforeAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(before / _cdg.Twips))
}
func _bgbagb() *_dc.Path {
	_cgdgg := _dc.NewPath()
	_cgdgg.ExtrusionokAttr = _fae.ST_TrueFalseTrue
	_cgdgg.GradientshapeokAttr = _fae.ST_TrueFalseTrue
	_cgdgg.ConnecttypeAttr = _dc.OfcST_ConnectTypeRect
	return _cgdgg
}

// Caps returns true if paragraph font is capitalized.
func (_ffaaa ParagraphProperties) Caps() bool { return _dabbe(_ffaaa._adegb.RPr.Caps) }

// ClearContent clears any content in the run (text, tabs, breaks, etc.)
func (_aggd Run) ClearContent() { _aggd._gabc.EG_RunInnerContent = nil }

const (
	FormFieldTypeUnknown FormFieldType = iota
	FormFieldTypeText
	FormFieldTypeCheckBox
	FormFieldTypeDropDown
)

func _eaaf(_ccfca *Document) map[int64]map[int64]int64 {
	_geddf := _ccfca.Paragraphs()
	_abcfd := make(map[int64]map[int64]int64, 0)
	for _, _aedf := range _geddf {
		_dcfbf := _fgfbb(_ccfca, _aedf)
		if _dcfbf.NumberingLevel != nil && _dcfbf.AbstractNumId != nil {
			_gbfad := *_dcfbf.AbstractNumId
			if _, _aegc := _abcfd[_gbfad]; _aegc {
				if _afde := _dcfbf.NumberingLevel.X(); _afde != nil {
					if _, _beaea := _abcfd[_gbfad][_afde.IlvlAttr]; _beaea {
						_abcfd[_gbfad][_afde.IlvlAttr]++
					} else {
						_abcfd[_gbfad][_afde.IlvlAttr] = 1
					}
				}
			} else {
				if _ecac := _dcfbf.NumberingLevel.X(); _ecac != nil {
					_abcfd[_gbfad] = map[int64]int64{_ecac.IlvlAttr: 1}
				}
			}
		}
	}
	return _abcfd
}

// SetBeforeAuto controls if spacing before a paragraph is automatically determined.
func (_bdcab ParagraphSpacing) SetBeforeAuto(b bool) {
	if b {
		_bdcab._gdfc.BeforeAutospacingAttr = &_fae.ST_OnOff{}
		_bdcab._gdfc.BeforeAutospacingAttr.Bool = _e.Bool(true)
	} else {
		_bdcab._gdfc.BeforeAutospacingAttr = nil
	}
}

// AddAnnotationReference adds annotation reference to a run.
func (_ebff Run) AddAnnotationReference() {
	_fggcg := _ebff.newIC()
	_fggcg.RunInnerContentChoice.AnnotationRef = _deg.NewCT_Empty()
}

// FormFieldType is the type of the form field.
//
//go:generate stringer -type=FormFieldType
type FormFieldType byte

// ClearColor clears the text color.
func (_fdcb RunProperties) ClearColor() { _fdcb._bfed.Color = nil }

// X returns the inner wrapped XML type.
func (_eadd InlineDrawing) X() *_deg.WdInline { return _eadd._bfcfc }

// Paragraphs returns all the paragraphs in the document body including tables.
func (_cgfg *Document) Paragraphs() []Paragraph {
	_cffe := []Paragraph{}
	if _cgfg._effc.Body == nil {
		return nil
	}
	for _, _cafb := range _cgfg._effc.Body.EG_BlockLevelElts {
		for _, _cdfc := range _cafb.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _, _defg := range _cdfc.ContentBlockContentChoice.P {
				_cffe = append(_cffe, Paragraph{_cgfg, _defg})
			}
		}
	}
	for _, _ddadd := range _cgfg.Tables() {
		for _, _dea := range _ddadd.Rows() {
			for _, _aaaa := range _dea.Cells() {
				_cffe = append(_cffe, _aaaa.Paragraphs()...)
			}
		}
	}
	return _cffe
}

// Font returns the name of paragraph font family.
func (_dcgfb ParagraphProperties) Font() string {
	if _bfcdd := _dcgfb._adegb.RPr.RFonts; _bfcdd != nil {
		if _bfcdd.AsciiAttr != nil {
			return *_bfcdd.AsciiAttr
		} else if _bfcdd.HAnsiAttr != nil {
			return *_bfcdd.HAnsiAttr
		} else if _bfcdd.CsAttr != nil {
			return *_bfcdd.CsAttr
		}
	}
	return ""
}

// SetFirstLineIndent controls the first line indent of the paragraph.
func (_dfae ParagraphStyleProperties) SetFirstLineIndent(m _cdg.Distance) {
	if _dfae._dgebc.Ind == nil {
		_dfae._dgebc.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_dfae._dgebc.Ind.FirstLineAttr = nil
	} else {
		_dfae._dgebc.Ind.FirstLineAttr = &_fae.ST_TwipsMeasure{}
		_dfae._dgebc.Ind.FirstLineAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _cdg.Twips))
	}
}

// CharacterSpacingMeasure returns paragraph characters spacing with its measure which can be mm, cm, in, pt, pc or pi.
func (_efcg ParagraphProperties) CharacterSpacingMeasure() string {
	if _eccgg := _efcg._adegb.RPr.Spacing; _eccgg != nil {
		_dbddd := _eccgg.ValAttr
		if _dbddd.ST_UniversalMeasure != nil {
			return *_dbddd.ST_UniversalMeasure
		}
	}
	return ""
}

// Footnote is an individual footnote reference within the document.
type Footnote struct {
	_dagad *Document
	_cfca  *_deg.CT_FtnEdn
}

func (_abgb Run) parseHTMLTag(_ddfae string) string {
	_bagdb := _d.NewDecoder(_ag.NewReader([]byte(_ddfae)))
	_ccegf := ""
	_ceec := []_d.StartElement{}
	for {
		_gdgcg, _cdfd := _bagdb.Token()
		if _cdfd != nil {
			break
		}
		switch _agbc := _gdgcg.(type) {
		case _d.StartElement:
			_ceec = append(_ceec, _agbc)
		case _d.EndElement:
			if _ceec[len(_ceec)-1].Name.Local == _agbc.Name.Local {
				_fdagd := _ceec[len(_ceec)-1]
				_ceec = _ceec[:len(_ceec)-1]
				switch _agbc.Name.Local {
				case "\u0062", "\u0073\u0074\u0072\u006f\u006e\u0067":
					_abgb.Properties().SetBold(true)
				case "\u0069", "\u0065\u006d":
					_abgb.Properties().SetItalic(true)
				case "\u0075":
					_addf := _bg.Black
					for _, _feaef := range _fdagd.Attr {
						if _feaef.Name.Local == "\u0063\u006f\u006co\u0072" {
							if _fcga, _acdf := _bg.ColorMap[_feaef.Value]; _acdf {
								_addf = _fcga
							}
						}
					}
					_abgb.Properties().SetUnderline(_deg.ST_UnderlineSingle, _addf)
				case "\u0073\u0074\u0072\u0069\u006b\u0065":
					_abgb.Properties().SetStrikeThrough(true)
				case "\u006d\u0061\u0072\u006b":
					_aaba := _deg.ST_HighlightColorYellow
					for _, _gafda := range _fdagd.Attr {
						if _gafda.Name.Local == "\u0063\u006f\u006co\u0072" {
							if _cbcc, _acac := _bg.HighlightColorMap[_gafda.Value]; _acac {
								_aaba = _cbcc
							}
						}
					}
					_abgb.Properties().SetHighlight(_aaba)
				case "\u0073\u0075\u0062":
					_abgb.Properties().SetVerticalAlignment(_fae.ST_VerticalAlignRunSubscript)
				case "\u0073\u0075\u0070":
					_abgb.Properties().SetVerticalAlignment(_fae.ST_VerticalAlignRunSuperscript)
				}
			}
		case _d.CharData:
			_ccegf += string(_agbc)
		}
	}
	return _ccegf
}

// SetVerticalAlignment controls the vertical alignment of the run, this is used
// to control if text is superscript/subscript.
func (_fadcbf RunProperties) SetVerticalAlignment(v _fae.ST_VerticalAlignRun) {
	if v == _fae.ST_VerticalAlignRunUnset {
		_fadcbf._bfed.VertAlign = nil
	} else {
		_fadcbf._bfed.VertAlign = _deg.NewCT_VerticalAlignRun()
		_fadcbf._bfed.VertAlign.ValAttr = v
	}
}

// ReplaceText replace the text inside node.
func (_acec *Node) ReplaceText(oldText, newText string) {
	switch _efdgb := _acec.X().(type) {
	case *Paragraph:
		for _, _efec := range _efdgb.Runs() {
			for _, _dfgbb := range _efec._gabc.EG_RunInnerContent {
				if _dfgbb.RunInnerContentChoice.T != nil {
					_cbad := _dfgbb.RunInnerContentChoice.T.Content
					_cbad = _ac.ReplaceAll(_cbad, oldText, newText)
					_dfgbb.RunInnerContentChoice.T.Content = _cbad
				}
			}
		}
	}
	for _, _bbde := range _acec.Children {
		_bbde.ReplaceText(oldText, newText)
	}
}

// AddHyperLink adds a new hyperlink to a parapgraph.
func (_befa Paragraph) AddHyperLink() HyperLink {
	_cbfbe := _deg.NewEG_PContent()
	_befa._bbff.EG_PContent = append(_befa._bbff.EG_PContent, _cbfbe)
	_cbfbe.PContentChoice.Hyperlink = _deg.NewCT_Hyperlink()
	return HyperLink{_befa._eaefb, _cbfbe.PContentChoice.Hyperlink}
}

// Levels returns all of the numbering levels defined in the definition.
func (_caa NumberingDefinition) Levels() []NumberingLevel {
	_gbda := []NumberingLevel{}
	for _, _caed := range _caa._feab.Lvl {
		_gbda = append(_gbda, NumberingLevel{_caed})
	}
	return _gbda
}

// AddSection adds a new document section with an optional section break.  If t
// is ST_SectionMarkUnset, then no break will be inserted.
func (_eeea ParagraphProperties) AddSection(t _deg.ST_SectionMark) Section {
	_eeea._adegb.SectPr = _deg.NewCT_SectPr()
	if t != _deg.ST_SectionMarkUnset {
		_eeea._adegb.SectPr.Type = _deg.NewCT_SectType()
		_eeea._adegb.SectPr.Type.ValAttr = t
	}
	return Section{_eeea._agcfge, _eeea._adegb.SectPr}
}

// SetSize sets the size of the displayed image on the page.
func (_dce AnchoredDrawing) SetSize(w, h _cdg.Distance) {
	_dce._bgc.Extent.CxAttr = int64(float64(w*_cdg.Pixel72) / _cdg.EMU)
	_dce._bgc.Extent.CyAttr = int64(float64(h*_cdg.Pixel72) / _cdg.EMU)
}

// SetRight sets the right border to a specified type, color and thickness.
func (_edddg TableBorders) SetRight(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_edddg._cadbb.Right = _deg.NewCT_Border()
	_bgdcd(_edddg._cadbb.Right, t, c, thickness)
}

// AddDropdownList adds dropdown list form field to the paragraph and returns it.
func (_bdcce Paragraph) AddDropdownList(name string) FormField {
	_ddffg := _bdcce.addFldCharsForField(name, "\u0046\u004f\u0052M\u0044\u0052\u004f\u0050\u0044\u004f\u0057\u004e")
	_ddffg._bgcg.FFDataChoice[0].DdList = _deg.NewCT_FFDDList()
	return _ddffg
}

// GetStyleByID returns Style by it is IdAttr.
func (_bfgac *Document) GetStyleByID(id string) Style {
	for _, _dfbcc := range _bfgac.Styles._cegfc.Style {
		if _dfbcc.StyleIdAttr != nil && *_dfbcc.StyleIdAttr == id {
			return Style{_dfbcc}
		}
	}
	return Style{}
}

// Clear resets the numbering.
func (_geea Numbering) Clear() {
	_geea._gcfa.AbstractNum = nil
	_geea._gcfa.Num = nil
	_geea._gcfa.NumIdMacAtCleanup = nil
	_geea._gcfa.NumPicBullet = nil
}

// SetOffset sets the offset of the image relative to the origin, which by
// default this is the top-left corner of the page. Offset is incompatible with
// SetAlignment, whichever is called last is applied.
func (_ae AnchoredDrawing) SetOffset(x, y _cdg.Distance) { _ae.SetXOffset(x); _ae.SetYOffset(y) }

// SetUnhideWhenUsed controls if a semi hidden style becomes visible when used.
func (_gbebc Style) SetUnhideWhenUsed(b bool) {
	if b {
		_gbebc._bageg.UnhideWhenUsed = _deg.NewCT_OnOff()
	} else {
		_gbebc._bageg.UnhideWhenUsed = nil
	}
}

// SetColor sets the text color.
func (_fgdfg RunProperties) SetColor(c _bg.Color) {
	_fgdfg._bfed.Color = _deg.NewCT_Color()
	_fgdfg._bfed.Color.ValAttr.ST_HexColorRGB = c.AsRGBString()
}

// SetContextualSpacing controls whether to Ignore Spacing Above and Below When
// Using Identical Styles
func (_dade ParagraphStyleProperties) SetContextualSpacing(b bool) {
	if !b {
		_dade._dgebc.ContextualSpacing = nil
	} else {
		_dade._dgebc.ContextualSpacing = _deg.NewCT_OnOff()
	}
}

// SetOuterShadowImageEffect sets the outer shadow image effect.
func (_ede AnchoredDrawing) SetOuterShadowImageEffect(radius, offset _cdg.Distance, c _bg.Color, degrees float64) {
	_ge := _cdg.ToEMU(float64(radius))
	_ecc := _cdg.ToEMU(float64(offset))
	_ba := int32(degrees * 60000)
	for _, _gbc := range _ede._bgc.Graphic.GraphicData.Any {
		if _fbb, _fag := _gbc.(*_gg.Pic); _fag {
			_ede.initializeEffectList(_fbb.SpPr)
			_fbb.SpPr.EffectPropertiesChoice.EffectLst.OuterShdw = _ad.NewCT_OuterShadowEffect()
			_fbb.SpPr.EffectPropertiesChoice.EffectLst.OuterShdw.BlurRadAttr = &_ge
			_fbb.SpPr.EffectPropertiesChoice.EffectLst.OuterShdw.DistAttr = &_ecc
			_fbb.SpPr.EffectPropertiesChoice.EffectLst.OuterShdw.DirAttr = &_ba
			_fbb.SpPr.EffectPropertiesChoice.EffectLst.OuterShdw.SrgbClr = _ad.NewCT_SRgbColor()
			_fbb.SpPr.EffectPropertiesChoice.EffectLst.OuterShdw.SrgbClr.ValAttr = *c.AsRGBString()
			_fbb.SpPr.EffectPropertiesChoice.EffectLst.OuterShdw.AlgnAttr = _ad.ST_RectAlignmentBl
			_faea := false
			_fbb.SpPr.EffectPropertiesChoice.EffectLst.OuterShdw.RotWithShapeAttr = &_faea
		}
	}
	_ede.setEffectExtent(_ge, _ge, _ge, _ge)
}
func _debd() *_dc.Formulas {
	_bcagg := _dc.NewFormulas()
	_bcagg.F = []*_dc.CT_F{_bgg.CreateFormula("\u0073\u0075\u006d\u0020\u0023\u0030\u0020\u0030\u00201\u0030\u0038\u0030\u0030"), _bgg.CreateFormula("p\u0072\u006f\u0064\u0020\u0023\u0030\u0020\u0032\u0020\u0031"), _bgg.CreateFormula("\u0073\u0075\u006d\u0020\u0032\u0031\u0036\u0030\u0030 \u0030\u0020\u0040\u0031"), _bgg.CreateFormula("\u0073\u0075\u006d\u0020\u0030\u0020\u0030\u0020\u0040\u0032"), _bgg.CreateFormula("\u0073\u0075\u006d\u0020\u0032\u0031\u0036\u0030\u0030 \u0030\u0020\u0040\u0033"), _bgg.CreateFormula("\u0069\u0066\u0020\u0040\u0030\u0020\u0040\u0033\u0020\u0030"), _bgg.CreateFormula("\u0069\u0066\u0020\u0040\u0030\u0020\u0032\u0031\u00360\u0030\u0020\u0040\u0031"), _bgg.CreateFormula("\u0069\u0066\u0020\u0040\u0030\u0020\u0030\u0020\u0040\u0032"), _bgg.CreateFormula("\u0069\u0066\u0020\u0040\u0030\u0020\u0040\u0034\u00202\u0031\u0036\u0030\u0030"), _bgg.CreateFormula("\u006di\u0064\u0020\u0040\u0035\u0020\u00406"), _bgg.CreateFormula("\u006di\u0064\u0020\u0040\u0038\u0020\u00405"), _bgg.CreateFormula("\u006di\u0064\u0020\u0040\u0037\u0020\u00408"), _bgg.CreateFormula("\u006di\u0064\u0020\u0040\u0036\u0020\u00407"), _bgg.CreateFormula("s\u0075\u006d\u0020\u0040\u0036\u0020\u0030\u0020\u0040\u0035")}
	return _bcagg
}

// SetConformance sets conformance attribute of the document
// as one of these values from github.com/unidoc/unioffice/schema/soo/ofc/sharedTypes:
// ST_ConformanceClassUnset, ST_ConformanceClassStrict or ST_ConformanceClassTransitional.
func (_geeee Document) SetConformance(conformanceAttr _fae.ST_ConformanceClass) {
	_geeee._effc.ConformanceAttr = conformanceAttr
}
func _eafbd(_aea *_deg.CT_P, _dcbe, _fcce map[int64]int64) {
	for _, _dabae := range _aea.EG_PContent {
		for _, _gafgc := range _dabae.PContentChoice.EG_ContentRunContent {
			if _gafgc.ContentRunContentChoice.R != nil {
				for _, _fafg := range _gafgc.ContentRunContentChoice.R.EG_RunInnerContent {
					_abdd := _fafg.RunInnerContentChoice.EndnoteReference
					if _abdd != nil && _abdd.IdAttr > 0 {
						if _eeaf, _cadg := _fcce[_abdd.IdAttr]; _cadg {
							_abdd.IdAttr = _eeaf
						}
					}
					_fccf := _fafg.RunInnerContentChoice.FootnoteReference
					if _fccf != nil && _fccf.IdAttr > 0 {
						if _cbff, _dfca := _dcbe[_fccf.IdAttr]; _dfca {
							_fccf.IdAttr = _cbff
						}
					}
				}
			}
		}
	}
}

// Margins allows controlling individual cell margins.
func (_gce CellProperties) Margins() CellMargins {
	if _gce._cbb.TcMar == nil {
		_gce._cbb.TcMar = _deg.NewCT_TcMar()
	}
	return CellMargins{_gce._cbb.TcMar}
}

// SetBottom sets the bottom border to a specified type, color and thickness.
func (_befgb TableBorders) SetBottom(t _deg.ST_Border, c _bg.Color, thickness _cdg.Distance) {
	_befgb._cadbb.Bottom = _deg.NewCT_Border()
	_bgdcd(_befgb._cadbb.Bottom, t, c, thickness)
}
func (_beaec Styles) initializeDocDefaults() {
	_beaec._cegfc.DocDefaults = _deg.NewCT_DocDefaults()
	_beaec._cegfc.DocDefaults.RPrDefault = _deg.NewCT_RPrDefault()
	_beaec._cegfc.DocDefaults.RPrDefault.RPr = _deg.NewCT_RPr()
	_dafbc := RunProperties{_beaec._cegfc.DocDefaults.RPrDefault.RPr}
	_dafbc.SetSize(12 * _cdg.Point)
	_dafbc.Fonts().SetASCIITheme(_deg.ST_ThemeMajorAscii)
	_dafbc.Fonts().SetEastAsiaTheme(_deg.ST_ThemeMajorEastAsia)
	_dafbc.Fonts().SetHANSITheme(_deg.ST_ThemeMajorHAnsi)
	_dafbc.Fonts().SetCSTheme(_deg.ST_ThemeMajorBidi)
	_dafbc.X().Lang = _deg.NewCT_Language()
	_dafbc.X().Lang.ValAttr = _e.String("\u0065\u006e\u002dU\u0053")
	_dafbc.X().Lang.EastAsiaAttr = _e.String("\u0065\u006e\u002dU\u0053")
	_dafbc.X().Lang.BidiAttr = _e.String("\u0061\u0072\u002dS\u0041")
	_beaec._cegfc.DocDefaults.PPrDefault = _deg.NewCT_PPrDefault()
}

// AddParagraph adds a new paragraph to the document body.
func (_feb *Document) AddParagraph() Paragraph {
	_bgagg := _deg.NewEG_BlockLevelElts()
	_feb._effc.Body.EG_BlockLevelElts = append(_feb._effc.Body.EG_BlockLevelElts, _bgagg)
	_cdc := _deg.NewEG_ContentBlockContent()
	_bgagg.BlockLevelEltsChoice.EG_ContentBlockContent = append(_bgagg.BlockLevelEltsChoice.EG_ContentBlockContent, _cdc)
	_cgcb := _deg.NewCT_P()
	_cdc.ContentBlockContentChoice.P = append(_cdc.ContentBlockContentChoice.P, _cgcb)
	return Paragraph{_feb, _cgcb}
}

// Shadow returns true if run shadow is on.
func (_acae RunProperties) Shadow() bool { return _dabbe(_acae._bfed.Shadow) }

// ReplaceTextByRegexp replace the text within node using regexp expression.
func (_cdfeg *Node) ReplaceTextByRegexp(rgx *_be.Regexp, newText string) {
	switch _dede := _cdfeg.X().(type) {
	case *Paragraph:
		for _, _aebcg := range _dede.Runs() {
			for _, _ddgb := range _aebcg._gabc.EG_RunInnerContent {
				if _ddgb.RunInnerContentChoice.T != nil {
					_gbbd := _ddgb.RunInnerContentChoice.T.Content
					_gbbd = rgx.ReplaceAllString(_gbbd, newText)
					_ddgb.RunInnerContentChoice.T.Content = _gbbd
				}
			}
		}
	}
	for _, _acdge := range _cdfeg.Children {
		_acdge.ReplaceTextByRegexp(rgx, newText)
	}
}

// SetRightToLeft sets the run text goes from right to left.
func (_dcaac RunProperties) SetRightToLeft(b bool) {
	if !b {
		_dcaac._bfed.Rtl = nil
	} else {
		_dcaac._bfed.Rtl = _deg.NewCT_OnOff()
	}
}

// Properties returns the table properties.
func (_ggca Table) Properties() TableProperties {
	if _ggca._abbae.TblPr == nil {
		_ggca._abbae.TblPr = _deg.NewCT_TblPr()
	}
	return TableProperties{_ggca._abbae.TblPr}
}

// SetTextWrapTopAndBottom sets the text wrap to top and bottom.
func (_aaf AnchoredDrawing) SetTextWrapTopAndBottom() {
	_aaf._bgc.WrapTypeChoice = &_deg.WdEG_WrapTypeChoice{}
	_aaf._bgc.WrapTypeChoice.WrapTopAndBottom = _deg.NewWdCT_WrapTopBottom()
	_aaf._bgc.LayoutInCellAttr = true
	_aaf._bgc.AllowOverlapAttr = true
}

// SetText sets the text to be used in bullet mode.
func (_ccfcb NumberingLevel) SetText(t string) {
	if t == "" {
		_ccfcb._cdgg.LvlText = nil
	} else {
		_ccfcb._cdgg.LvlText = _deg.NewCT_LevelText()
		_ccfcb._cdgg.LvlText.ValAttr = _e.String(t)
	}
}

// SetHangingIndent controls the hanging indent of the paragraph.
func (_bfcec ParagraphStyleProperties) SetHangingIndent(m _cdg.Distance) {
	if _bfcec._dgebc.Ind == nil {
		_bfcec._dgebc.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_bfcec._dgebc.Ind.HangingAttr = nil
	} else {
		_bfcec._dgebc.Ind.HangingAttr = &_fae.ST_TwipsMeasure{}
		_bfcec._dgebc.Ind.HangingAttr.ST_UnsignedDecimalNumber = _e.Uint64(uint64(m / _cdg.Twips))
	}
}

// SetStart sets the cell start margin
func (_dffg CellMargins) SetStart(d _cdg.Distance) {
	_dffg._fee.Start = _deg.NewCT_TblWidth()
	_gecb(_dffg._fee.Start, d)
}

// RemoveMailMerge removes any mail merge settings
func (_acbea Settings) RemoveMailMerge() { _acbea._bbaeb.MailMerge = nil }

// GetFooter gets a section Footer for given type
func (_gegcf Section) GetFooter(t _deg.ST_HdrFtr) (Footer, bool) {
	for _, _edfcf := range _gegcf._eegag.EG_HdrFtrReferences {
		if _edfcf.HdrFtrReferencesChoice.FooterReference == nil {
			continue
		}
		if _edfcf.HdrFtrReferencesChoice.FooterReference.TypeAttr == t {
			for _, _bgged := range _gegcf._bbbea.Footers() {
				_afdd := _gegcf._bbbea._afff.FindRIDForN(_bgged.Index(), _e.FooterType)
				if _afdd == _edfcf.HdrFtrReferencesChoice.FooterReference.IdAttr {
					return _bgged, true
				}
			}
		}
	}
	return Footer{}, false
}

// Comment is run's comment component.
type Comment struct {
	_gfae *Document
	_bfbc *_deg.CT_Comment
}

// EastAsiaFont returns the name of run font family for East Asia.
func (_bacf RunProperties) EastAsiaFont() string {
	if _cdgfc := _bacf._bfed.RFonts; _cdgfc != nil {
		if _cdgfc.EastAsiaAttr != nil {
			return *_cdgfc.EastAsiaAttr
		}
	}
	return ""
}

// SetCSTheme sets the font complex script theme.
func (_cebfg Fonts) SetCSTheme(t _deg.ST_Theme) { _cebfg._gddaa.CsthemeAttr = t }

// SetFontFamily sets the Ascii & HAnsi fonly family for a run.
func (_eaae RunProperties) SetFontFamily(family string) {
	if _eaae._bfed.RFonts == nil {
		_eaae._bfed.RFonts = _deg.NewCT_Fonts()
	}
	_eaae._bfed.RFonts.AsciiAttr = _e.String(family)
	_eaae._bfed.RFonts.HAnsiAttr = _e.String(family)
	_eaae._bfed.RFonts.EastAsiaAttr = _e.String(family)
}

// Nodes contains slice of Node element.
type Nodes struct{ _aebcgc []Node }

func (_fbe *Document) validateTableCells() error {
	for _, _geae := range _fbe._effc.Body.EG_BlockLevelElts {
		for _, _aadg := range _geae.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _, _dcfe := range _aadg.ContentBlockContentChoice.Tbl {
				for _, _abge := range _dcfe.EG_ContentRowContent {
					for _, _bage := range _abge.ContentRowContentChoice.Tr {
						_cge := false
						for _, _bfdg := range _bage.EG_ContentCellContent {
							_ddgc := false
							for _, _acab := range _bfdg.ContentCellContentChoice.Tc {
								_cge = true
								for _, _bgcd := range _acab.EG_BlockLevelElts {
									for _, _abf := range _bgcd.BlockLevelEltsChoice.EG_ContentBlockContent {
										if len(_abf.ContentBlockContentChoice.P) > 0 {
											_ddgc = true
											break
										}
									}
								}
							}
							if !_ddgc {
								return _bea.New("t\u0061\u0062\u006c\u0065\u0020\u0063e\u006c\u006c\u0020\u006d\u0075\u0073t\u0020\u0063\u006f\u006e\u0074\u0061\u0069n\u0020\u0061\u0020\u0070\u0061\u0072\u0061\u0067\u0072\u0061p\u0068")
							}
						}
						if !_cge {
							return _bea.New("\u0074\u0061b\u006c\u0065\u0020\u0072\u006f\u0077\u0020\u006d\u0075\u0073\u0074\u0020\u0063\u006f\u006e\u0074\u0061\u0069\u006e\u0020\u0061\u0020ce\u006c\u006c")
						}
					}
				}
			}
		}
	}
	return nil
}

// SetRowBandSize sets the number of Rows in the row band
func (_fdbcf TableStyleProperties) SetRowBandSize(rows int64) {
	_fdbcf._daffa.TblStyleRowBandSize = _deg.NewCT_DecimalNumber()
	_fdbcf._daffa.TblStyleRowBandSize.ValAttr = rows
}

// NewWatermarkPicture generates new WatermarkPicture.
func NewWatermarkPicture() WatermarkPicture {
	_fbabg := _dc.NewShapetype()
	_egbbb := _gccec()
	_cecab := _bgbagb()
	_dfdbc := _efegf()
	_fbabg.EG_ShapeElements = []*_dc.EG_ShapeElements{{ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Formulas: _egbbb}}, {ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Path: _cecab}}, {ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Lock: _dfdbc}}}
	var (
		_fddfbb = "\u005f\u0078\u0030\u0030\u0030\u0030\u005f\u0074\u0037\u0035"
		_fdfcc  = "2\u0031\u0036\u0030\u0030\u002c\u0032\u0031\u0036\u0030\u0030"
		_cbga   = float32(75.0)
		_bedfd  = "\u006d\u0040\u0034\u00405l\u0040\u0034\u0040\u0031\u0031\u0040\u0039\u0040\u0031\u0031\u0040\u0039\u0040\u0035x\u0065"
	)
	_fbabg.IdAttr = &_fddfbb
	_fbabg.CoordsizeAttr = &_fdfcc
	_fbabg.SptAttr = &_cbga
	_fbabg.PreferrelativeAttr = _fae.ST_TrueFalseTrue
	_fbabg.PathAttr = &_bedfd
	_fbabg.FilledAttr = _fae.ST_TrueFalseFalse
	_fbabg.StrokedAttr = _fae.ST_TrueFalseFalse
	_bdebd := _dc.NewShape()
	_bdebd.ShapeChoice = []*_dc.CT_ShapeChoice{{ShapeElementsChoice: &_dc.EG_ShapeElementsChoice{Imagedata: _fgac()}}}
	var (
		_efede  = "\u0057\u006f\u0072\u0064\u0050\u0069\u0063\u0074\u0075\u0072e\u0057\u0061\u0074\u0065\u0072\u006d\u0061r\u006b\u0031\u0036\u0033\u0032\u0033\u0031\u0036\u0035\u0039\u0035"
		_gccb   = "\u005f\u0078\u00300\u0030\u0030\u005f\u0073\u0032\u0030\u0035\u0031"
		_cbeg   = "#\u005f\u0078\u0030\u0030\u0030\u0030\u005f\u0074\u0037\u0035"
		_cegebg = ""
		_bbffa  = "\u0070os\u0069t\u0069o\u006e\u003a\u0061\u0062\u0073\u006fl\u0075\u0074\u0065\u003bm\u0061\u0072\u0067\u0069\u006e\u002d\u006c\u0065\u0066\u0074\u003a\u0030\u003bma\u0072\u0067\u0069\u006e\u002d\u0074\u006f\u0070\u003a\u0030\u003b\u0077\u0069\u0064\u0074\u0068\u003a\u0030\u0070\u0074;\u0068e\u0069\u0067\u0068\u0074\u003a\u0030\u0070\u0074\u003b\u007a\u002d\u0069\u006ed\u0065\u0078:\u002d\u0032\u00351\u0036\u0035\u0038\u0032\u0034\u0030\u003b\u006d\u0073o-\u0070\u006f\u0073i\u0074\u0069\u006f\u006e-\u0068\u006f\u0072\u0069\u007a\u006fn\u0074\u0061l\u003a\u0063\u0065\u006e\u0074\u0065\u0072\u003bm\u0073\u006f\u002d\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u002d\u0068\u006f\u0072\u0069\u007a\u006f\u006e\u0074\u0061\u006c\u002drela\u0074\u0069\u0076\u0065\u003a\u006d\u0061\u0072\u0067\u0069\u006e\u003b\u006d\u0073\u006f\u002d\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e\u002d\u0076\u0065\u0072t\u0069c\u0061l\u003a\u0063\u0065\u006e\u0074\u0065\u0072\u003b\u006d\u0073\u006f\u002d\u0070\u006f\u0073\u0069\u0074\u0069\u006f\u006e-\u0076\u0065r\u0074\u0069c\u0061l\u002d\u0072\u0065\u006c\u0061\u0074i\u0076\u0065\u003a\u006d\u0061\u0072\u0067\u0069\u006e"
	)
	_bdebd.IdAttr = &_efede
	_bdebd.SpidAttr = &_gccb
	_bdebd.TypeAttr = &_cbeg
	_bdebd.AltAttr = &_cegebg
	_bdebd.StyleAttr = &_bbffa
	_bdebd.AllowincellAttr = _fae.ST_TrueFalseFalse
	_aaagc := _deg.NewCT_Picture()
	_aaagc.Any = []_e.Any{_fbabg, _bdebd}
	return WatermarkPicture{_dbece: _aaagc, _bfadf: _bdebd, _dbeec: _fbabg}
}

// AddParagraph adds a paragraph to the table cell.
func (_ged Cell) AddParagraph() Paragraph {
	_afb := _deg.NewEG_BlockLevelElts()
	_ged._fdf.EG_BlockLevelElts = append(_ged._fdf.EG_BlockLevelElts, _afb)
	_dfd := _deg.NewEG_ContentBlockContent()
	_afb.BlockLevelEltsChoice.EG_ContentBlockContent = append(_afb.BlockLevelEltsChoice.EG_ContentBlockContent, _dfd)
	_daad := _deg.NewCT_P()
	_dfd.ContentBlockContentChoice.P = append(_dfd.ContentBlockContentChoice.P, _daad)
	return Paragraph{_ged._dff, _daad}
}

// X returns the inner wrapped XML type.
func (_dcecc ParagraphStyleProperties) X() *_deg.CT_PPrGeneral { return _dcecc._dgebc }

// Footnote returns the footnote based on the ID; this can be used nicely with
// the run.IsFootnote() functionality.
func (_adbf *Document) Footnote(id int64) Footnote {
	for _, _bfeb := range _adbf.Footnotes() {
		if _bfeb.id() == id {
			return _bfeb
		}
	}
	return Footnote{}
}
func (_aadgd Paragraph) addEndBookmark(_gdcfe int64) *_deg.CT_MarkupRange {
	_bccb := _deg.NewEG_PContent()
	_aadgd._bbff.EG_PContent = append(_aadgd._bbff.EG_PContent, _bccb)
	_eaeca := _deg.NewEG_ContentRunContent()
	_dggb := _deg.NewEG_RunLevelElts()
	_ffaebg := _deg.NewEG_RangeMarkupElements()
	_fafec := _deg.NewCT_MarkupRange()
	_fafec.IdAttr = _gdcfe
	_ffaebg.RangeMarkupElementsChoice.BookmarkEnd = _fafec
	_bccb.PContentChoice.EG_ContentRunContent = append(_bccb.PContentChoice.EG_ContentRunContent, _eaeca)
	_eaeca.ContentRunContentChoice.EG_RunLevelElts = append(_eaeca.ContentRunContentChoice.EG_RunLevelElts, _dggb)
	_dggb.RunLevelEltsChoice.EG_RangeMarkupElements = append(_dggb.RunLevelEltsChoice.EG_RangeMarkupElements, _ffaebg)
	return _fafec
}
func _fbf() (*_ad.CT_Point2D, []*_ad.CT_Point2D) {
	var (
		_gba int64 = 0
		_cdd int64 = 21600
	)
	_gca := _ad.ST_Coordinate{ST_CoordinateUnqualified: &_gba, ST_UniversalMeasure: nil}
	_bddf := _ad.ST_Coordinate{ST_CoordinateUnqualified: &_cdd, ST_UniversalMeasure: nil}
	_fcb := _ad.NewCT_Point2D()
	_fcb.XAttr = _gca
	_fcb.YAttr = _gca
	_ggf := []*_ad.CT_Point2D{&_ad.CT_Point2D{XAttr: _gca, YAttr: _bddf}, &_ad.CT_Point2D{XAttr: _bddf, YAttr: _bddf}, &_ad.CT_Point2D{XAttr: _bddf, YAttr: _gca}, _fcb}
	return _fcb, _ggf
}

// SetBehindDoc sets the behindDoc attribute of anchor.
func (_bde AnchoredDrawing) SetBehindDoc(val bool) { _bde._bgc.BehindDocAttr = val }

// CellBorders are the borders for an individual
type CellBorders struct{ _fba *_deg.CT_TcBorders }

// Numbering return numbering that being use by paragraph.
func (_ccdc Paragraph) Numbering() Numbering {
	_ccdc.ensurePPr()
	_fgee := NewNumbering()
	if _ccdc._bbff.PPr.NumPr != nil {
		_dfccd := int64(-1)
		_cged := int64(-1)
		if _ccdc._bbff.PPr.NumPr.NumId != nil {
			_dfccd = _ccdc._bbff.PPr.NumPr.NumId.ValAttr
		}
		for _, _eaec := range _ccdc._eaefb.Numbering._gcfa.Num {
			if _dfccd < 0 {
				break
			}
			if _eaec.NumIdAttr == _dfccd {
				if _eaec.AbstractNumId != nil {
					_cged = _eaec.AbstractNumId.ValAttr
					_fgee._gcfa.Num = append(_fgee._gcfa.Num, _eaec)
					break
				}
			}
		}
		for _, _gdde := range _ccdc._eaefb.Numbering._gcfa.AbstractNum {
			if _cged < 0 {
				break
			}
			if _gdde.AbstractNumIdAttr == _cged {
				_fgee._gcfa.AbstractNum = append(_fgee._gcfa.AbstractNum, _gdde)
				break
			}
		}
	}
	return _fgee
}

// SetThemeShade sets the shade based off the theme color.
func (_dbd Color) SetThemeShade(s uint8) {
	_abd := _dd.Sprintf("\u0025\u0030\u0032\u0078", s)
	_dbd._dbb.ThemeShadeAttr = &_abd
}

// SetEndIndent controls the end indentation.
func (_cafed ParagraphProperties) SetEndIndent(m _cdg.Distance) {
	if _cafed._adegb.Ind == nil {
		_cafed._adegb.Ind = _deg.NewCT_Ind()
	}
	if m == _cdg.Zero {
		_cafed._adegb.Ind.EndAttr = nil
	} else {
		_cafed._adegb.Ind.EndAttr = &_deg.ST_SignedTwipsMeasure{}
		_cafed._adegb.Ind.EndAttr.Int64 = _e.Int64(int64(m / _cdg.Twips))
	}
}

// Tables returns the tables defined in the footer.
func (_dcea Footer) Tables() []Table {
	_cfded := []Table{}
	if _dcea._aabd == nil {
		return nil
	}
	for _, _cddba := range _dcea._aabd.EG_BlockLevelElts {
		for _, _febd := range _cddba.BlockLevelEltsChoice.EG_ContentBlockContent {
			_cfded = append(_cfded, _dcea._abba.tables(_febd)...)
		}
	}
	return _cfded
}

// GetTargetByRelId returns a target path with the associated relation ID in the
// document.
func (_fbef *Document) GetTargetByRelId(idAttr string) string {
	return _fbef._afff.GetTargetByRelId(idAttr)
}

// AddDefinition adds a new numbering definition.
func (_eacbc Numbering) AddDefinition() NumberingDefinition {
	_dfed := _deg.NewCT_Num()
	_eedff := int64(1)
	for _, _dgfg := range _eacbc.Definitions() {
		if _dgfg.AbstractNumberID() >= _eedff {
			_eedff = _dgfg.AbstractNumberID() + 1
		}
	}
	_cgece := int64(1)
	for _, _eagga := range _eacbc.X().Num {
		if _eagga.NumIdAttr >= _cgece {
			_cgece = _eagga.NumIdAttr + 1
		}
	}
	_dfed.NumIdAttr = _cgece
	_dfed.AbstractNumId = _deg.NewCT_DecimalNumber()
	_dfed.AbstractNumId.ValAttr = _eedff
	_gddad := _deg.NewCT_AbstractNum()
	_gddad.AbstractNumIdAttr = _eedff
	_eacbc._gcfa.AbstractNum = append(_eacbc._gcfa.AbstractNum, _gddad)
	_eacbc._gcfa.Num = append(_eacbc._gcfa.Num, _dfed)
	return NumberingDefinition{_gddad}
}

// Name returns the name of the style if set.
func (_cggaf Style) Name() string {
	if _cggaf._bageg.Name == nil {
		return ""
	}
	return _cggaf._bageg.Name.ValAttr
}

// MergeFields returns the list of all mail merge fields found in the document.
func (_bfcg Document) MergeFields() []string {
	_cced := map[string]struct{}{}
	for _, _eceab := range _bfcg.mergeFields() {
		_cced[_eceab._bbdde] = struct{}{}
	}
	_gbed := []string{}
	for _ecbdc := range _cced {
		_gbed = append(_gbed, _ecbdc)
	}
	return _gbed
}

// RemoveParagraph removes a paragraph from the endnote.
func (_gcgg Endnote) RemoveParagraph(p Paragraph) {
	for _, _gacg := range _gcgg.content() {
		for _gbag, _eefcd := range _gacg.ContentBlockContentChoice.P {
			if _eefcd == p._bbff {
				copy(_gacg.ContentBlockContentChoice.P[_gbag:], _gacg.ContentBlockContentChoice.P[_gbag+1:])
				_gacg.ContentBlockContentChoice.P = _gacg.ContentBlockContentChoice.P[0 : len(_gacg.ContentBlockContentChoice.P)-1]
				return
			}
		}
	}
}
func (_ddebe Paragraph) addSeparateFldChar() *_deg.CT_FldChar {
	_baeba := _ddebe.addFldChar()
	_baeba.FldCharTypeAttr = _deg.ST_FldCharTypeSeparate
	return _baeba
}

// AddParagraph adds a paragraph to the endnote.
func (_bbaba Endnote) AddParagraph() Paragraph {
	_ecbga := _deg.NewEG_ContentBlockContent()
	_bafe := len(_bbaba._cfda.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent)
	_bbaba._cfda.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent = append(_bbaba._cfda.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent, _ecbga)
	_gafbg := _deg.NewCT_P()
	var _cfgbc *_deg.CT_String
	if _bafe != 0 {
		_efbcd := len(_bbaba._cfda.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent[_bafe-1].ContentBlockContentChoice.P)
		_cfgbc = _bbaba._cfda.EG_BlockLevelElts[0].BlockLevelEltsChoice.EG_ContentBlockContent[_bafe-1].ContentBlockContentChoice.P[_efbcd-1].PPr.PStyle
	} else {
		_cfgbc = _deg.NewCT_String()
		_cfgbc.ValAttr = "\u0045n\u0064\u006e\u006f\u0074\u0065"
	}
	_ecbga.ContentBlockContentChoice.P = append(_ecbga.ContentBlockContentChoice.P, _gafbg)
	_egfe := Paragraph{_bbaba._eecgf, _gafbg}
	_egfe._bbff.PPr = _deg.NewCT_PPr()
	_egfe._bbff.PPr.PStyle = _cfgbc
	_egfe._bbff.PPr.RPr = _deg.NewCT_ParaRPr()
	return _egfe
}
func (_cbgb *Document) reorderComments() {
	_fda := int64(1)
	_eggc := map[int64]int64{}
	_gbcf := _cbgb._aeg
	for _, _cacd := range _gbcf.CT_Comments.Comment {
		_eggc[_cacd.IdAttr] = _fda
		_cacd.IdAttr = _fda
		_fda++
	}
	for _, _agc := range _cbgb.Paragraphs() {
		for _, _ffff := range _agc.X().EG_PContent {
			for _, _deca := range _ffff.PContentChoice.EG_ContentRunContent {
				for _, _eeff := range _deca.ContentRunContentChoice.EG_RunLevelElts {
					for _, _efce := range _eeff.RunLevelEltsChoice.EG_RangeMarkupElements {
						if _efce.RangeMarkupElementsChoice.CommentRangeStart != nil {
							_efce.RangeMarkupElementsChoice.CommentRangeStart.IdAttr = _eggc[_efce.RangeMarkupElementsChoice.CommentRangeStart.IdAttr]
						} else if _efce.RangeMarkupElementsChoice.CommentRangeEnd != nil {
							_efce.RangeMarkupElementsChoice.CommentRangeEnd.IdAttr = _eggc[_efce.RangeMarkupElementsChoice.CommentRangeEnd.IdAttr]
						}
					}
				}
				if _deca.ContentRunContentChoice.R != nil {
					for _, _gcd := range _deca.ContentRunContentChoice.R.EG_RunInnerContent {
						if _gcd.RunInnerContentChoice.CommentReference != nil {
							_gcd.RunInnerContentChoice.CommentReference.IdAttr = _eggc[_gcd.RunInnerContentChoice.CommentReference.IdAttr]
						}
					}
				}
			}
		}
	}
}

// SetFirstColumn controls the conditional formatting for the first column in a table.
func (_eccdd TableLook) SetFirstColumn(on bool) {
	if !on {
		_eccdd._bfdc.FirstColumnAttr = &_fae.ST_OnOff{}
		_eccdd._bfdc.FirstColumnAttr.ST_OnOff1 = _fae.ST_OnOff1Off
	} else {
		_eccdd._bfdc.FirstColumnAttr = &_fae.ST_OnOff{}
		_eccdd._bfdc.FirstColumnAttr.ST_OnOff1 = _fae.ST_OnOff1On
	}
}

// X returns the inner wrapped XML type.
func (_feee TableLook) X() *_deg.CT_TblLook { return _feee._bfdc }

// SetMultiLevelType sets the multilevel type.
func (_cdffgd NumberingDefinition) SetMultiLevelType(t _deg.ST_MultiLevelType) {
	if t == _deg.ST_MultiLevelTypeUnset {
		_cdffgd._feab.MultiLevelType = nil
	} else {
		_cdffgd._feab.MultiLevelType = _deg.NewCT_MultiLevelType()
		_cdffgd._feab.MultiLevelType.ValAttr = t
	}
}
func (_bcbd *Document) insertParagraph(_aagg Paragraph, _cdcg bool) Paragraph {
	if _bcbd._effc.Body == nil {
		return _bcbd.AddParagraph()
	}
	_fcbc := _aagg.X()
	for _, _gafc := range _bcbd._effc.Body.EG_BlockLevelElts {
		for _, _bcbb := range _gafc.BlockLevelEltsChoice.EG_ContentBlockContent {
			for _bbfa, _gbgg := range _bcbb.ContentBlockContentChoice.P {
				if _gbgg == _fcbc {
					_effg := _deg.NewCT_P()
					_bcbb.ContentBlockContentChoice.P = append(_bcbb.ContentBlockContentChoice.P, nil)
					if _cdcg {
						copy(_bcbb.ContentBlockContentChoice.P[_bbfa+1:], _bcbb.ContentBlockContentChoice.P[_bbfa:])
						_bcbb.ContentBlockContentChoice.P[_bbfa] = _effg
					} else {
						copy(_bcbb.ContentBlockContentChoice.P[_bbfa+2:], _bcbb.ContentBlockContentChoice.P[_bbfa+1:])
						_bcbb.ContentBlockContentChoice.P[_bbfa+1] = _effg
					}
					return Paragraph{_bcbd, _effg}
				}
			}
			for _, _cgbd := range _bcbb.ContentBlockContentChoice.Tbl {
				for _, _egbd := range _cgbd.EG_ContentRowContent {
					for _, _cbd := range _egbd.ContentRowContentChoice.Tr {
						for _, _acdg := range _cbd.EG_ContentCellContent {
							for _, _baff := range _acdg.ContentCellContentChoice.Tc {
								for _, _bffd := range _baff.EG_BlockLevelElts {
									for _, _bdg := range _bffd.BlockLevelEltsChoice.EG_ContentBlockContent {
										for _ebcg, _gega := range _bdg.ContentBlockContentChoice.P {
											if _gega == _fcbc {
												_dfbg := _deg.NewCT_P()
												_bdg.ContentBlockContentChoice.P = append(_bdg.ContentBlockContentChoice.P, nil)
												if _cdcg {
													copy(_bdg.ContentBlockContentChoice.P[_ebcg+1:], _bdg.ContentBlockContentChoice.P[_ebcg:])
													_bdg.ContentBlockContentChoice.P[_ebcg] = _dfbg
												} else {
													copy(_bdg.ContentBlockContentChoice.P[_ebcg+2:], _bdg.ContentBlockContentChoice.P[_ebcg+1:])
													_bdg.ContentBlockContentChoice.P[_ebcg+1] = _dfbg
												}
												return Paragraph{_bcbd, _dfbg}
											}
										}
									}
								}
							}
						}
					}
				}
			}
			if _bcbb.ContentBlockContentChoice.Sdt != nil && _bcbb.ContentBlockContentChoice.Sdt.SdtContent != nil {
				for _, _ebg := range _bcbb.ContentBlockContentChoice.Sdt.SdtContent.EG_ContentBlockContent {
					for _bbbed, _befb := range _ebg.ContentBlockContentChoice.P {
						if _befb == _fcbc {
							_abdaf := _deg.NewCT_P()
							_ebg.ContentBlockContentChoice.P = append(_ebg.ContentBlockContentChoice.P, nil)
							if _cdcg {
								copy(_ebg.ContentBlockContentChoice.P[_bbbed+1:], _ebg.ContentBlockContentChoice.P[_bbbed:])
								_ebg.ContentBlockContentChoice.P[_bbbed] = _abdaf
							} else {
								copy(_ebg.ContentBlockContentChoice.P[_bbbed+2:], _ebg.ContentBlockContentChoice.P[_bbbed+1:])
								_ebg.ContentBlockContentChoice.P[_bbbed+1] = _abdaf
							}
							return Paragraph{_bcbd, _abdaf}
						}
					}
				}
			}
		}
	}
	return _bcbd.AddParagraph()
}

// SetOpacity sets opacity of watermark text in range 0.0 - 1.0, where is 1.0 is the default value.
func (_abcce *WatermarkText) SetOpacity(value float64) {
	if _abcce._cfbf != nil {
		_fedg := _abcce._cfbf.ShapeChoice
		for _, _bccgc := range _fedg {
			if _bccgc.ShapeElementsChoice.Fill != nil {
				_fdbg := _b.Itoa((int)(65536.0*value)) + "\u0066"
				_bccgc.ShapeElementsChoice.Fill.OpacityAttr = &_fdbg
			}
		}
	}
}

// RemoveParagraph removes a paragraph from the footnote.
func (_feae Footnote) RemoveParagraph(p Paragraph) {
	for _, _cbfb := range _feae.content() {
		for _dbbd, _cbggg := range _cbfb.ContentBlockContentChoice.P {
			if _cbggg == p._bbff {
				copy(_cbfb.ContentBlockContentChoice.P[_dbbd:], _cbfb.ContentBlockContentChoice.P[_dbbd+1:])
				_cbfb.ContentBlockContentChoice.P = _cbfb.ContentBlockContentChoice.P[0 : len(_cbfb.ContentBlockContentChoice.P)-1]
				return
			}
		}
	}
}

// NewTableWidth returns a newly intialized TableWidth
func NewTableWidth() TableWidth { return TableWidth{_deg.NewCT_TblWidth()} }

// SetYOffset sets the Y offset for an image relative to the origin.
func (_ed AnchoredDrawing) SetYOffset(y _cdg.Distance) {
	_ed._bgc.PositionV.PosVChoice = &_deg.WdCT_PosVChoice{}
	_ed._bgc.PositionV.PosVChoice.PosOffset = _e.Int32(int32(y / _cdg.EMU))
}

// ExtractFromHeader returns text from the document header as an array of TextItems.
func ExtractFromHeader(header *_deg.Hdr) []TextItem {
	var _dbadg []TextItem
	for _, _fdgc := range header.EG_BlockLevelElts {
		_dbadg = append(_dbadg, _aege(_fdgc.BlockLevelEltsChoice.EG_ContentBlockContent, nil)...)
	}
	return _dbadg
}
